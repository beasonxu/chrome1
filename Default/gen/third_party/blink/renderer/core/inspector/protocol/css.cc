// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "third_party/blink/renderer/core/inspector/protocol/css.h"

#include "third_party/blink/renderer/core/inspector/protocol/protocol.h"

#include "third_party/inspector_protocol/crdtp/cbor.h"
#include "third_party/inspector_protocol/crdtp/find_by_first.h"
#include "third_party/inspector_protocol/crdtp/span.h"

namespace blink {
namespace protocol {
namespace CSS {

using crdtp::DeserializerState;
using crdtp::ProtocolTypeTraits;

// ------------- Enum values from types.

const char Metainfo::domainName[] = "CSS";
const char Metainfo::commandPrefix[] = "CSS.";
const char Metainfo::version[] = "1.3";


namespace StyleSheetOriginEnum {
const char Injected[] = "injected";
const char UserAgent[] = "user-agent";
const char Inspector[] = "inspector";
const char Regular[] = "regular";
} // namespace StyleSheetOriginEnum


CRDTP_BEGIN_DESERIALIZER(PseudoElementMatches)
    CRDTP_DESERIALIZE_FIELD("matches", m_matches),
    CRDTP_DESERIALIZE_FIELD_OPT("pseudoIdentifier", m_pseudoIdentifier),
    CRDTP_DESERIALIZE_FIELD("pseudoType", m_pseudoType),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(PseudoElementMatches)
    CRDTP_SERIALIZE_FIELD("pseudoType", m_pseudoType);
    CRDTP_SERIALIZE_FIELD("pseudoIdentifier", m_pseudoIdentifier);
    CRDTP_SERIALIZE_FIELD("matches", m_matches);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(InheritedStyleEntry)
    CRDTP_DESERIALIZE_FIELD_OPT("inlineStyle", m_inlineStyle),
    CRDTP_DESERIALIZE_FIELD("matchedCSSRules", m_matchedCSSRules),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(InheritedStyleEntry)
    CRDTP_SERIALIZE_FIELD("inlineStyle", m_inlineStyle);
    CRDTP_SERIALIZE_FIELD("matchedCSSRules", m_matchedCSSRules);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(InheritedPseudoElementMatches)
    CRDTP_DESERIALIZE_FIELD("pseudoElements", m_pseudoElements),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(InheritedPseudoElementMatches)
    CRDTP_SERIALIZE_FIELD("pseudoElements", m_pseudoElements);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(RuleMatch)
    CRDTP_DESERIALIZE_FIELD("matchingSelectors", m_matchingSelectors),
    CRDTP_DESERIALIZE_FIELD("rule", m_rule),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(RuleMatch)
    CRDTP_SERIALIZE_FIELD("rule", m_rule);
    CRDTP_SERIALIZE_FIELD("matchingSelectors", m_matchingSelectors);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(Value)
    CRDTP_DESERIALIZE_FIELD_OPT("range", m_range),
    CRDTP_DESERIALIZE_FIELD("text", m_text),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(Value)
    CRDTP_SERIALIZE_FIELD("text", m_text);
    CRDTP_SERIALIZE_FIELD("range", m_range);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(SelectorList)
    CRDTP_DESERIALIZE_FIELD("selectors", m_selectors),
    CRDTP_DESERIALIZE_FIELD("text", m_text),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(SelectorList)
    CRDTP_SERIALIZE_FIELD("selectors", m_selectors);
    CRDTP_SERIALIZE_FIELD("text", m_text);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(CSSStyleSheetHeader)
    CRDTP_DESERIALIZE_FIELD("disabled", m_disabled),
    CRDTP_DESERIALIZE_FIELD("endColumn", m_endColumn),
    CRDTP_DESERIALIZE_FIELD("endLine", m_endLine),
    CRDTP_DESERIALIZE_FIELD("frameId", m_frameId),
    CRDTP_DESERIALIZE_FIELD_OPT("hasSourceURL", m_hasSourceURL),
    CRDTP_DESERIALIZE_FIELD("isConstructed", m_isConstructed),
    CRDTP_DESERIALIZE_FIELD("isInline", m_isInline),
    CRDTP_DESERIALIZE_FIELD("isMutable", m_isMutable),
    CRDTP_DESERIALIZE_FIELD("length", m_length),
    CRDTP_DESERIALIZE_FIELD("origin", m_origin),
    CRDTP_DESERIALIZE_FIELD_OPT("ownerNode", m_ownerNode),
    CRDTP_DESERIALIZE_FIELD_OPT("sourceMapURL", m_sourceMapURL),
    CRDTP_DESERIALIZE_FIELD("sourceURL", m_sourceURL),
    CRDTP_DESERIALIZE_FIELD("startColumn", m_startColumn),
    CRDTP_DESERIALIZE_FIELD("startLine", m_startLine),
    CRDTP_DESERIALIZE_FIELD("styleSheetId", m_styleSheetId),
    CRDTP_DESERIALIZE_FIELD("title", m_title),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(CSSStyleSheetHeader)
    CRDTP_SERIALIZE_FIELD("styleSheetId", m_styleSheetId);
    CRDTP_SERIALIZE_FIELD("frameId", m_frameId);
    CRDTP_SERIALIZE_FIELD("sourceURL", m_sourceURL);
    CRDTP_SERIALIZE_FIELD("sourceMapURL", m_sourceMapURL);
    CRDTP_SERIALIZE_FIELD("origin", m_origin);
    CRDTP_SERIALIZE_FIELD("title", m_title);
    CRDTP_SERIALIZE_FIELD("ownerNode", m_ownerNode);
    CRDTP_SERIALIZE_FIELD("disabled", m_disabled);
    CRDTP_SERIALIZE_FIELD("hasSourceURL", m_hasSourceURL);
    CRDTP_SERIALIZE_FIELD("isInline", m_isInline);
    CRDTP_SERIALIZE_FIELD("isMutable", m_isMutable);
    CRDTP_SERIALIZE_FIELD("isConstructed", m_isConstructed);
    CRDTP_SERIALIZE_FIELD("startLine", m_startLine);
    CRDTP_SERIALIZE_FIELD("startColumn", m_startColumn);
    CRDTP_SERIALIZE_FIELD("length", m_length);
    CRDTP_SERIALIZE_FIELD("endLine", m_endLine);
    CRDTP_SERIALIZE_FIELD("endColumn", m_endColumn);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(CSSRule)
    CRDTP_DESERIALIZE_FIELD_OPT("containerQueries", m_containerQueries),
    CRDTP_DESERIALIZE_FIELD_OPT("layers", m_layers),
    CRDTP_DESERIALIZE_FIELD_OPT("media", m_media),
    CRDTP_DESERIALIZE_FIELD("origin", m_origin),
    CRDTP_DESERIALIZE_FIELD_OPT("scopes", m_scopes),
    CRDTP_DESERIALIZE_FIELD("selectorList", m_selectorList),
    CRDTP_DESERIALIZE_FIELD("style", m_style),
    CRDTP_DESERIALIZE_FIELD_OPT("styleSheetId", m_styleSheetId),
    CRDTP_DESERIALIZE_FIELD_OPT("supports", m_supports),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(CSSRule)
    CRDTP_SERIALIZE_FIELD("styleSheetId", m_styleSheetId);
    CRDTP_SERIALIZE_FIELD("selectorList", m_selectorList);
    CRDTP_SERIALIZE_FIELD("origin", m_origin);
    CRDTP_SERIALIZE_FIELD("style", m_style);
    CRDTP_SERIALIZE_FIELD("media", m_media);
    CRDTP_SERIALIZE_FIELD("containerQueries", m_containerQueries);
    CRDTP_SERIALIZE_FIELD("supports", m_supports);
    CRDTP_SERIALIZE_FIELD("layers", m_layers);
    CRDTP_SERIALIZE_FIELD("scopes", m_scopes);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(RuleUsage)
    CRDTP_DESERIALIZE_FIELD("endOffset", m_endOffset),
    CRDTP_DESERIALIZE_FIELD("startOffset", m_startOffset),
    CRDTP_DESERIALIZE_FIELD("styleSheetId", m_styleSheetId),
    CRDTP_DESERIALIZE_FIELD("used", m_used),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(RuleUsage)
    CRDTP_SERIALIZE_FIELD("styleSheetId", m_styleSheetId);
    CRDTP_SERIALIZE_FIELD("startOffset", m_startOffset);
    CRDTP_SERIALIZE_FIELD("endOffset", m_endOffset);
    CRDTP_SERIALIZE_FIELD("used", m_used);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(SourceRange)
    CRDTP_DESERIALIZE_FIELD("endColumn", m_endColumn),
    CRDTP_DESERIALIZE_FIELD("endLine", m_endLine),
    CRDTP_DESERIALIZE_FIELD("startColumn", m_startColumn),
    CRDTP_DESERIALIZE_FIELD("startLine", m_startLine),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(SourceRange)
    CRDTP_SERIALIZE_FIELD("startLine", m_startLine);
    CRDTP_SERIALIZE_FIELD("startColumn", m_startColumn);
    CRDTP_SERIALIZE_FIELD("endLine", m_endLine);
    CRDTP_SERIALIZE_FIELD("endColumn", m_endColumn);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(ShorthandEntry)
    CRDTP_DESERIALIZE_FIELD_OPT("important", m_important),
    CRDTP_DESERIALIZE_FIELD("name", m_name),
    CRDTP_DESERIALIZE_FIELD("value", m_value),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(ShorthandEntry)
    CRDTP_SERIALIZE_FIELD("name", m_name);
    CRDTP_SERIALIZE_FIELD("value", m_value);
    CRDTP_SERIALIZE_FIELD("important", m_important);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(CSSComputedStyleProperty)
    CRDTP_DESERIALIZE_FIELD("name", m_name),
    CRDTP_DESERIALIZE_FIELD("value", m_value),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(CSSComputedStyleProperty)
    CRDTP_SERIALIZE_FIELD("name", m_name);
    CRDTP_SERIALIZE_FIELD("value", m_value);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(CSSStyle)
    CRDTP_DESERIALIZE_FIELD("cssProperties", m_cssProperties),
    CRDTP_DESERIALIZE_FIELD_OPT("cssText", m_cssText),
    CRDTP_DESERIALIZE_FIELD_OPT("range", m_range),
    CRDTP_DESERIALIZE_FIELD("shorthandEntries", m_shorthandEntries),
    CRDTP_DESERIALIZE_FIELD_OPT("styleSheetId", m_styleSheetId),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(CSSStyle)
    CRDTP_SERIALIZE_FIELD("styleSheetId", m_styleSheetId);
    CRDTP_SERIALIZE_FIELD("cssProperties", m_cssProperties);
    CRDTP_SERIALIZE_FIELD("shorthandEntries", m_shorthandEntries);
    CRDTP_SERIALIZE_FIELD("cssText", m_cssText);
    CRDTP_SERIALIZE_FIELD("range", m_range);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(CSSProperty)
    CRDTP_DESERIALIZE_FIELD_OPT("disabled", m_disabled),
    CRDTP_DESERIALIZE_FIELD_OPT("implicit", m_implicit),
    CRDTP_DESERIALIZE_FIELD_OPT("important", m_important),
    CRDTP_DESERIALIZE_FIELD_OPT("longhandProperties", m_longhandProperties),
    CRDTP_DESERIALIZE_FIELD("name", m_name),
    CRDTP_DESERIALIZE_FIELD_OPT("parsedOk", m_parsedOk),
    CRDTP_DESERIALIZE_FIELD_OPT("range", m_range),
    CRDTP_DESERIALIZE_FIELD_OPT("text", m_text),
    CRDTP_DESERIALIZE_FIELD("value", m_value),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(CSSProperty)
    CRDTP_SERIALIZE_FIELD("name", m_name);
    CRDTP_SERIALIZE_FIELD("value", m_value);
    CRDTP_SERIALIZE_FIELD("important", m_important);
    CRDTP_SERIALIZE_FIELD("implicit", m_implicit);
    CRDTP_SERIALIZE_FIELD("text", m_text);
    CRDTP_SERIALIZE_FIELD("parsedOk", m_parsedOk);
    CRDTP_SERIALIZE_FIELD("disabled", m_disabled);
    CRDTP_SERIALIZE_FIELD("range", m_range);
    CRDTP_SERIALIZE_FIELD("longhandProperties", m_longhandProperties);
CRDTP_END_SERIALIZER();



const char* CSSMedia::SourceEnum::MediaRule = "mediaRule";
const char* CSSMedia::SourceEnum::ImportRule = "importRule";
const char* CSSMedia::SourceEnum::LinkedSheet = "linkedSheet";
const char* CSSMedia::SourceEnum::InlineSheet = "inlineSheet";
CRDTP_BEGIN_DESERIALIZER(CSSMedia)
    CRDTP_DESERIALIZE_FIELD_OPT("mediaList", m_mediaList),
    CRDTP_DESERIALIZE_FIELD_OPT("range", m_range),
    CRDTP_DESERIALIZE_FIELD("source", m_source),
    CRDTP_DESERIALIZE_FIELD_OPT("sourceURL", m_sourceURL),
    CRDTP_DESERIALIZE_FIELD_OPT("styleSheetId", m_styleSheetId),
    CRDTP_DESERIALIZE_FIELD("text", m_text),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(CSSMedia)
    CRDTP_SERIALIZE_FIELD("text", m_text);
    CRDTP_SERIALIZE_FIELD("source", m_source);
    CRDTP_SERIALIZE_FIELD("sourceURL", m_sourceURL);
    CRDTP_SERIALIZE_FIELD("range", m_range);
    CRDTP_SERIALIZE_FIELD("styleSheetId", m_styleSheetId);
    CRDTP_SERIALIZE_FIELD("mediaList", m_mediaList);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(MediaQuery)
    CRDTP_DESERIALIZE_FIELD("active", m_active),
    CRDTP_DESERIALIZE_FIELD("expressions", m_expressions),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(MediaQuery)
    CRDTP_SERIALIZE_FIELD("expressions", m_expressions);
    CRDTP_SERIALIZE_FIELD("active", m_active);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(MediaQueryExpression)
    CRDTP_DESERIALIZE_FIELD_OPT("computedLength", m_computedLength),
    CRDTP_DESERIALIZE_FIELD("feature", m_feature),
    CRDTP_DESERIALIZE_FIELD("unit", m_unit),
    CRDTP_DESERIALIZE_FIELD("value", m_value),
    CRDTP_DESERIALIZE_FIELD_OPT("valueRange", m_valueRange),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(MediaQueryExpression)
    CRDTP_SERIALIZE_FIELD("value", m_value);
    CRDTP_SERIALIZE_FIELD("unit", m_unit);
    CRDTP_SERIALIZE_FIELD("feature", m_feature);
    CRDTP_SERIALIZE_FIELD("valueRange", m_valueRange);
    CRDTP_SERIALIZE_FIELD("computedLength", m_computedLength);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(CSSContainerQuery)
    CRDTP_DESERIALIZE_FIELD_OPT("name", m_name),
    CRDTP_DESERIALIZE_FIELD_OPT("range", m_range),
    CRDTP_DESERIALIZE_FIELD_OPT("styleSheetId", m_styleSheetId),
    CRDTP_DESERIALIZE_FIELD("text", m_text),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(CSSContainerQuery)
    CRDTP_SERIALIZE_FIELD("text", m_text);
    CRDTP_SERIALIZE_FIELD("range", m_range);
    CRDTP_SERIALIZE_FIELD("styleSheetId", m_styleSheetId);
    CRDTP_SERIALIZE_FIELD("name", m_name);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(CSSSupports)
    CRDTP_DESERIALIZE_FIELD("active", m_active),
    CRDTP_DESERIALIZE_FIELD_OPT("range", m_range),
    CRDTP_DESERIALIZE_FIELD_OPT("styleSheetId", m_styleSheetId),
    CRDTP_DESERIALIZE_FIELD("text", m_text),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(CSSSupports)
    CRDTP_SERIALIZE_FIELD("text", m_text);
    CRDTP_SERIALIZE_FIELD("active", m_active);
    CRDTP_SERIALIZE_FIELD("range", m_range);
    CRDTP_SERIALIZE_FIELD("styleSheetId", m_styleSheetId);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(CSSScope)
    CRDTP_DESERIALIZE_FIELD_OPT("range", m_range),
    CRDTP_DESERIALIZE_FIELD_OPT("styleSheetId", m_styleSheetId),
    CRDTP_DESERIALIZE_FIELD("text", m_text),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(CSSScope)
    CRDTP_SERIALIZE_FIELD("text", m_text);
    CRDTP_SERIALIZE_FIELD("range", m_range);
    CRDTP_SERIALIZE_FIELD("styleSheetId", m_styleSheetId);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(CSSLayer)
    CRDTP_DESERIALIZE_FIELD_OPT("range", m_range),
    CRDTP_DESERIALIZE_FIELD_OPT("styleSheetId", m_styleSheetId),
    CRDTP_DESERIALIZE_FIELD("text", m_text),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(CSSLayer)
    CRDTP_SERIALIZE_FIELD("text", m_text);
    CRDTP_SERIALIZE_FIELD("range", m_range);
    CRDTP_SERIALIZE_FIELD("styleSheetId", m_styleSheetId);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(CSSLayerData)
    CRDTP_DESERIALIZE_FIELD("name", m_name),
    CRDTP_DESERIALIZE_FIELD("order", m_order),
    CRDTP_DESERIALIZE_FIELD_OPT("subLayers", m_subLayers),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(CSSLayerData)
    CRDTP_SERIALIZE_FIELD("name", m_name);
    CRDTP_SERIALIZE_FIELD("subLayers", m_subLayers);
    CRDTP_SERIALIZE_FIELD("order", m_order);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(PlatformFontUsage)
    CRDTP_DESERIALIZE_FIELD("familyName", m_familyName),
    CRDTP_DESERIALIZE_FIELD("glyphCount", m_glyphCount),
    CRDTP_DESERIALIZE_FIELD("isCustomFont", m_isCustomFont),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(PlatformFontUsage)
    CRDTP_SERIALIZE_FIELD("familyName", m_familyName);
    CRDTP_SERIALIZE_FIELD("isCustomFont", m_isCustomFont);
    CRDTP_SERIALIZE_FIELD("glyphCount", m_glyphCount);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(FontVariationAxis)
    CRDTP_DESERIALIZE_FIELD("defaultValue", m_defaultValue),
    CRDTP_DESERIALIZE_FIELD("maxValue", m_maxValue),
    CRDTP_DESERIALIZE_FIELD("minValue", m_minValue),
    CRDTP_DESERIALIZE_FIELD("name", m_name),
    CRDTP_DESERIALIZE_FIELD("tag", m_tag),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(FontVariationAxis)
    CRDTP_SERIALIZE_FIELD("tag", m_tag);
    CRDTP_SERIALIZE_FIELD("name", m_name);
    CRDTP_SERIALIZE_FIELD("minValue", m_minValue);
    CRDTP_SERIALIZE_FIELD("maxValue", m_maxValue);
    CRDTP_SERIALIZE_FIELD("defaultValue", m_defaultValue);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(FontFace)
    CRDTP_DESERIALIZE_FIELD("fontDisplay", m_fontDisplay),
    CRDTP_DESERIALIZE_FIELD("fontFamily", m_fontFamily),
    CRDTP_DESERIALIZE_FIELD("fontStretch", m_fontStretch),
    CRDTP_DESERIALIZE_FIELD("fontStyle", m_fontStyle),
    CRDTP_DESERIALIZE_FIELD("fontVariant", m_fontVariant),
    CRDTP_DESERIALIZE_FIELD_OPT("fontVariationAxes", m_fontVariationAxes),
    CRDTP_DESERIALIZE_FIELD("fontWeight", m_fontWeight),
    CRDTP_DESERIALIZE_FIELD("platformFontFamily", m_platformFontFamily),
    CRDTP_DESERIALIZE_FIELD("src", m_src),
    CRDTP_DESERIALIZE_FIELD("unicodeRange", m_unicodeRange),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(FontFace)
    CRDTP_SERIALIZE_FIELD("fontFamily", m_fontFamily);
    CRDTP_SERIALIZE_FIELD("fontStyle", m_fontStyle);
    CRDTP_SERIALIZE_FIELD("fontVariant", m_fontVariant);
    CRDTP_SERIALIZE_FIELD("fontWeight", m_fontWeight);
    CRDTP_SERIALIZE_FIELD("fontStretch", m_fontStretch);
    CRDTP_SERIALIZE_FIELD("fontDisplay", m_fontDisplay);
    CRDTP_SERIALIZE_FIELD("unicodeRange", m_unicodeRange);
    CRDTP_SERIALIZE_FIELD("src", m_src);
    CRDTP_SERIALIZE_FIELD("platformFontFamily", m_platformFontFamily);
    CRDTP_SERIALIZE_FIELD("fontVariationAxes", m_fontVariationAxes);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(CSSKeyframesRule)
    CRDTP_DESERIALIZE_FIELD("animationName", m_animationName),
    CRDTP_DESERIALIZE_FIELD("keyframes", m_keyframes),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(CSSKeyframesRule)
    CRDTP_SERIALIZE_FIELD("animationName", m_animationName);
    CRDTP_SERIALIZE_FIELD("keyframes", m_keyframes);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(CSSKeyframeRule)
    CRDTP_DESERIALIZE_FIELD("keyText", m_keyText),
    CRDTP_DESERIALIZE_FIELD("origin", m_origin),
    CRDTP_DESERIALIZE_FIELD("style", m_style),
    CRDTP_DESERIALIZE_FIELD_OPT("styleSheetId", m_styleSheetId),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(CSSKeyframeRule)
    CRDTP_SERIALIZE_FIELD("styleSheetId", m_styleSheetId);
    CRDTP_SERIALIZE_FIELD("origin", m_origin);
    CRDTP_SERIALIZE_FIELD("keyText", m_keyText);
    CRDTP_SERIALIZE_FIELD("style", m_style);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(StyleDeclarationEdit)
    CRDTP_DESERIALIZE_FIELD("range", m_range),
    CRDTP_DESERIALIZE_FIELD("styleSheetId", m_styleSheetId),
    CRDTP_DESERIALIZE_FIELD("text", m_text),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(StyleDeclarationEdit)
    CRDTP_SERIALIZE_FIELD("styleSheetId", m_styleSheetId);
    CRDTP_SERIALIZE_FIELD("range", m_range);
    CRDTP_SERIALIZE_FIELD("text", m_text);
CRDTP_END_SERIALIZER();


// ------------- Enum values from params.


// ------------- Frontend notifications.

void Frontend::fontsUpdated(Maybe<protocol::CSS::FontFace> font)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("font"), font);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("CSS.fontsUpdated", serializer.Finish()));
}

void Frontend::mediaQueryResultChanged()
{
    if (!frontend_channel_)
        return;
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("CSS.mediaQueryResultChanged"));
}

void Frontend::styleSheetAdded(std::unique_ptr<protocol::CSS::CSSStyleSheetHeader> header)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("header"), header);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("CSS.styleSheetAdded", serializer.Finish()));
}

void Frontend::styleSheetChanged(const String& styleSheetId)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("styleSheetId"), styleSheetId);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("CSS.styleSheetChanged", serializer.Finish()));
}

void Frontend::styleSheetRemoved(const String& styleSheetId)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("styleSheetId"), styleSheetId);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("CSS.styleSheetRemoved", serializer.Finish()));
}

void Frontend::flush()
{
    frontend_channel_->FlushProtocolNotifications();
}

void Frontend::sendRawNotification(std::unique_ptr<Serializable> notification)
{
    frontend_channel_->SendProtocolNotification(std::move(notification));
}

// --------------------- Dispatcher.

class DomainDispatcherImpl : public protocol::DomainDispatcher {
public:
    DomainDispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DomainDispatcher(frontendChannel)
        , m_backend(backend) {}
    ~DomainDispatcherImpl() override { }

    using CallHandler = void (DomainDispatcherImpl::*)(const crdtp::Dispatchable& dispatchable);

    std::function<void(const crdtp::Dispatchable&)> Dispatch(crdtp::span<uint8_t> command_name) override;

    void addRule(const crdtp::Dispatchable& dispatchable);
    void collectClassNames(const crdtp::Dispatchable& dispatchable);
    void createStyleSheet(const crdtp::Dispatchable& dispatchable);
    void disable(const crdtp::Dispatchable& dispatchable);
    void enable(const crdtp::Dispatchable& dispatchable);
    void forcePseudoState(const crdtp::Dispatchable& dispatchable);
    void getBackgroundColors(const crdtp::Dispatchable& dispatchable);
    void getComputedStyleForNode(const crdtp::Dispatchable& dispatchable);
    void getInlineStylesForNode(const crdtp::Dispatchable& dispatchable);
    void getMatchedStylesForNode(const crdtp::Dispatchable& dispatchable);
    void getMediaQueries(const crdtp::Dispatchable& dispatchable);
    void getPlatformFontsForNode(const crdtp::Dispatchable& dispatchable);
    void getStyleSheetText(const crdtp::Dispatchable& dispatchable);
    void getLayersForNode(const crdtp::Dispatchable& dispatchable);
    void trackComputedStyleUpdates(const crdtp::Dispatchable& dispatchable);
    void takeComputedStyleUpdates(const crdtp::Dispatchable& dispatchable);
    void setEffectivePropertyValueForNode(const crdtp::Dispatchable& dispatchable);
    void setKeyframeKey(const crdtp::Dispatchable& dispatchable);
    void setMediaText(const crdtp::Dispatchable& dispatchable);
    void setContainerQueryText(const crdtp::Dispatchable& dispatchable);
    void setSupportsText(const crdtp::Dispatchable& dispatchable);
    void setScopeText(const crdtp::Dispatchable& dispatchable);
    void setRuleSelector(const crdtp::Dispatchable& dispatchable);
    void setStyleSheetText(const crdtp::Dispatchable& dispatchable);
    void setStyleTexts(const crdtp::Dispatchable& dispatchable);
    void startRuleUsageTracking(const crdtp::Dispatchable& dispatchable);
    void stopRuleUsageTracking(const crdtp::Dispatchable& dispatchable);
    void takeCoverageDelta(const crdtp::Dispatchable& dispatchable);
    void setLocalFontsEnabled(const crdtp::Dispatchable& dispatchable);
 protected:
    Backend* m_backend;
};

namespace {
// This helper method with a static map of command methods (instance methods
// of DomainDispatcherImpl declared just above) by their name is used immediately below,
// in the DomainDispatcherImpl::Dispatch method.
DomainDispatcherImpl::CallHandler CommandByName(crdtp::span<uint8_t> command_name) {
  static auto* commands = [](){
    auto* commands = new std::vector<std::pair<crdtp::span<uint8_t>,
                              DomainDispatcherImpl::CallHandler>>{
    {
          crdtp::SpanFrom("addRule"),
          &DomainDispatcherImpl::addRule
    },
    {
          crdtp::SpanFrom("collectClassNames"),
          &DomainDispatcherImpl::collectClassNames
    },
    {
          crdtp::SpanFrom("createStyleSheet"),
          &DomainDispatcherImpl::createStyleSheet
    },
    {
          crdtp::SpanFrom("disable"),
          &DomainDispatcherImpl::disable
    },
    {
          crdtp::SpanFrom("enable"),
          &DomainDispatcherImpl::enable
    },
    {
          crdtp::SpanFrom("forcePseudoState"),
          &DomainDispatcherImpl::forcePseudoState
    },
    {
          crdtp::SpanFrom("getBackgroundColors"),
          &DomainDispatcherImpl::getBackgroundColors
    },
    {
          crdtp::SpanFrom("getComputedStyleForNode"),
          &DomainDispatcherImpl::getComputedStyleForNode
    },
    {
          crdtp::SpanFrom("getInlineStylesForNode"),
          &DomainDispatcherImpl::getInlineStylesForNode
    },
    {
          crdtp::SpanFrom("getLayersForNode"),
          &DomainDispatcherImpl::getLayersForNode
    },
    {
          crdtp::SpanFrom("getMatchedStylesForNode"),
          &DomainDispatcherImpl::getMatchedStylesForNode
    },
    {
          crdtp::SpanFrom("getMediaQueries"),
          &DomainDispatcherImpl::getMediaQueries
    },
    {
          crdtp::SpanFrom("getPlatformFontsForNode"),
          &DomainDispatcherImpl::getPlatformFontsForNode
    },
    {
          crdtp::SpanFrom("getStyleSheetText"),
          &DomainDispatcherImpl::getStyleSheetText
    },
    {
          crdtp::SpanFrom("setContainerQueryText"),
          &DomainDispatcherImpl::setContainerQueryText
    },
    {
          crdtp::SpanFrom("setEffectivePropertyValueForNode"),
          &DomainDispatcherImpl::setEffectivePropertyValueForNode
    },
    {
          crdtp::SpanFrom("setKeyframeKey"),
          &DomainDispatcherImpl::setKeyframeKey
    },
    {
          crdtp::SpanFrom("setLocalFontsEnabled"),
          &DomainDispatcherImpl::setLocalFontsEnabled
    },
    {
          crdtp::SpanFrom("setMediaText"),
          &DomainDispatcherImpl::setMediaText
    },
    {
          crdtp::SpanFrom("setRuleSelector"),
          &DomainDispatcherImpl::setRuleSelector
    },
    {
          crdtp::SpanFrom("setScopeText"),
          &DomainDispatcherImpl::setScopeText
    },
    {
          crdtp::SpanFrom("setStyleSheetText"),
          &DomainDispatcherImpl::setStyleSheetText
    },
    {
          crdtp::SpanFrom("setStyleTexts"),
          &DomainDispatcherImpl::setStyleTexts
    },
    {
          crdtp::SpanFrom("setSupportsText"),
          &DomainDispatcherImpl::setSupportsText
    },
    {
          crdtp::SpanFrom("startRuleUsageTracking"),
          &DomainDispatcherImpl::startRuleUsageTracking
    },
    {
          crdtp::SpanFrom("stopRuleUsageTracking"),
          &DomainDispatcherImpl::stopRuleUsageTracking
    },
    {
          crdtp::SpanFrom("takeComputedStyleUpdates"),
          &DomainDispatcherImpl::takeComputedStyleUpdates
    },
    {
          crdtp::SpanFrom("takeCoverageDelta"),
          &DomainDispatcherImpl::takeCoverageDelta
    },
    {
          crdtp::SpanFrom("trackComputedStyleUpdates"),
          &DomainDispatcherImpl::trackComputedStyleUpdates
    },
    };
    return commands;
  }();
  return crdtp::FindByFirst<DomainDispatcherImpl::CallHandler>(*commands, command_name, nullptr);
}
}  // namespace

std::function<void(const crdtp::Dispatchable&)> DomainDispatcherImpl::Dispatch(crdtp::span<uint8_t> command_name) {
  CallHandler handler = CommandByName(command_name);
  if (!handler) return nullptr;

  return [this, handler](const crdtp::Dispatchable& dispatchable) {
    (this->*handler)(dispatchable);
  };
}


namespace {

struct addRuleParams : public crdtp::DeserializableProtocolObject<addRuleParams> {
    String styleSheetId;
    String ruleText;
    std::unique_ptr<protocol::CSS::SourceRange> location;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(addRuleParams)
    CRDTP_DESERIALIZE_FIELD("location", location),
    CRDTP_DESERIALIZE_FIELD("ruleText", ruleText),
    CRDTP_DESERIALIZE_FIELD("styleSheetId", styleSheetId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::addRule(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    addRuleParams params;
    if (!addRuleParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::CSS::CSSRule> out_rule;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->addRule(params.styleSheetId, params.ruleText, std::move(params.location), &out_rule);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.addRule"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("rule"), out_rule);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct collectClassNamesParams : public crdtp::DeserializableProtocolObject<collectClassNamesParams> {
    String styleSheetId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(collectClassNamesParams)
    CRDTP_DESERIALIZE_FIELD("styleSheetId", styleSheetId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::collectClassNames(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    collectClassNamesParams params;
    if (!collectClassNamesParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::Array<String>> out_classNames;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->collectClassNames(params.styleSheetId, &out_classNames);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.collectClassNames"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("classNames"), out_classNames);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct createStyleSheetParams : public crdtp::DeserializableProtocolObject<createStyleSheetParams> {
    String frameId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(createStyleSheetParams)
    CRDTP_DESERIALIZE_FIELD("frameId", frameId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::createStyleSheet(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    createStyleSheetParams params;
    if (!createStyleSheetParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    String out_styleSheetId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->createStyleSheet(params.frameId, &out_styleSheetId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.createStyleSheet"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("styleSheetId"), out_styleSheetId);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::disable(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->disable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.disable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

class EnableCallbackImpl : public Backend::EnableCallback, public DomainDispatcher::Callback {
public:
    EnableCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("CSS.enable"), message) { }

    void sendSuccess() override
    {
        crdtp::ObjectSerializer serializer;
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {


}  // namespace

void DomainDispatcherImpl::enable(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    m_backend->enable(std::make_unique<EnableCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

namespace {

struct forcePseudoStateParams : public crdtp::DeserializableProtocolObject<forcePseudoStateParams> {
    int nodeId;
    std::unique_ptr<protocol::Array<String>> forcedPseudoClasses;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(forcePseudoStateParams)
    CRDTP_DESERIALIZE_FIELD("forcedPseudoClasses", forcedPseudoClasses),
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::forcePseudoState(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    forcePseudoStateParams params;
    if (!forcePseudoStateParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->forcePseudoState(params.nodeId, std::move(params.forcedPseudoClasses));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.forcePseudoState"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct getBackgroundColorsParams : public crdtp::DeserializableProtocolObject<getBackgroundColorsParams> {
    int nodeId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getBackgroundColorsParams)
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getBackgroundColors(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getBackgroundColorsParams params;
    if (!getBackgroundColorsParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    Maybe<protocol::Array<String>> out_backgroundColors;
    Maybe<String> out_computedFontSize;
    Maybe<String> out_computedFontWeight;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getBackgroundColors(params.nodeId, &out_backgroundColors, &out_computedFontSize, &out_computedFontWeight);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.getBackgroundColors"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("backgroundColors"), out_backgroundColors);
          serializer.AddField(crdtp::MakeSpan("computedFontSize"), out_computedFontSize);
          serializer.AddField(crdtp::MakeSpan("computedFontWeight"), out_computedFontWeight);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getComputedStyleForNodeParams : public crdtp::DeserializableProtocolObject<getComputedStyleForNodeParams> {
    int nodeId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getComputedStyleForNodeParams)
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getComputedStyleForNode(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getComputedStyleForNodeParams params;
    if (!getComputedStyleForNodeParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::CSS::CSSComputedStyleProperty>> out_computedStyle;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getComputedStyleForNode(params.nodeId, &out_computedStyle);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.getComputedStyleForNode"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("computedStyle"), out_computedStyle);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getInlineStylesForNodeParams : public crdtp::DeserializableProtocolObject<getInlineStylesForNodeParams> {
    int nodeId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getInlineStylesForNodeParams)
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getInlineStylesForNode(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getInlineStylesForNodeParams params;
    if (!getInlineStylesForNodeParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    Maybe<protocol::CSS::CSSStyle> out_inlineStyle;
    Maybe<protocol::CSS::CSSStyle> out_attributesStyle;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getInlineStylesForNode(params.nodeId, &out_inlineStyle, &out_attributesStyle);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.getInlineStylesForNode"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("inlineStyle"), out_inlineStyle);
          serializer.AddField(crdtp::MakeSpan("attributesStyle"), out_attributesStyle);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getMatchedStylesForNodeParams : public crdtp::DeserializableProtocolObject<getMatchedStylesForNodeParams> {
    int nodeId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getMatchedStylesForNodeParams)
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getMatchedStylesForNode(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getMatchedStylesForNodeParams params;
    if (!getMatchedStylesForNodeParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    Maybe<protocol::CSS::CSSStyle> out_inlineStyle;
    Maybe<protocol::CSS::CSSStyle> out_attributesStyle;
    Maybe<protocol::Array<protocol::CSS::RuleMatch>> out_matchedCSSRules;
    Maybe<protocol::Array<protocol::CSS::PseudoElementMatches>> out_pseudoElements;
    Maybe<protocol::Array<protocol::CSS::InheritedStyleEntry>> out_inherited;
    Maybe<protocol::Array<protocol::CSS::InheritedPseudoElementMatches>> out_inheritedPseudoElements;
    Maybe<protocol::Array<protocol::CSS::CSSKeyframesRule>> out_cssKeyframesRules;
    Maybe<int> out_parentLayoutNodeId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getMatchedStylesForNode(params.nodeId, &out_inlineStyle, &out_attributesStyle, &out_matchedCSSRules, &out_pseudoElements, &out_inherited, &out_inheritedPseudoElements, &out_cssKeyframesRules, &out_parentLayoutNodeId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.getMatchedStylesForNode"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("inlineStyle"), out_inlineStyle);
          serializer.AddField(crdtp::MakeSpan("attributesStyle"), out_attributesStyle);
          serializer.AddField(crdtp::MakeSpan("matchedCSSRules"), out_matchedCSSRules);
          serializer.AddField(crdtp::MakeSpan("pseudoElements"), out_pseudoElements);
          serializer.AddField(crdtp::MakeSpan("inherited"), out_inherited);
          serializer.AddField(crdtp::MakeSpan("inheritedPseudoElements"), out_inheritedPseudoElements);
          serializer.AddField(crdtp::MakeSpan("cssKeyframesRules"), out_cssKeyframesRules);
          serializer.AddField(crdtp::MakeSpan("parentLayoutNodeId"), out_parentLayoutNodeId);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::getMediaQueries(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::CSS::CSSMedia>> out_medias;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getMediaQueries(&out_medias);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.getMediaQueries"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("medias"), out_medias);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getPlatformFontsForNodeParams : public crdtp::DeserializableProtocolObject<getPlatformFontsForNodeParams> {
    int nodeId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getPlatformFontsForNodeParams)
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getPlatformFontsForNode(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getPlatformFontsForNodeParams params;
    if (!getPlatformFontsForNodeParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::CSS::PlatformFontUsage>> out_fonts;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getPlatformFontsForNode(params.nodeId, &out_fonts);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.getPlatformFontsForNode"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("fonts"), out_fonts);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getStyleSheetTextParams : public crdtp::DeserializableProtocolObject<getStyleSheetTextParams> {
    String styleSheetId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getStyleSheetTextParams)
    CRDTP_DESERIALIZE_FIELD("styleSheetId", styleSheetId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getStyleSheetText(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getStyleSheetTextParams params;
    if (!getStyleSheetTextParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    String out_text;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getStyleSheetText(params.styleSheetId, &out_text);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.getStyleSheetText"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("text"), out_text);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getLayersForNodeParams : public crdtp::DeserializableProtocolObject<getLayersForNodeParams> {
    int nodeId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getLayersForNodeParams)
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getLayersForNode(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getLayersForNodeParams params;
    if (!getLayersForNodeParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::CSS::CSSLayerData> out_rootLayer;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getLayersForNode(params.nodeId, &out_rootLayer);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.getLayersForNode"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("rootLayer"), out_rootLayer);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct trackComputedStyleUpdatesParams : public crdtp::DeserializableProtocolObject<trackComputedStyleUpdatesParams> {
    std::unique_ptr<protocol::Array<protocol::CSS::CSSComputedStyleProperty>> propertiesToTrack;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(trackComputedStyleUpdatesParams)
    CRDTP_DESERIALIZE_FIELD("propertiesToTrack", propertiesToTrack),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::trackComputedStyleUpdates(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    trackComputedStyleUpdatesParams params;
    if (!trackComputedStyleUpdatesParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->trackComputedStyleUpdates(std::move(params.propertiesToTrack));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.trackComputedStyleUpdates"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

class TakeComputedStyleUpdatesCallbackImpl : public Backend::TakeComputedStyleUpdatesCallback, public DomainDispatcher::Callback {
public:
    TakeComputedStyleUpdatesCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("CSS.takeComputedStyleUpdates"), message) { }

    void sendSuccess(std::unique_ptr<protocol::Array<int>> nodeIds) override
    {
        crdtp::ObjectSerializer serializer;
        serializer.AddField(crdtp::MakeSpan("nodeIds"), nodeIds);
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {


}  // namespace

void DomainDispatcherImpl::takeComputedStyleUpdates(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    m_backend->takeComputedStyleUpdates(std::make_unique<TakeComputedStyleUpdatesCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

namespace {

struct setEffectivePropertyValueForNodeParams : public crdtp::DeserializableProtocolObject<setEffectivePropertyValueForNodeParams> {
    int nodeId;
    String propertyName;
    String value;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setEffectivePropertyValueForNodeParams)
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
    CRDTP_DESERIALIZE_FIELD("propertyName", propertyName),
    CRDTP_DESERIALIZE_FIELD("value", value),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setEffectivePropertyValueForNode(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setEffectivePropertyValueForNodeParams params;
    if (!setEffectivePropertyValueForNodeParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setEffectivePropertyValueForNode(params.nodeId, params.propertyName, params.value);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.setEffectivePropertyValueForNode"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setKeyframeKeyParams : public crdtp::DeserializableProtocolObject<setKeyframeKeyParams> {
    String styleSheetId;
    std::unique_ptr<protocol::CSS::SourceRange> range;
    String keyText;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setKeyframeKeyParams)
    CRDTP_DESERIALIZE_FIELD("keyText", keyText),
    CRDTP_DESERIALIZE_FIELD("range", range),
    CRDTP_DESERIALIZE_FIELD("styleSheetId", styleSheetId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setKeyframeKey(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setKeyframeKeyParams params;
    if (!setKeyframeKeyParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::CSS::Value> out_keyText;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setKeyframeKey(params.styleSheetId, std::move(params.range), params.keyText, &out_keyText);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.setKeyframeKey"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("keyText"), out_keyText);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct setMediaTextParams : public crdtp::DeserializableProtocolObject<setMediaTextParams> {
    String styleSheetId;
    std::unique_ptr<protocol::CSS::SourceRange> range;
    String text;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setMediaTextParams)
    CRDTP_DESERIALIZE_FIELD("range", range),
    CRDTP_DESERIALIZE_FIELD("styleSheetId", styleSheetId),
    CRDTP_DESERIALIZE_FIELD("text", text),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setMediaText(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setMediaTextParams params;
    if (!setMediaTextParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::CSS::CSSMedia> out_media;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setMediaText(params.styleSheetId, std::move(params.range), params.text, &out_media);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.setMediaText"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("media"), out_media);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct setContainerQueryTextParams : public crdtp::DeserializableProtocolObject<setContainerQueryTextParams> {
    String styleSheetId;
    std::unique_ptr<protocol::CSS::SourceRange> range;
    String text;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setContainerQueryTextParams)
    CRDTP_DESERIALIZE_FIELD("range", range),
    CRDTP_DESERIALIZE_FIELD("styleSheetId", styleSheetId),
    CRDTP_DESERIALIZE_FIELD("text", text),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setContainerQueryText(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setContainerQueryTextParams params;
    if (!setContainerQueryTextParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::CSS::CSSContainerQuery> out_containerQuery;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setContainerQueryText(params.styleSheetId, std::move(params.range), params.text, &out_containerQuery);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.setContainerQueryText"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("containerQuery"), out_containerQuery);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct setSupportsTextParams : public crdtp::DeserializableProtocolObject<setSupportsTextParams> {
    String styleSheetId;
    std::unique_ptr<protocol::CSS::SourceRange> range;
    String text;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setSupportsTextParams)
    CRDTP_DESERIALIZE_FIELD("range", range),
    CRDTP_DESERIALIZE_FIELD("styleSheetId", styleSheetId),
    CRDTP_DESERIALIZE_FIELD("text", text),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setSupportsText(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setSupportsTextParams params;
    if (!setSupportsTextParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::CSS::CSSSupports> out_supports;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setSupportsText(params.styleSheetId, std::move(params.range), params.text, &out_supports);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.setSupportsText"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("supports"), out_supports);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct setScopeTextParams : public crdtp::DeserializableProtocolObject<setScopeTextParams> {
    String styleSheetId;
    std::unique_ptr<protocol::CSS::SourceRange> range;
    String text;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setScopeTextParams)
    CRDTP_DESERIALIZE_FIELD("range", range),
    CRDTP_DESERIALIZE_FIELD("styleSheetId", styleSheetId),
    CRDTP_DESERIALIZE_FIELD("text", text),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setScopeText(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setScopeTextParams params;
    if (!setScopeTextParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::CSS::CSSScope> out_scope;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setScopeText(params.styleSheetId, std::move(params.range), params.text, &out_scope);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.setScopeText"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("scope"), out_scope);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct setRuleSelectorParams : public crdtp::DeserializableProtocolObject<setRuleSelectorParams> {
    String styleSheetId;
    std::unique_ptr<protocol::CSS::SourceRange> range;
    String selector;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setRuleSelectorParams)
    CRDTP_DESERIALIZE_FIELD("range", range),
    CRDTP_DESERIALIZE_FIELD("selector", selector),
    CRDTP_DESERIALIZE_FIELD("styleSheetId", styleSheetId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setRuleSelector(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setRuleSelectorParams params;
    if (!setRuleSelectorParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::CSS::SelectorList> out_selectorList;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setRuleSelector(params.styleSheetId, std::move(params.range), params.selector, &out_selectorList);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.setRuleSelector"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("selectorList"), out_selectorList);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct setStyleSheetTextParams : public crdtp::DeserializableProtocolObject<setStyleSheetTextParams> {
    String styleSheetId;
    String text;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setStyleSheetTextParams)
    CRDTP_DESERIALIZE_FIELD("styleSheetId", styleSheetId),
    CRDTP_DESERIALIZE_FIELD("text", text),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setStyleSheetText(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setStyleSheetTextParams params;
    if (!setStyleSheetTextParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    Maybe<String> out_sourceMapURL;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setStyleSheetText(params.styleSheetId, params.text, &out_sourceMapURL);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.setStyleSheetText"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("sourceMapURL"), out_sourceMapURL);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct setStyleTextsParams : public crdtp::DeserializableProtocolObject<setStyleTextsParams> {
    std::unique_ptr<protocol::Array<protocol::CSS::StyleDeclarationEdit>> edits;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setStyleTextsParams)
    CRDTP_DESERIALIZE_FIELD("edits", edits),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setStyleTexts(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setStyleTextsParams params;
    if (!setStyleTextsParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::CSS::CSSStyle>> out_styles;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setStyleTexts(std::move(params.edits), &out_styles);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.setStyleTexts"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("styles"), out_styles);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::startRuleUsageTracking(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->startRuleUsageTracking();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.startRuleUsageTracking"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::stopRuleUsageTracking(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::CSS::RuleUsage>> out_ruleUsage;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->stopRuleUsageTracking(&out_ruleUsage);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.stopRuleUsageTracking"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("ruleUsage"), out_ruleUsage);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::takeCoverageDelta(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::CSS::RuleUsage>> out_coverage;
    double out_timestamp;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->takeCoverageDelta(&out_coverage, &out_timestamp);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.takeCoverageDelta"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("coverage"), out_coverage);
          serializer.AddField(crdtp::MakeSpan("timestamp"), out_timestamp);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct setLocalFontsEnabledParams : public crdtp::DeserializableProtocolObject<setLocalFontsEnabledParams> {
    bool enabled;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setLocalFontsEnabledParams)
    CRDTP_DESERIALIZE_FIELD("enabled", enabled),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setLocalFontsEnabled(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setLocalFontsEnabledParams params;
    if (!setLocalFontsEnabledParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setLocalFontsEnabled(params.enabled);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("CSS.setLocalFontsEnabled"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {
// This helper method (with a static map of redirects) is used from Dispatcher::wire
// immediately below.
const std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>& SortedRedirects() {
  static auto* redirects = [](){
    auto* redirects = new std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>{
    };
    return redirects;
  }();
  return *redirects;
}
}  // namespace

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    auto dispatcher = std::make_unique<DomainDispatcherImpl>(uber->channel(), backend);
    uber->WireBackend(crdtp::SpanFrom("CSS"), SortedRedirects(), std::move(dispatcher));
}

} // CSS
} // namespace blink
} // namespace protocol
