// This file is generated by TypeBuilder_h.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef blink_protocol_Network_h
#define blink_protocol_Network_h

#include "third_party/blink/renderer/core/core_export.h"
#include "third_party/blink/renderer/core/inspector/protocol/protocol.h"
// For each imported domain we generate a ValueConversions struct instead of a full domain definition
// and include Domain::API version from there.
#include "third_party/blink/renderer/core/inspector/protocol/debugger.h"
#include "third_party/blink/renderer/core/inspector/protocol/runtime.h"
#include "third_party/blink/renderer/core/inspector/protocol/security.h"

namespace blink {
namespace protocol {
namespace Network {
using ResourceType = String;
using LoaderId = String;
using RequestId = String;
using InterceptionId = String;
using ErrorReason = String;
using TimeSinceEpoch = double;
using MonotonicTime = double;
using Headers = Object;
using ConnectionType = String;
using CookieSameSite = String;
using CookiePriority = String;
using CookieSourceScheme = String;
class ResourceTiming;
using ResourcePriority = String;
class PostDataEntry;
class Request;
class SignedCertificateTimestamp;
class SecurityDetails;
using CertificateTransparencyCompliance = String;
using BlockedReason = String;
using CorsError = String;
class CorsErrorStatus;
using ServiceWorkerResponseSource = String;
class TrustTokenParams;
using TrustTokenOperationType = String;
class Response;
class WebSocketRequest;
class WebSocketResponse;
class WebSocketFrame;
class Initiator;
class Cookie;
using SetCookieBlockedReason = String;
using CookieBlockedReason = String;
class BlockedSetCookieWithReason;
class BlockedCookieWithReason;
class AuthChallenge;
class SignedExchangeSignature;
class SignedExchangeHeader;
using SignedExchangeErrorField = String;
class SignedExchangeError;
class SignedExchangeInfo;
using ContentEncoding = String;
using PrivateNetworkRequestPolicy = String;
using IPAddressSpace = String;
class ConnectTiming;
class ClientSecurityState;
using ReportStatus = String;
using ReportId = String;
class ReportingApiReport;
class ReportingApiEndpoint;

// ------------- Forward and enum declarations.

namespace ResourceTypeEnum {
CORE_EXPORT extern const char Document[];
CORE_EXPORT extern const char Stylesheet[];
CORE_EXPORT extern const char Image[];
CORE_EXPORT extern const char Media[];
CORE_EXPORT extern const char Font[];
CORE_EXPORT extern const char Script[];
CORE_EXPORT extern const char TextTrack[];
CORE_EXPORT extern const char XHR[];
CORE_EXPORT extern const char Fetch[];
CORE_EXPORT extern const char Prefetch[];
CORE_EXPORT extern const char EventSource[];
CORE_EXPORT extern const char WebSocket[];
CORE_EXPORT extern const char Manifest[];
CORE_EXPORT extern const char SignedExchange[];
CORE_EXPORT extern const char Ping[];
CORE_EXPORT extern const char CSPViolationReport[];
CORE_EXPORT extern const char Preflight[];
CORE_EXPORT extern const char Other[];
} // namespace ResourceTypeEnum

namespace ErrorReasonEnum {
CORE_EXPORT extern const char Failed[];
CORE_EXPORT extern const char Aborted[];
CORE_EXPORT extern const char TimedOut[];
CORE_EXPORT extern const char AccessDenied[];
CORE_EXPORT extern const char ConnectionClosed[];
CORE_EXPORT extern const char ConnectionReset[];
CORE_EXPORT extern const char ConnectionRefused[];
CORE_EXPORT extern const char ConnectionAborted[];
CORE_EXPORT extern const char ConnectionFailed[];
CORE_EXPORT extern const char NameNotResolved[];
CORE_EXPORT extern const char InternetDisconnected[];
CORE_EXPORT extern const char AddressUnreachable[];
CORE_EXPORT extern const char BlockedByClient[];
CORE_EXPORT extern const char BlockedByResponse[];
} // namespace ErrorReasonEnum

namespace ConnectionTypeEnum {
CORE_EXPORT extern const char None[];
CORE_EXPORT extern const char Cellular2g[];
CORE_EXPORT extern const char Cellular3g[];
CORE_EXPORT extern const char Cellular4g[];
CORE_EXPORT extern const char Bluetooth[];
CORE_EXPORT extern const char Ethernet[];
CORE_EXPORT extern const char Wifi[];
CORE_EXPORT extern const char Wimax[];
CORE_EXPORT extern const char Other[];
} // namespace ConnectionTypeEnum

namespace CookieSameSiteEnum {
CORE_EXPORT extern const char Strict[];
CORE_EXPORT extern const char Lax[];
CORE_EXPORT extern const char None[];
} // namespace CookieSameSiteEnum

namespace CookiePriorityEnum {
CORE_EXPORT extern const char Low[];
CORE_EXPORT extern const char Medium[];
CORE_EXPORT extern const char High[];
} // namespace CookiePriorityEnum

namespace CookieSourceSchemeEnum {
CORE_EXPORT extern const char Unset[];
CORE_EXPORT extern const char NonSecure[];
CORE_EXPORT extern const char Secure[];
} // namespace CookieSourceSchemeEnum

namespace ResourcePriorityEnum {
CORE_EXPORT extern const char VeryLow[];
CORE_EXPORT extern const char Low[];
CORE_EXPORT extern const char Medium[];
CORE_EXPORT extern const char High[];
CORE_EXPORT extern const char VeryHigh[];
} // namespace ResourcePriorityEnum

namespace CertificateTransparencyComplianceEnum {
CORE_EXPORT extern const char Unknown[];
CORE_EXPORT extern const char NotCompliant[];
CORE_EXPORT extern const char Compliant[];
} // namespace CertificateTransparencyComplianceEnum

namespace BlockedReasonEnum {
CORE_EXPORT extern const char Other[];
CORE_EXPORT extern const char Csp[];
CORE_EXPORT extern const char MixedContent[];
CORE_EXPORT extern const char Origin[];
CORE_EXPORT extern const char Inspector[];
CORE_EXPORT extern const char SubresourceFilter[];
CORE_EXPORT extern const char ContentType[];
CORE_EXPORT extern const char CoepFrameResourceNeedsCoepHeader[];
CORE_EXPORT extern const char CoopSandboxedIframeCannotNavigateToCoopPage[];
CORE_EXPORT extern const char CorpNotSameOrigin[];
CORE_EXPORT extern const char CorpNotSameOriginAfterDefaultedToSameOriginByCoep[];
CORE_EXPORT extern const char CorpNotSameSite[];
} // namespace BlockedReasonEnum

namespace CorsErrorEnum {
CORE_EXPORT extern const char DisallowedByMode[];
CORE_EXPORT extern const char InvalidResponse[];
CORE_EXPORT extern const char WildcardOriginNotAllowed[];
CORE_EXPORT extern const char MissingAllowOriginHeader[];
CORE_EXPORT extern const char MultipleAllowOriginValues[];
CORE_EXPORT extern const char InvalidAllowOriginValue[];
CORE_EXPORT extern const char AllowOriginMismatch[];
CORE_EXPORT extern const char InvalidAllowCredentials[];
CORE_EXPORT extern const char CorsDisabledScheme[];
CORE_EXPORT extern const char PreflightInvalidStatus[];
CORE_EXPORT extern const char PreflightDisallowedRedirect[];
CORE_EXPORT extern const char PreflightWildcardOriginNotAllowed[];
CORE_EXPORT extern const char PreflightMissingAllowOriginHeader[];
CORE_EXPORT extern const char PreflightMultipleAllowOriginValues[];
CORE_EXPORT extern const char PreflightInvalidAllowOriginValue[];
CORE_EXPORT extern const char PreflightAllowOriginMismatch[];
CORE_EXPORT extern const char PreflightInvalidAllowCredentials[];
CORE_EXPORT extern const char PreflightMissingAllowExternal[];
CORE_EXPORT extern const char PreflightInvalidAllowExternal[];
CORE_EXPORT extern const char PreflightMissingAllowPrivateNetwork[];
CORE_EXPORT extern const char PreflightInvalidAllowPrivateNetwork[];
CORE_EXPORT extern const char InvalidAllowMethodsPreflightResponse[];
CORE_EXPORT extern const char InvalidAllowHeadersPreflightResponse[];
CORE_EXPORT extern const char MethodDisallowedByPreflightResponse[];
CORE_EXPORT extern const char HeaderDisallowedByPreflightResponse[];
CORE_EXPORT extern const char RedirectContainsCredentials[];
CORE_EXPORT extern const char InsecurePrivateNetwork[];
CORE_EXPORT extern const char InvalidPrivateNetworkAccess[];
CORE_EXPORT extern const char UnexpectedPrivateNetworkAccess[];
CORE_EXPORT extern const char NoCorsRedirectModeNotFollow[];
} // namespace CorsErrorEnum

namespace ServiceWorkerResponseSourceEnum {
CORE_EXPORT extern const char CacheStorage[];
CORE_EXPORT extern const char HttpCache[];
CORE_EXPORT extern const char FallbackCode[];
CORE_EXPORT extern const char Network[];
} // namespace ServiceWorkerResponseSourceEnum

namespace TrustTokenOperationTypeEnum {
CORE_EXPORT extern const char Issuance[];
CORE_EXPORT extern const char Redemption[];
CORE_EXPORT extern const char Signing[];
} // namespace TrustTokenOperationTypeEnum

namespace SetCookieBlockedReasonEnum {
CORE_EXPORT extern const char SecureOnly[];
CORE_EXPORT extern const char SameSiteStrict[];
CORE_EXPORT extern const char SameSiteLax[];
CORE_EXPORT extern const char SameSiteUnspecifiedTreatedAsLax[];
CORE_EXPORT extern const char SameSiteNoneInsecure[];
CORE_EXPORT extern const char UserPreferences[];
CORE_EXPORT extern const char SyntaxError[];
CORE_EXPORT extern const char SchemeNotSupported[];
CORE_EXPORT extern const char OverwriteSecure[];
CORE_EXPORT extern const char InvalidDomain[];
CORE_EXPORT extern const char InvalidPrefix[];
CORE_EXPORT extern const char UnknownError[];
CORE_EXPORT extern const char SchemefulSameSiteStrict[];
CORE_EXPORT extern const char SchemefulSameSiteLax[];
CORE_EXPORT extern const char SchemefulSameSiteUnspecifiedTreatedAsLax[];
CORE_EXPORT extern const char SamePartyFromCrossPartyContext[];
CORE_EXPORT extern const char SamePartyConflictsWithOtherAttributes[];
CORE_EXPORT extern const char NameValuePairExceedsMaxSize[];
} // namespace SetCookieBlockedReasonEnum

namespace CookieBlockedReasonEnum {
CORE_EXPORT extern const char SecureOnly[];
CORE_EXPORT extern const char NotOnPath[];
CORE_EXPORT extern const char DomainMismatch[];
CORE_EXPORT extern const char SameSiteStrict[];
CORE_EXPORT extern const char SameSiteLax[];
CORE_EXPORT extern const char SameSiteUnspecifiedTreatedAsLax[];
CORE_EXPORT extern const char SameSiteNoneInsecure[];
CORE_EXPORT extern const char UserPreferences[];
CORE_EXPORT extern const char UnknownError[];
CORE_EXPORT extern const char SchemefulSameSiteStrict[];
CORE_EXPORT extern const char SchemefulSameSiteLax[];
CORE_EXPORT extern const char SchemefulSameSiteUnspecifiedTreatedAsLax[];
CORE_EXPORT extern const char SamePartyFromCrossPartyContext[];
CORE_EXPORT extern const char NameValuePairExceedsMaxSize[];
} // namespace CookieBlockedReasonEnum

namespace SignedExchangeErrorFieldEnum {
CORE_EXPORT extern const char SignatureSig[];
CORE_EXPORT extern const char SignatureIntegrity[];
CORE_EXPORT extern const char SignatureCertUrl[];
CORE_EXPORT extern const char SignatureCertSha256[];
CORE_EXPORT extern const char SignatureValidityUrl[];
CORE_EXPORT extern const char SignatureTimestamps[];
} // namespace SignedExchangeErrorFieldEnum

namespace ContentEncodingEnum {
CORE_EXPORT extern const char Deflate[];
CORE_EXPORT extern const char Gzip[];
CORE_EXPORT extern const char Br[];
} // namespace ContentEncodingEnum

namespace PrivateNetworkRequestPolicyEnum {
CORE_EXPORT extern const char Allow[];
CORE_EXPORT extern const char BlockFromInsecureToMorePrivate[];
CORE_EXPORT extern const char WarnFromInsecureToMorePrivate[];
CORE_EXPORT extern const char PreflightBlock[];
CORE_EXPORT extern const char PreflightWarn[];
} // namespace PrivateNetworkRequestPolicyEnum

namespace IPAddressSpaceEnum {
CORE_EXPORT extern const char Local[];
CORE_EXPORT extern const char Private[];
CORE_EXPORT extern const char Public[];
CORE_EXPORT extern const char Unknown[];
} // namespace IPAddressSpaceEnum

namespace ReportStatusEnum {
CORE_EXPORT extern const char Queued[];
CORE_EXPORT extern const char Pending[];
CORE_EXPORT extern const char MarkedForRemoval[];
CORE_EXPORT extern const char Success[];
} // namespace ReportStatusEnum

namespace TrustTokenOperationDone {
namespace StatusEnum {
CORE_EXPORT extern const char* Ok;
CORE_EXPORT extern const char* InvalidArgument;
CORE_EXPORT extern const char* FailedPrecondition;
CORE_EXPORT extern const char* ResourceExhausted;
CORE_EXPORT extern const char* AlreadyExists;
CORE_EXPORT extern const char* Unavailable;
CORE_EXPORT extern const char* BadResponse;
CORE_EXPORT extern const char* InternalError;
CORE_EXPORT extern const char* UnknownError;
CORE_EXPORT extern const char* FulfilledLocally;
} // StatusEnum
} // TrustTokenOperationDone

// ------------- Type and builder declarations.

class CORE_EXPORT ResourceTiming : public ::crdtp::ProtocolObject<ResourceTiming> {
public:
    ~ResourceTiming() override { }

    double getRequestTime() { return m_requestTime; }
    void setRequestTime(double value) { m_requestTime = value; }

    double getProxyStart() { return m_proxyStart; }
    void setProxyStart(double value) { m_proxyStart = value; }

    double getProxyEnd() { return m_proxyEnd; }
    void setProxyEnd(double value) { m_proxyEnd = value; }

    double getDnsStart() { return m_dnsStart; }
    void setDnsStart(double value) { m_dnsStart = value; }

    double getDnsEnd() { return m_dnsEnd; }
    void setDnsEnd(double value) { m_dnsEnd = value; }

    double getConnectStart() { return m_connectStart; }
    void setConnectStart(double value) { m_connectStart = value; }

    double getConnectEnd() { return m_connectEnd; }
    void setConnectEnd(double value) { m_connectEnd = value; }

    double getSslStart() { return m_sslStart; }
    void setSslStart(double value) { m_sslStart = value; }

    double getSslEnd() { return m_sslEnd; }
    void setSslEnd(double value) { m_sslEnd = value; }

    double getWorkerStart() { return m_workerStart; }
    void setWorkerStart(double value) { m_workerStart = value; }

    double getWorkerReady() { return m_workerReady; }
    void setWorkerReady(double value) { m_workerReady = value; }

    double getWorkerFetchStart() { return m_workerFetchStart; }
    void setWorkerFetchStart(double value) { m_workerFetchStart = value; }

    double getWorkerRespondWithSettled() { return m_workerRespondWithSettled; }
    void setWorkerRespondWithSettled(double value) { m_workerRespondWithSettled = value; }

    double getSendStart() { return m_sendStart; }
    void setSendStart(double value) { m_sendStart = value; }

    double getSendEnd() { return m_sendEnd; }
    void setSendEnd(double value) { m_sendEnd = value; }

    double getPushStart() { return m_pushStart; }
    void setPushStart(double value) { m_pushStart = value; }

    double getPushEnd() { return m_pushEnd; }
    void setPushEnd(double value) { m_pushEnd = value; }

    double getReceiveHeadersEnd() { return m_receiveHeadersEnd; }
    void setReceiveHeadersEnd(double value) { m_receiveHeadersEnd = value; }

    template<int STATE>
    class ResourceTimingBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            RequestTimeSet = 1 << 1,
            ProxyStartSet = 1 << 2,
            ProxyEndSet = 1 << 3,
            DnsStartSet = 1 << 4,
            DnsEndSet = 1 << 5,
            ConnectStartSet = 1 << 6,
            ConnectEndSet = 1 << 7,
            SslStartSet = 1 << 8,
            SslEndSet = 1 << 9,
            WorkerStartSet = 1 << 10,
            WorkerReadySet = 1 << 11,
            WorkerFetchStartSet = 1 << 12,
            WorkerRespondWithSettledSet = 1 << 13,
            SendStartSet = 1 << 14,
            SendEndSet = 1 << 15,
            PushStartSet = 1 << 16,
            PushEndSet = 1 << 17,
            ReceiveHeadersEndSet = 1 << 18,
            AllFieldsSet = (RequestTimeSet | ProxyStartSet | ProxyEndSet | DnsStartSet | DnsEndSet | ConnectStartSet | ConnectEndSet | SslStartSet | SslEndSet | WorkerStartSet | WorkerReadySet | WorkerFetchStartSet | WorkerRespondWithSettledSet | SendStartSet | SendEndSet | PushStartSet | PushEndSet | ReceiveHeadersEndSet | 0)};


        ResourceTimingBuilder<STATE | RequestTimeSet>& setRequestTime(double value)
        {
            static_assert(!(STATE & RequestTimeSet), "property requestTime should not be set yet");
            m_result->setRequestTime(value);
            return castState<RequestTimeSet>();
        }

        ResourceTimingBuilder<STATE | ProxyStartSet>& setProxyStart(double value)
        {
            static_assert(!(STATE & ProxyStartSet), "property proxyStart should not be set yet");
            m_result->setProxyStart(value);
            return castState<ProxyStartSet>();
        }

        ResourceTimingBuilder<STATE | ProxyEndSet>& setProxyEnd(double value)
        {
            static_assert(!(STATE & ProxyEndSet), "property proxyEnd should not be set yet");
            m_result->setProxyEnd(value);
            return castState<ProxyEndSet>();
        }

        ResourceTimingBuilder<STATE | DnsStartSet>& setDnsStart(double value)
        {
            static_assert(!(STATE & DnsStartSet), "property dnsStart should not be set yet");
            m_result->setDnsStart(value);
            return castState<DnsStartSet>();
        }

        ResourceTimingBuilder<STATE | DnsEndSet>& setDnsEnd(double value)
        {
            static_assert(!(STATE & DnsEndSet), "property dnsEnd should not be set yet");
            m_result->setDnsEnd(value);
            return castState<DnsEndSet>();
        }

        ResourceTimingBuilder<STATE | ConnectStartSet>& setConnectStart(double value)
        {
            static_assert(!(STATE & ConnectStartSet), "property connectStart should not be set yet");
            m_result->setConnectStart(value);
            return castState<ConnectStartSet>();
        }

        ResourceTimingBuilder<STATE | ConnectEndSet>& setConnectEnd(double value)
        {
            static_assert(!(STATE & ConnectEndSet), "property connectEnd should not be set yet");
            m_result->setConnectEnd(value);
            return castState<ConnectEndSet>();
        }

        ResourceTimingBuilder<STATE | SslStartSet>& setSslStart(double value)
        {
            static_assert(!(STATE & SslStartSet), "property sslStart should not be set yet");
            m_result->setSslStart(value);
            return castState<SslStartSet>();
        }

        ResourceTimingBuilder<STATE | SslEndSet>& setSslEnd(double value)
        {
            static_assert(!(STATE & SslEndSet), "property sslEnd should not be set yet");
            m_result->setSslEnd(value);
            return castState<SslEndSet>();
        }

        ResourceTimingBuilder<STATE | WorkerStartSet>& setWorkerStart(double value)
        {
            static_assert(!(STATE & WorkerStartSet), "property workerStart should not be set yet");
            m_result->setWorkerStart(value);
            return castState<WorkerStartSet>();
        }

        ResourceTimingBuilder<STATE | WorkerReadySet>& setWorkerReady(double value)
        {
            static_assert(!(STATE & WorkerReadySet), "property workerReady should not be set yet");
            m_result->setWorkerReady(value);
            return castState<WorkerReadySet>();
        }

        ResourceTimingBuilder<STATE | WorkerFetchStartSet>& setWorkerFetchStart(double value)
        {
            static_assert(!(STATE & WorkerFetchStartSet), "property workerFetchStart should not be set yet");
            m_result->setWorkerFetchStart(value);
            return castState<WorkerFetchStartSet>();
        }

        ResourceTimingBuilder<STATE | WorkerRespondWithSettledSet>& setWorkerRespondWithSettled(double value)
        {
            static_assert(!(STATE & WorkerRespondWithSettledSet), "property workerRespondWithSettled should not be set yet");
            m_result->setWorkerRespondWithSettled(value);
            return castState<WorkerRespondWithSettledSet>();
        }

        ResourceTimingBuilder<STATE | SendStartSet>& setSendStart(double value)
        {
            static_assert(!(STATE & SendStartSet), "property sendStart should not be set yet");
            m_result->setSendStart(value);
            return castState<SendStartSet>();
        }

        ResourceTimingBuilder<STATE | SendEndSet>& setSendEnd(double value)
        {
            static_assert(!(STATE & SendEndSet), "property sendEnd should not be set yet");
            m_result->setSendEnd(value);
            return castState<SendEndSet>();
        }

        ResourceTimingBuilder<STATE | PushStartSet>& setPushStart(double value)
        {
            static_assert(!(STATE & PushStartSet), "property pushStart should not be set yet");
            m_result->setPushStart(value);
            return castState<PushStartSet>();
        }

        ResourceTimingBuilder<STATE | PushEndSet>& setPushEnd(double value)
        {
            static_assert(!(STATE & PushEndSet), "property pushEnd should not be set yet");
            m_result->setPushEnd(value);
            return castState<PushEndSet>();
        }

        ResourceTimingBuilder<STATE | ReceiveHeadersEndSet>& setReceiveHeadersEnd(double value)
        {
            static_assert(!(STATE & ReceiveHeadersEndSet), "property receiveHeadersEnd should not be set yet");
            m_result->setReceiveHeadersEnd(value);
            return castState<ReceiveHeadersEndSet>();
        }

        std::unique_ptr<ResourceTiming> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ResourceTiming;
        ResourceTimingBuilder() : m_result(new ResourceTiming()) { }

        template<int STEP> ResourceTimingBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ResourceTimingBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::ResourceTiming> m_result;
    };

    static ResourceTimingBuilder<0> create()
    {
        return ResourceTimingBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    ResourceTiming()
    {
          m_requestTime = 0;
          m_proxyStart = 0;
          m_proxyEnd = 0;
          m_dnsStart = 0;
          m_dnsEnd = 0;
          m_connectStart = 0;
          m_connectEnd = 0;
          m_sslStart = 0;
          m_sslEnd = 0;
          m_workerStart = 0;
          m_workerReady = 0;
          m_workerFetchStart = 0;
          m_workerRespondWithSettled = 0;
          m_sendStart = 0;
          m_sendEnd = 0;
          m_pushStart = 0;
          m_pushEnd = 0;
          m_receiveHeadersEnd = 0;
    }

    double m_requestTime;
    double m_proxyStart;
    double m_proxyEnd;
    double m_dnsStart;
    double m_dnsEnd;
    double m_connectStart;
    double m_connectEnd;
    double m_sslStart;
    double m_sslEnd;
    double m_workerStart;
    double m_workerReady;
    double m_workerFetchStart;
    double m_workerRespondWithSettled;
    double m_sendStart;
    double m_sendEnd;
    double m_pushStart;
    double m_pushEnd;
    double m_receiveHeadersEnd;
};


class CORE_EXPORT PostDataEntry : public ::crdtp::ProtocolObject<PostDataEntry> {
public:
    ~PostDataEntry() override { }

    bool hasBytes() { return m_bytes.isJust(); }
    Binary getBytes(const Binary& defaultValue) { return m_bytes.isJust() ? m_bytes.fromJust() : defaultValue; }
    void setBytes(const Binary& value) { m_bytes = value; }

    template<int STATE>
    class PostDataEntryBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            AllFieldsSet = (0)};


        PostDataEntryBuilder<STATE>& setBytes(const Binary& value)
        {
            m_result->setBytes(value);
            return *this;
        }

        std::unique_ptr<PostDataEntry> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class PostDataEntry;
        PostDataEntryBuilder() : m_result(new PostDataEntry()) { }

        template<int STEP> PostDataEntryBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<PostDataEntryBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::PostDataEntry> m_result;
    };

    static PostDataEntryBuilder<0> create()
    {
        return PostDataEntryBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    PostDataEntry()
    {
    }

    Maybe<Binary> m_bytes;
};


class CORE_EXPORT Request : public ::crdtp::ProtocolObject<Request> {
public:
    ~Request() override { }

    String getUrl() { return m_url; }
    void setUrl(const String& value) { m_url = value; }

    bool hasUrlFragment() { return m_urlFragment.isJust(); }
    String getUrlFragment(const String& defaultValue) { return m_urlFragment.isJust() ? m_urlFragment.fromJust() : defaultValue; }
    void setUrlFragment(const String& value) { m_urlFragment = value; }

    String getMethod() { return m_method; }
    void setMethod(const String& value) { m_method = value; }

    protocol::Network::Headers* getHeaders() { return m_headers.get(); }
    void setHeaders(std::unique_ptr<protocol::Network::Headers> value) { m_headers = std::move(value); }

    bool hasPostData() { return m_postData.isJust(); }
    String getPostData(const String& defaultValue) { return m_postData.isJust() ? m_postData.fromJust() : defaultValue; }
    void setPostData(const String& value) { m_postData = value; }

    bool hasHasPostData() { return m_hasPostData.isJust(); }
    bool getHasPostData(bool defaultValue) { return m_hasPostData.isJust() ? m_hasPostData.fromJust() : defaultValue; }
    void setHasPostData(bool value) { m_hasPostData = value; }

    bool hasPostDataEntries() { return m_postDataEntries.isJust(); }
    protocol::Array<protocol::Network::PostDataEntry>* getPostDataEntries(protocol::Array<protocol::Network::PostDataEntry>* defaultValue) { return m_postDataEntries.isJust() ? m_postDataEntries.fromJust() : defaultValue; }
    void setPostDataEntries(std::unique_ptr<protocol::Array<protocol::Network::PostDataEntry>> value) { m_postDataEntries = std::move(value); }

    bool hasMixedContentType() { return m_mixedContentType.isJust(); }
    String getMixedContentType(const String& defaultValue) { return m_mixedContentType.isJust() ? m_mixedContentType.fromJust() : defaultValue; }
    void setMixedContentType(const String& value) { m_mixedContentType = value; }

    String getInitialPriority() { return m_initialPriority; }
    void setInitialPriority(const String& value) { m_initialPriority = value; }

    struct CORE_EXPORT ReferrerPolicyEnum {
        static const char* UnsafeUrl;
        static const char* NoReferrerWhenDowngrade;
        static const char* NoReferrer;
        static const char* Origin;
        static const char* OriginWhenCrossOrigin;
        static const char* SameOrigin;
        static const char* StrictOrigin;
        static const char* StrictOriginWhenCrossOrigin;
    }; // ReferrerPolicyEnum

    String getReferrerPolicy() { return m_referrerPolicy; }
    void setReferrerPolicy(const String& value) { m_referrerPolicy = value; }

    bool hasIsLinkPreload() { return m_isLinkPreload.isJust(); }
    bool getIsLinkPreload(bool defaultValue) { return m_isLinkPreload.isJust() ? m_isLinkPreload.fromJust() : defaultValue; }
    void setIsLinkPreload(bool value) { m_isLinkPreload = value; }

    bool hasTrustTokenParams() { return m_trustTokenParams.isJust(); }
    protocol::Network::TrustTokenParams* getTrustTokenParams(protocol::Network::TrustTokenParams* defaultValue) { return m_trustTokenParams.isJust() ? m_trustTokenParams.fromJust() : defaultValue; }
    void setTrustTokenParams(std::unique_ptr<protocol::Network::TrustTokenParams> value) { m_trustTokenParams = std::move(value); }

    bool hasIsSameSite() { return m_isSameSite.isJust(); }
    bool getIsSameSite(bool defaultValue) { return m_isSameSite.isJust() ? m_isSameSite.fromJust() : defaultValue; }
    void setIsSameSite(bool value) { m_isSameSite = value; }

    template<int STATE>
    class RequestBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            UrlSet = 1 << 1,
            MethodSet = 1 << 2,
            HeadersSet = 1 << 3,
            InitialPrioritySet = 1 << 4,
            ReferrerPolicySet = 1 << 5,
            AllFieldsSet = (UrlSet | MethodSet | HeadersSet | InitialPrioritySet | ReferrerPolicySet | 0)};


        RequestBuilder<STATE | UrlSet>& setUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->setUrl(value);
            return castState<UrlSet>();
        }

        RequestBuilder<STATE>& setUrlFragment(const String& value)
        {
            m_result->setUrlFragment(value);
            return *this;
        }

        RequestBuilder<STATE | MethodSet>& setMethod(const String& value)
        {
            static_assert(!(STATE & MethodSet), "property method should not be set yet");
            m_result->setMethod(value);
            return castState<MethodSet>();
        }

        RequestBuilder<STATE | HeadersSet>& setHeaders(std::unique_ptr<protocol::Network::Headers> value)
        {
            static_assert(!(STATE & HeadersSet), "property headers should not be set yet");
            m_result->setHeaders(std::move(value));
            return castState<HeadersSet>();
        }

        RequestBuilder<STATE>& setPostData(const String& value)
        {
            m_result->setPostData(value);
            return *this;
        }

        RequestBuilder<STATE>& setHasPostData(bool value)
        {
            m_result->setHasPostData(value);
            return *this;
        }

        RequestBuilder<STATE>& setPostDataEntries(std::unique_ptr<protocol::Array<protocol::Network::PostDataEntry>> value)
        {
            m_result->setPostDataEntries(std::move(value));
            return *this;
        }

        RequestBuilder<STATE>& setMixedContentType(const String& value)
        {
            m_result->setMixedContentType(value);
            return *this;
        }

        RequestBuilder<STATE | InitialPrioritySet>& setInitialPriority(const String& value)
        {
            static_assert(!(STATE & InitialPrioritySet), "property initialPriority should not be set yet");
            m_result->setInitialPriority(value);
            return castState<InitialPrioritySet>();
        }

        RequestBuilder<STATE | ReferrerPolicySet>& setReferrerPolicy(const String& value)
        {
            static_assert(!(STATE & ReferrerPolicySet), "property referrerPolicy should not be set yet");
            m_result->setReferrerPolicy(value);
            return castState<ReferrerPolicySet>();
        }

        RequestBuilder<STATE>& setIsLinkPreload(bool value)
        {
            m_result->setIsLinkPreload(value);
            return *this;
        }

        RequestBuilder<STATE>& setTrustTokenParams(std::unique_ptr<protocol::Network::TrustTokenParams> value)
        {
            m_result->setTrustTokenParams(std::move(value));
            return *this;
        }

        RequestBuilder<STATE>& setIsSameSite(bool value)
        {
            m_result->setIsSameSite(value);
            return *this;
        }

        std::unique_ptr<Request> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class Request;
        RequestBuilder() : m_result(new Request()) { }

        template<int STEP> RequestBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<RequestBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::Request> m_result;
    };

    static RequestBuilder<0> create()
    {
        return RequestBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    Request()
    {
    }

    String m_url;
    Maybe<String> m_urlFragment;
    String m_method;
    std::unique_ptr<protocol::Network::Headers> m_headers;
    Maybe<String> m_postData;
    Maybe<bool> m_hasPostData;
    Maybe<protocol::Array<protocol::Network::PostDataEntry>> m_postDataEntries;
    Maybe<String> m_mixedContentType;
    String m_initialPriority;
    String m_referrerPolicy;
    Maybe<bool> m_isLinkPreload;
    Maybe<protocol::Network::TrustTokenParams> m_trustTokenParams;
    Maybe<bool> m_isSameSite;
};


class CORE_EXPORT SignedCertificateTimestamp : public ::crdtp::ProtocolObject<SignedCertificateTimestamp> {
public:
    ~SignedCertificateTimestamp() override { }

    String getStatus() { return m_status; }
    void setStatus(const String& value) { m_status = value; }

    String getOrigin() { return m_origin; }
    void setOrigin(const String& value) { m_origin = value; }

    String getLogDescription() { return m_logDescription; }
    void setLogDescription(const String& value) { m_logDescription = value; }

    String getLogId() { return m_logId; }
    void setLogId(const String& value) { m_logId = value; }

    double getTimestamp() { return m_timestamp; }
    void setTimestamp(double value) { m_timestamp = value; }

    String getHashAlgorithm() { return m_hashAlgorithm; }
    void setHashAlgorithm(const String& value) { m_hashAlgorithm = value; }

    String getSignatureAlgorithm() { return m_signatureAlgorithm; }
    void setSignatureAlgorithm(const String& value) { m_signatureAlgorithm = value; }

    String getSignatureData() { return m_signatureData; }
    void setSignatureData(const String& value) { m_signatureData = value; }

    template<int STATE>
    class SignedCertificateTimestampBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            StatusSet = 1 << 1,
            OriginSet = 1 << 2,
            LogDescriptionSet = 1 << 3,
            LogIdSet = 1 << 4,
            TimestampSet = 1 << 5,
            HashAlgorithmSet = 1 << 6,
            SignatureAlgorithmSet = 1 << 7,
            SignatureDataSet = 1 << 8,
            AllFieldsSet = (StatusSet | OriginSet | LogDescriptionSet | LogIdSet | TimestampSet | HashAlgorithmSet | SignatureAlgorithmSet | SignatureDataSet | 0)};


        SignedCertificateTimestampBuilder<STATE | StatusSet>& setStatus(const String& value)
        {
            static_assert(!(STATE & StatusSet), "property status should not be set yet");
            m_result->setStatus(value);
            return castState<StatusSet>();
        }

        SignedCertificateTimestampBuilder<STATE | OriginSet>& setOrigin(const String& value)
        {
            static_assert(!(STATE & OriginSet), "property origin should not be set yet");
            m_result->setOrigin(value);
            return castState<OriginSet>();
        }

        SignedCertificateTimestampBuilder<STATE | LogDescriptionSet>& setLogDescription(const String& value)
        {
            static_assert(!(STATE & LogDescriptionSet), "property logDescription should not be set yet");
            m_result->setLogDescription(value);
            return castState<LogDescriptionSet>();
        }

        SignedCertificateTimestampBuilder<STATE | LogIdSet>& setLogId(const String& value)
        {
            static_assert(!(STATE & LogIdSet), "property logId should not be set yet");
            m_result->setLogId(value);
            return castState<LogIdSet>();
        }

        SignedCertificateTimestampBuilder<STATE | TimestampSet>& setTimestamp(double value)
        {
            static_assert(!(STATE & TimestampSet), "property timestamp should not be set yet");
            m_result->setTimestamp(value);
            return castState<TimestampSet>();
        }

        SignedCertificateTimestampBuilder<STATE | HashAlgorithmSet>& setHashAlgorithm(const String& value)
        {
            static_assert(!(STATE & HashAlgorithmSet), "property hashAlgorithm should not be set yet");
            m_result->setHashAlgorithm(value);
            return castState<HashAlgorithmSet>();
        }

        SignedCertificateTimestampBuilder<STATE | SignatureAlgorithmSet>& setSignatureAlgorithm(const String& value)
        {
            static_assert(!(STATE & SignatureAlgorithmSet), "property signatureAlgorithm should not be set yet");
            m_result->setSignatureAlgorithm(value);
            return castState<SignatureAlgorithmSet>();
        }

        SignedCertificateTimestampBuilder<STATE | SignatureDataSet>& setSignatureData(const String& value)
        {
            static_assert(!(STATE & SignatureDataSet), "property signatureData should not be set yet");
            m_result->setSignatureData(value);
            return castState<SignatureDataSet>();
        }

        std::unique_ptr<SignedCertificateTimestamp> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SignedCertificateTimestamp;
        SignedCertificateTimestampBuilder() : m_result(new SignedCertificateTimestamp()) { }

        template<int STEP> SignedCertificateTimestampBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SignedCertificateTimestampBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::SignedCertificateTimestamp> m_result;
    };

    static SignedCertificateTimestampBuilder<0> create()
    {
        return SignedCertificateTimestampBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    SignedCertificateTimestamp()
    {
          m_timestamp = 0;
    }

    String m_status;
    String m_origin;
    String m_logDescription;
    String m_logId;
    double m_timestamp;
    String m_hashAlgorithm;
    String m_signatureAlgorithm;
    String m_signatureData;
};


class CORE_EXPORT SecurityDetails : public ::crdtp::ProtocolObject<SecurityDetails> {
public:
    ~SecurityDetails() override { }

    String getProtocol() { return m_protocol; }
    void setProtocol(const String& value) { m_protocol = value; }

    String getKeyExchange() { return m_keyExchange; }
    void setKeyExchange(const String& value) { m_keyExchange = value; }

    bool hasKeyExchangeGroup() { return m_keyExchangeGroup.isJust(); }
    String getKeyExchangeGroup(const String& defaultValue) { return m_keyExchangeGroup.isJust() ? m_keyExchangeGroup.fromJust() : defaultValue; }
    void setKeyExchangeGroup(const String& value) { m_keyExchangeGroup = value; }

    String getCipher() { return m_cipher; }
    void setCipher(const String& value) { m_cipher = value; }

    bool hasMac() { return m_mac.isJust(); }
    String getMac(const String& defaultValue) { return m_mac.isJust() ? m_mac.fromJust() : defaultValue; }
    void setMac(const String& value) { m_mac = value; }

    int getCertificateId() { return m_certificateId; }
    void setCertificateId(int value) { m_certificateId = value; }

    String getSubjectName() { return m_subjectName; }
    void setSubjectName(const String& value) { m_subjectName = value; }

    protocol::Array<String>* getSanList() { return m_sanList.get(); }
    void setSanList(std::unique_ptr<protocol::Array<String>> value) { m_sanList = std::move(value); }

    String getIssuer() { return m_issuer; }
    void setIssuer(const String& value) { m_issuer = value; }

    double getValidFrom() { return m_validFrom; }
    void setValidFrom(double value) { m_validFrom = value; }

    double getValidTo() { return m_validTo; }
    void setValidTo(double value) { m_validTo = value; }

    protocol::Array<protocol::Network::SignedCertificateTimestamp>* getSignedCertificateTimestampList() { return m_signedCertificateTimestampList.get(); }
    void setSignedCertificateTimestampList(std::unique_ptr<protocol::Array<protocol::Network::SignedCertificateTimestamp>> value) { m_signedCertificateTimestampList = std::move(value); }

    String getCertificateTransparencyCompliance() { return m_certificateTransparencyCompliance; }
    void setCertificateTransparencyCompliance(const String& value) { m_certificateTransparencyCompliance = value; }

    bool hasServerSignatureAlgorithm() { return m_serverSignatureAlgorithm.isJust(); }
    int getServerSignatureAlgorithm(int defaultValue) { return m_serverSignatureAlgorithm.isJust() ? m_serverSignatureAlgorithm.fromJust() : defaultValue; }
    void setServerSignatureAlgorithm(int value) { m_serverSignatureAlgorithm = value; }

    bool getEncryptedClientHello() { return m_encryptedClientHello; }
    void setEncryptedClientHello(bool value) { m_encryptedClientHello = value; }

    template<int STATE>
    class SecurityDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ProtocolSet = 1 << 1,
            KeyExchangeSet = 1 << 2,
            CipherSet = 1 << 3,
            CertificateIdSet = 1 << 4,
            SubjectNameSet = 1 << 5,
            SanListSet = 1 << 6,
            IssuerSet = 1 << 7,
            ValidFromSet = 1 << 8,
            ValidToSet = 1 << 9,
            SignedCertificateTimestampListSet = 1 << 10,
            CertificateTransparencyComplianceSet = 1 << 11,
            EncryptedClientHelloSet = 1 << 12,
            AllFieldsSet = (ProtocolSet | KeyExchangeSet | CipherSet | CertificateIdSet | SubjectNameSet | SanListSet | IssuerSet | ValidFromSet | ValidToSet | SignedCertificateTimestampListSet | CertificateTransparencyComplianceSet | EncryptedClientHelloSet | 0)};


        SecurityDetailsBuilder<STATE | ProtocolSet>& setProtocol(const String& value)
        {
            static_assert(!(STATE & ProtocolSet), "property protocol should not be set yet");
            m_result->setProtocol(value);
            return castState<ProtocolSet>();
        }

        SecurityDetailsBuilder<STATE | KeyExchangeSet>& setKeyExchange(const String& value)
        {
            static_assert(!(STATE & KeyExchangeSet), "property keyExchange should not be set yet");
            m_result->setKeyExchange(value);
            return castState<KeyExchangeSet>();
        }

        SecurityDetailsBuilder<STATE>& setKeyExchangeGroup(const String& value)
        {
            m_result->setKeyExchangeGroup(value);
            return *this;
        }

        SecurityDetailsBuilder<STATE | CipherSet>& setCipher(const String& value)
        {
            static_assert(!(STATE & CipherSet), "property cipher should not be set yet");
            m_result->setCipher(value);
            return castState<CipherSet>();
        }

        SecurityDetailsBuilder<STATE>& setMac(const String& value)
        {
            m_result->setMac(value);
            return *this;
        }

        SecurityDetailsBuilder<STATE | CertificateIdSet>& setCertificateId(int value)
        {
            static_assert(!(STATE & CertificateIdSet), "property certificateId should not be set yet");
            m_result->setCertificateId(value);
            return castState<CertificateIdSet>();
        }

        SecurityDetailsBuilder<STATE | SubjectNameSet>& setSubjectName(const String& value)
        {
            static_assert(!(STATE & SubjectNameSet), "property subjectName should not be set yet");
            m_result->setSubjectName(value);
            return castState<SubjectNameSet>();
        }

        SecurityDetailsBuilder<STATE | SanListSet>& setSanList(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & SanListSet), "property sanList should not be set yet");
            m_result->setSanList(std::move(value));
            return castState<SanListSet>();
        }

        SecurityDetailsBuilder<STATE | IssuerSet>& setIssuer(const String& value)
        {
            static_assert(!(STATE & IssuerSet), "property issuer should not be set yet");
            m_result->setIssuer(value);
            return castState<IssuerSet>();
        }

        SecurityDetailsBuilder<STATE | ValidFromSet>& setValidFrom(double value)
        {
            static_assert(!(STATE & ValidFromSet), "property validFrom should not be set yet");
            m_result->setValidFrom(value);
            return castState<ValidFromSet>();
        }

        SecurityDetailsBuilder<STATE | ValidToSet>& setValidTo(double value)
        {
            static_assert(!(STATE & ValidToSet), "property validTo should not be set yet");
            m_result->setValidTo(value);
            return castState<ValidToSet>();
        }

        SecurityDetailsBuilder<STATE | SignedCertificateTimestampListSet>& setSignedCertificateTimestampList(std::unique_ptr<protocol::Array<protocol::Network::SignedCertificateTimestamp>> value)
        {
            static_assert(!(STATE & SignedCertificateTimestampListSet), "property signedCertificateTimestampList should not be set yet");
            m_result->setSignedCertificateTimestampList(std::move(value));
            return castState<SignedCertificateTimestampListSet>();
        }

        SecurityDetailsBuilder<STATE | CertificateTransparencyComplianceSet>& setCertificateTransparencyCompliance(const String& value)
        {
            static_assert(!(STATE & CertificateTransparencyComplianceSet), "property certificateTransparencyCompliance should not be set yet");
            m_result->setCertificateTransparencyCompliance(value);
            return castState<CertificateTransparencyComplianceSet>();
        }

        SecurityDetailsBuilder<STATE>& setServerSignatureAlgorithm(int value)
        {
            m_result->setServerSignatureAlgorithm(value);
            return *this;
        }

        SecurityDetailsBuilder<STATE | EncryptedClientHelloSet>& setEncryptedClientHello(bool value)
        {
            static_assert(!(STATE & EncryptedClientHelloSet), "property encryptedClientHello should not be set yet");
            m_result->setEncryptedClientHello(value);
            return castState<EncryptedClientHelloSet>();
        }

        std::unique_ptr<SecurityDetails> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SecurityDetails;
        SecurityDetailsBuilder() : m_result(new SecurityDetails()) { }

        template<int STEP> SecurityDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SecurityDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::SecurityDetails> m_result;
    };

    static SecurityDetailsBuilder<0> create()
    {
        return SecurityDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    SecurityDetails()
    {
          m_certificateId = 0;
          m_validFrom = 0;
          m_validTo = 0;
          m_encryptedClientHello = false;
    }

    String m_protocol;
    String m_keyExchange;
    Maybe<String> m_keyExchangeGroup;
    String m_cipher;
    Maybe<String> m_mac;
    int m_certificateId;
    String m_subjectName;
    std::unique_ptr<protocol::Array<String>> m_sanList;
    String m_issuer;
    double m_validFrom;
    double m_validTo;
    std::unique_ptr<protocol::Array<protocol::Network::SignedCertificateTimestamp>> m_signedCertificateTimestampList;
    String m_certificateTransparencyCompliance;
    Maybe<int> m_serverSignatureAlgorithm;
    bool m_encryptedClientHello;
};


class CORE_EXPORT CorsErrorStatus : public ::crdtp::ProtocolObject<CorsErrorStatus> {
public:
    ~CorsErrorStatus() override { }

    String getCorsError() { return m_corsError; }
    void setCorsError(const String& value) { m_corsError = value; }

    String getFailedParameter() { return m_failedParameter; }
    void setFailedParameter(const String& value) { m_failedParameter = value; }

    template<int STATE>
    class CorsErrorStatusBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            CorsErrorSet = 1 << 1,
            FailedParameterSet = 1 << 2,
            AllFieldsSet = (CorsErrorSet | FailedParameterSet | 0)};


        CorsErrorStatusBuilder<STATE | CorsErrorSet>& setCorsError(const String& value)
        {
            static_assert(!(STATE & CorsErrorSet), "property corsError should not be set yet");
            m_result->setCorsError(value);
            return castState<CorsErrorSet>();
        }

        CorsErrorStatusBuilder<STATE | FailedParameterSet>& setFailedParameter(const String& value)
        {
            static_assert(!(STATE & FailedParameterSet), "property failedParameter should not be set yet");
            m_result->setFailedParameter(value);
            return castState<FailedParameterSet>();
        }

        std::unique_ptr<CorsErrorStatus> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class CorsErrorStatus;
        CorsErrorStatusBuilder() : m_result(new CorsErrorStatus()) { }

        template<int STEP> CorsErrorStatusBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<CorsErrorStatusBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::CorsErrorStatus> m_result;
    };

    static CorsErrorStatusBuilder<0> create()
    {
        return CorsErrorStatusBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    CorsErrorStatus()
    {
    }

    String m_corsError;
    String m_failedParameter;
};


class CORE_EXPORT TrustTokenParams : public ::crdtp::ProtocolObject<TrustTokenParams> {
public:
    ~TrustTokenParams() override { }

    String getType() { return m_type; }
    void setType(const String& value) { m_type = value; }

    struct CORE_EXPORT RefreshPolicyEnum {
        static const char* UseCached;
        static const char* Refresh;
    }; // RefreshPolicyEnum

    String getRefreshPolicy() { return m_refreshPolicy; }
    void setRefreshPolicy(const String& value) { m_refreshPolicy = value; }

    bool hasIssuers() { return m_issuers.isJust(); }
    protocol::Array<String>* getIssuers(protocol::Array<String>* defaultValue) { return m_issuers.isJust() ? m_issuers.fromJust() : defaultValue; }
    void setIssuers(std::unique_ptr<protocol::Array<String>> value) { m_issuers = std::move(value); }

    template<int STATE>
    class TrustTokenParamsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            TypeSet = 1 << 1,
            RefreshPolicySet = 1 << 2,
            AllFieldsSet = (TypeSet | RefreshPolicySet | 0)};


        TrustTokenParamsBuilder<STATE | TypeSet>& setType(const String& value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setType(value);
            return castState<TypeSet>();
        }

        TrustTokenParamsBuilder<STATE | RefreshPolicySet>& setRefreshPolicy(const String& value)
        {
            static_assert(!(STATE & RefreshPolicySet), "property refreshPolicy should not be set yet");
            m_result->setRefreshPolicy(value);
            return castState<RefreshPolicySet>();
        }

        TrustTokenParamsBuilder<STATE>& setIssuers(std::unique_ptr<protocol::Array<String>> value)
        {
            m_result->setIssuers(std::move(value));
            return *this;
        }

        std::unique_ptr<TrustTokenParams> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class TrustTokenParams;
        TrustTokenParamsBuilder() : m_result(new TrustTokenParams()) { }

        template<int STEP> TrustTokenParamsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<TrustTokenParamsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::TrustTokenParams> m_result;
    };

    static TrustTokenParamsBuilder<0> create()
    {
        return TrustTokenParamsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    TrustTokenParams()
    {
    }

    String m_type;
    String m_refreshPolicy;
    Maybe<protocol::Array<String>> m_issuers;
};


class CORE_EXPORT Response : public ::crdtp::ProtocolObject<Response> {
public:
    ~Response() override { }

    String getUrl() { return m_url; }
    void setUrl(const String& value) { m_url = value; }

    int getStatus() { return m_status; }
    void setStatus(int value) { m_status = value; }

    String getStatusText() { return m_statusText; }
    void setStatusText(const String& value) { m_statusText = value; }

    protocol::Network::Headers* getHeaders() { return m_headers.get(); }
    void setHeaders(std::unique_ptr<protocol::Network::Headers> value) { m_headers = std::move(value); }

    bool hasHeadersText() { return m_headersText.isJust(); }
    String getHeadersText(const String& defaultValue) { return m_headersText.isJust() ? m_headersText.fromJust() : defaultValue; }
    void setHeadersText(const String& value) { m_headersText = value; }

    String getMimeType() { return m_mimeType; }
    void setMimeType(const String& value) { m_mimeType = value; }

    bool hasRequestHeaders() { return m_requestHeaders.isJust(); }
    protocol::Network::Headers* getRequestHeaders(protocol::Network::Headers* defaultValue) { return m_requestHeaders.isJust() ? m_requestHeaders.fromJust() : defaultValue; }
    void setRequestHeaders(std::unique_ptr<protocol::Network::Headers> value) { m_requestHeaders = std::move(value); }

    bool hasRequestHeadersText() { return m_requestHeadersText.isJust(); }
    String getRequestHeadersText(const String& defaultValue) { return m_requestHeadersText.isJust() ? m_requestHeadersText.fromJust() : defaultValue; }
    void setRequestHeadersText(const String& value) { m_requestHeadersText = value; }

    bool getConnectionReused() { return m_connectionReused; }
    void setConnectionReused(bool value) { m_connectionReused = value; }

    double getConnectionId() { return m_connectionId; }
    void setConnectionId(double value) { m_connectionId = value; }

    bool hasRemoteIPAddress() { return m_remoteIPAddress.isJust(); }
    String getRemoteIPAddress(const String& defaultValue) { return m_remoteIPAddress.isJust() ? m_remoteIPAddress.fromJust() : defaultValue; }
    void setRemoteIPAddress(const String& value) { m_remoteIPAddress = value; }

    bool hasRemotePort() { return m_remotePort.isJust(); }
    int getRemotePort(int defaultValue) { return m_remotePort.isJust() ? m_remotePort.fromJust() : defaultValue; }
    void setRemotePort(int value) { m_remotePort = value; }

    bool hasFromDiskCache() { return m_fromDiskCache.isJust(); }
    bool getFromDiskCache(bool defaultValue) { return m_fromDiskCache.isJust() ? m_fromDiskCache.fromJust() : defaultValue; }
    void setFromDiskCache(bool value) { m_fromDiskCache = value; }

    bool hasFromServiceWorker() { return m_fromServiceWorker.isJust(); }
    bool getFromServiceWorker(bool defaultValue) { return m_fromServiceWorker.isJust() ? m_fromServiceWorker.fromJust() : defaultValue; }
    void setFromServiceWorker(bool value) { m_fromServiceWorker = value; }

    bool hasFromPrefetchCache() { return m_fromPrefetchCache.isJust(); }
    bool getFromPrefetchCache(bool defaultValue) { return m_fromPrefetchCache.isJust() ? m_fromPrefetchCache.fromJust() : defaultValue; }
    void setFromPrefetchCache(bool value) { m_fromPrefetchCache = value; }

    double getEncodedDataLength() { return m_encodedDataLength; }
    void setEncodedDataLength(double value) { m_encodedDataLength = value; }

    bool hasTiming() { return m_timing.isJust(); }
    protocol::Network::ResourceTiming* getTiming(protocol::Network::ResourceTiming* defaultValue) { return m_timing.isJust() ? m_timing.fromJust() : defaultValue; }
    void setTiming(std::unique_ptr<protocol::Network::ResourceTiming> value) { m_timing = std::move(value); }

    bool hasServiceWorkerResponseSource() { return m_serviceWorkerResponseSource.isJust(); }
    String getServiceWorkerResponseSource(const String& defaultValue) { return m_serviceWorkerResponseSource.isJust() ? m_serviceWorkerResponseSource.fromJust() : defaultValue; }
    void setServiceWorkerResponseSource(const String& value) { m_serviceWorkerResponseSource = value; }

    bool hasResponseTime() { return m_responseTime.isJust(); }
    double getResponseTime(double defaultValue) { return m_responseTime.isJust() ? m_responseTime.fromJust() : defaultValue; }
    void setResponseTime(double value) { m_responseTime = value; }

    bool hasCacheStorageCacheName() { return m_cacheStorageCacheName.isJust(); }
    String getCacheStorageCacheName(const String& defaultValue) { return m_cacheStorageCacheName.isJust() ? m_cacheStorageCacheName.fromJust() : defaultValue; }
    void setCacheStorageCacheName(const String& value) { m_cacheStorageCacheName = value; }

    bool hasProtocol() { return m_protocol.isJust(); }
    String getProtocol(const String& defaultValue) { return m_protocol.isJust() ? m_protocol.fromJust() : defaultValue; }
    void setProtocol(const String& value) { m_protocol = value; }

    String getSecurityState() { return m_securityState; }
    void setSecurityState(const String& value) { m_securityState = value; }

    bool hasSecurityDetails() { return m_securityDetails.isJust(); }
    protocol::Network::SecurityDetails* getSecurityDetails(protocol::Network::SecurityDetails* defaultValue) { return m_securityDetails.isJust() ? m_securityDetails.fromJust() : defaultValue; }
    void setSecurityDetails(std::unique_ptr<protocol::Network::SecurityDetails> value) { m_securityDetails = std::move(value); }

    template<int STATE>
    class ResponseBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            UrlSet = 1 << 1,
            StatusSet = 1 << 2,
            StatusTextSet = 1 << 3,
            HeadersSet = 1 << 4,
            MimeTypeSet = 1 << 5,
            ConnectionReusedSet = 1 << 6,
            ConnectionIdSet = 1 << 7,
            EncodedDataLengthSet = 1 << 8,
            SecurityStateSet = 1 << 9,
            AllFieldsSet = (UrlSet | StatusSet | StatusTextSet | HeadersSet | MimeTypeSet | ConnectionReusedSet | ConnectionIdSet | EncodedDataLengthSet | SecurityStateSet | 0)};


        ResponseBuilder<STATE | UrlSet>& setUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->setUrl(value);
            return castState<UrlSet>();
        }

        ResponseBuilder<STATE | StatusSet>& setStatus(int value)
        {
            static_assert(!(STATE & StatusSet), "property status should not be set yet");
            m_result->setStatus(value);
            return castState<StatusSet>();
        }

        ResponseBuilder<STATE | StatusTextSet>& setStatusText(const String& value)
        {
            static_assert(!(STATE & StatusTextSet), "property statusText should not be set yet");
            m_result->setStatusText(value);
            return castState<StatusTextSet>();
        }

        ResponseBuilder<STATE | HeadersSet>& setHeaders(std::unique_ptr<protocol::Network::Headers> value)
        {
            static_assert(!(STATE & HeadersSet), "property headers should not be set yet");
            m_result->setHeaders(std::move(value));
            return castState<HeadersSet>();
        }

        ResponseBuilder<STATE>& setHeadersText(const String& value)
        {
            m_result->setHeadersText(value);
            return *this;
        }

        ResponseBuilder<STATE | MimeTypeSet>& setMimeType(const String& value)
        {
            static_assert(!(STATE & MimeTypeSet), "property mimeType should not be set yet");
            m_result->setMimeType(value);
            return castState<MimeTypeSet>();
        }

        ResponseBuilder<STATE>& setRequestHeaders(std::unique_ptr<protocol::Network::Headers> value)
        {
            m_result->setRequestHeaders(std::move(value));
            return *this;
        }

        ResponseBuilder<STATE>& setRequestHeadersText(const String& value)
        {
            m_result->setRequestHeadersText(value);
            return *this;
        }

        ResponseBuilder<STATE | ConnectionReusedSet>& setConnectionReused(bool value)
        {
            static_assert(!(STATE & ConnectionReusedSet), "property connectionReused should not be set yet");
            m_result->setConnectionReused(value);
            return castState<ConnectionReusedSet>();
        }

        ResponseBuilder<STATE | ConnectionIdSet>& setConnectionId(double value)
        {
            static_assert(!(STATE & ConnectionIdSet), "property connectionId should not be set yet");
            m_result->setConnectionId(value);
            return castState<ConnectionIdSet>();
        }

        ResponseBuilder<STATE>& setRemoteIPAddress(const String& value)
        {
            m_result->setRemoteIPAddress(value);
            return *this;
        }

        ResponseBuilder<STATE>& setRemotePort(int value)
        {
            m_result->setRemotePort(value);
            return *this;
        }

        ResponseBuilder<STATE>& setFromDiskCache(bool value)
        {
            m_result->setFromDiskCache(value);
            return *this;
        }

        ResponseBuilder<STATE>& setFromServiceWorker(bool value)
        {
            m_result->setFromServiceWorker(value);
            return *this;
        }

        ResponseBuilder<STATE>& setFromPrefetchCache(bool value)
        {
            m_result->setFromPrefetchCache(value);
            return *this;
        }

        ResponseBuilder<STATE | EncodedDataLengthSet>& setEncodedDataLength(double value)
        {
            static_assert(!(STATE & EncodedDataLengthSet), "property encodedDataLength should not be set yet");
            m_result->setEncodedDataLength(value);
            return castState<EncodedDataLengthSet>();
        }

        ResponseBuilder<STATE>& setTiming(std::unique_ptr<protocol::Network::ResourceTiming> value)
        {
            m_result->setTiming(std::move(value));
            return *this;
        }

        ResponseBuilder<STATE>& setServiceWorkerResponseSource(const String& value)
        {
            m_result->setServiceWorkerResponseSource(value);
            return *this;
        }

        ResponseBuilder<STATE>& setResponseTime(double value)
        {
            m_result->setResponseTime(value);
            return *this;
        }

        ResponseBuilder<STATE>& setCacheStorageCacheName(const String& value)
        {
            m_result->setCacheStorageCacheName(value);
            return *this;
        }

        ResponseBuilder<STATE>& setProtocol(const String& value)
        {
            m_result->setProtocol(value);
            return *this;
        }

        ResponseBuilder<STATE | SecurityStateSet>& setSecurityState(const String& value)
        {
            static_assert(!(STATE & SecurityStateSet), "property securityState should not be set yet");
            m_result->setSecurityState(value);
            return castState<SecurityStateSet>();
        }

        ResponseBuilder<STATE>& setSecurityDetails(std::unique_ptr<protocol::Network::SecurityDetails> value)
        {
            m_result->setSecurityDetails(std::move(value));
            return *this;
        }

        std::unique_ptr<Response> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class Response;
        ResponseBuilder() : m_result(new Response()) { }

        template<int STEP> ResponseBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ResponseBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::Response> m_result;
    };

    static ResponseBuilder<0> create()
    {
        return ResponseBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    Response()
    {
          m_status = 0;
          m_connectionReused = false;
          m_connectionId = 0;
          m_encodedDataLength = 0;
    }

    String m_url;
    int m_status;
    String m_statusText;
    std::unique_ptr<protocol::Network::Headers> m_headers;
    Maybe<String> m_headersText;
    String m_mimeType;
    Maybe<protocol::Network::Headers> m_requestHeaders;
    Maybe<String> m_requestHeadersText;
    bool m_connectionReused;
    double m_connectionId;
    Maybe<String> m_remoteIPAddress;
    Maybe<int> m_remotePort;
    Maybe<bool> m_fromDiskCache;
    Maybe<bool> m_fromServiceWorker;
    Maybe<bool> m_fromPrefetchCache;
    double m_encodedDataLength;
    Maybe<protocol::Network::ResourceTiming> m_timing;
    Maybe<String> m_serviceWorkerResponseSource;
    Maybe<double> m_responseTime;
    Maybe<String> m_cacheStorageCacheName;
    Maybe<String> m_protocol;
    String m_securityState;
    Maybe<protocol::Network::SecurityDetails> m_securityDetails;
};


class CORE_EXPORT WebSocketRequest : public ::crdtp::ProtocolObject<WebSocketRequest> {
public:
    ~WebSocketRequest() override { }

    protocol::Network::Headers* getHeaders() { return m_headers.get(); }
    void setHeaders(std::unique_ptr<protocol::Network::Headers> value) { m_headers = std::move(value); }

    template<int STATE>
    class WebSocketRequestBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            HeadersSet = 1 << 1,
            AllFieldsSet = (HeadersSet | 0)};


        WebSocketRequestBuilder<STATE | HeadersSet>& setHeaders(std::unique_ptr<protocol::Network::Headers> value)
        {
            static_assert(!(STATE & HeadersSet), "property headers should not be set yet");
            m_result->setHeaders(std::move(value));
            return castState<HeadersSet>();
        }

        std::unique_ptr<WebSocketRequest> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class WebSocketRequest;
        WebSocketRequestBuilder() : m_result(new WebSocketRequest()) { }

        template<int STEP> WebSocketRequestBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<WebSocketRequestBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::WebSocketRequest> m_result;
    };

    static WebSocketRequestBuilder<0> create()
    {
        return WebSocketRequestBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    WebSocketRequest()
    {
    }

    std::unique_ptr<protocol::Network::Headers> m_headers;
};


class CORE_EXPORT WebSocketResponse : public ::crdtp::ProtocolObject<WebSocketResponse> {
public:
    ~WebSocketResponse() override { }

    int getStatus() { return m_status; }
    void setStatus(int value) { m_status = value; }

    String getStatusText() { return m_statusText; }
    void setStatusText(const String& value) { m_statusText = value; }

    protocol::Network::Headers* getHeaders() { return m_headers.get(); }
    void setHeaders(std::unique_ptr<protocol::Network::Headers> value) { m_headers = std::move(value); }

    bool hasHeadersText() { return m_headersText.isJust(); }
    String getHeadersText(const String& defaultValue) { return m_headersText.isJust() ? m_headersText.fromJust() : defaultValue; }
    void setHeadersText(const String& value) { m_headersText = value; }

    bool hasRequestHeaders() { return m_requestHeaders.isJust(); }
    protocol::Network::Headers* getRequestHeaders(protocol::Network::Headers* defaultValue) { return m_requestHeaders.isJust() ? m_requestHeaders.fromJust() : defaultValue; }
    void setRequestHeaders(std::unique_ptr<protocol::Network::Headers> value) { m_requestHeaders = std::move(value); }

    bool hasRequestHeadersText() { return m_requestHeadersText.isJust(); }
    String getRequestHeadersText(const String& defaultValue) { return m_requestHeadersText.isJust() ? m_requestHeadersText.fromJust() : defaultValue; }
    void setRequestHeadersText(const String& value) { m_requestHeadersText = value; }

    template<int STATE>
    class WebSocketResponseBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            StatusSet = 1 << 1,
            StatusTextSet = 1 << 2,
            HeadersSet = 1 << 3,
            AllFieldsSet = (StatusSet | StatusTextSet | HeadersSet | 0)};


        WebSocketResponseBuilder<STATE | StatusSet>& setStatus(int value)
        {
            static_assert(!(STATE & StatusSet), "property status should not be set yet");
            m_result->setStatus(value);
            return castState<StatusSet>();
        }

        WebSocketResponseBuilder<STATE | StatusTextSet>& setStatusText(const String& value)
        {
            static_assert(!(STATE & StatusTextSet), "property statusText should not be set yet");
            m_result->setStatusText(value);
            return castState<StatusTextSet>();
        }

        WebSocketResponseBuilder<STATE | HeadersSet>& setHeaders(std::unique_ptr<protocol::Network::Headers> value)
        {
            static_assert(!(STATE & HeadersSet), "property headers should not be set yet");
            m_result->setHeaders(std::move(value));
            return castState<HeadersSet>();
        }

        WebSocketResponseBuilder<STATE>& setHeadersText(const String& value)
        {
            m_result->setHeadersText(value);
            return *this;
        }

        WebSocketResponseBuilder<STATE>& setRequestHeaders(std::unique_ptr<protocol::Network::Headers> value)
        {
            m_result->setRequestHeaders(std::move(value));
            return *this;
        }

        WebSocketResponseBuilder<STATE>& setRequestHeadersText(const String& value)
        {
            m_result->setRequestHeadersText(value);
            return *this;
        }

        std::unique_ptr<WebSocketResponse> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class WebSocketResponse;
        WebSocketResponseBuilder() : m_result(new WebSocketResponse()) { }

        template<int STEP> WebSocketResponseBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<WebSocketResponseBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::WebSocketResponse> m_result;
    };

    static WebSocketResponseBuilder<0> create()
    {
        return WebSocketResponseBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    WebSocketResponse()
    {
          m_status = 0;
    }

    int m_status;
    String m_statusText;
    std::unique_ptr<protocol::Network::Headers> m_headers;
    Maybe<String> m_headersText;
    Maybe<protocol::Network::Headers> m_requestHeaders;
    Maybe<String> m_requestHeadersText;
};


class CORE_EXPORT WebSocketFrame : public ::crdtp::ProtocolObject<WebSocketFrame> {
public:
    ~WebSocketFrame() override { }

    double getOpcode() { return m_opcode; }
    void setOpcode(double value) { m_opcode = value; }

    bool getMask() { return m_mask; }
    void setMask(bool value) { m_mask = value; }

    String getPayloadData() { return m_payloadData; }
    void setPayloadData(const String& value) { m_payloadData = value; }

    template<int STATE>
    class WebSocketFrameBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            OpcodeSet = 1 << 1,
            MaskSet = 1 << 2,
            PayloadDataSet = 1 << 3,
            AllFieldsSet = (OpcodeSet | MaskSet | PayloadDataSet | 0)};


        WebSocketFrameBuilder<STATE | OpcodeSet>& setOpcode(double value)
        {
            static_assert(!(STATE & OpcodeSet), "property opcode should not be set yet");
            m_result->setOpcode(value);
            return castState<OpcodeSet>();
        }

        WebSocketFrameBuilder<STATE | MaskSet>& setMask(bool value)
        {
            static_assert(!(STATE & MaskSet), "property mask should not be set yet");
            m_result->setMask(value);
            return castState<MaskSet>();
        }

        WebSocketFrameBuilder<STATE | PayloadDataSet>& setPayloadData(const String& value)
        {
            static_assert(!(STATE & PayloadDataSet), "property payloadData should not be set yet");
            m_result->setPayloadData(value);
            return castState<PayloadDataSet>();
        }

        std::unique_ptr<WebSocketFrame> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class WebSocketFrame;
        WebSocketFrameBuilder() : m_result(new WebSocketFrame()) { }

        template<int STEP> WebSocketFrameBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<WebSocketFrameBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::WebSocketFrame> m_result;
    };

    static WebSocketFrameBuilder<0> create()
    {
        return WebSocketFrameBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    WebSocketFrame()
    {
          m_opcode = 0;
          m_mask = false;
    }

    double m_opcode;
    bool m_mask;
    String m_payloadData;
};


class CORE_EXPORT Initiator : public ::crdtp::ProtocolObject<Initiator> {
public:
    ~Initiator() override { }

    struct CORE_EXPORT TypeEnum {
        static const char* Parser;
        static const char* Script;
        static const char* Preload;
        static const char* SignedExchange;
        static const char* Preflight;
        static const char* Other;
    }; // TypeEnum

    String getType() { return m_type; }
    void setType(const String& value) { m_type = value; }

    bool hasStack() { return m_stack.isJust(); }
    v8_inspector::protocol::Runtime::API::StackTrace* getStack(v8_inspector::protocol::Runtime::API::StackTrace* defaultValue) { return m_stack.isJust() ? m_stack.fromJust() : defaultValue; }
    void setStack(std::unique_ptr<v8_inspector::protocol::Runtime::API::StackTrace> value) { m_stack = std::move(value); }

    bool hasUrl() { return m_url.isJust(); }
    String getUrl(const String& defaultValue) { return m_url.isJust() ? m_url.fromJust() : defaultValue; }
    void setUrl(const String& value) { m_url = value; }

    bool hasLineNumber() { return m_lineNumber.isJust(); }
    double getLineNumber(double defaultValue) { return m_lineNumber.isJust() ? m_lineNumber.fromJust() : defaultValue; }
    void setLineNumber(double value) { m_lineNumber = value; }

    bool hasColumnNumber() { return m_columnNumber.isJust(); }
    double getColumnNumber(double defaultValue) { return m_columnNumber.isJust() ? m_columnNumber.fromJust() : defaultValue; }
    void setColumnNumber(double value) { m_columnNumber = value; }

    bool hasRequestId() { return m_requestId.isJust(); }
    String getRequestId(const String& defaultValue) { return m_requestId.isJust() ? m_requestId.fromJust() : defaultValue; }
    void setRequestId(const String& value) { m_requestId = value; }

    template<int STATE>
    class InitiatorBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            TypeSet = 1 << 1,
            AllFieldsSet = (TypeSet | 0)};


        InitiatorBuilder<STATE | TypeSet>& setType(const String& value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setType(value);
            return castState<TypeSet>();
        }

        InitiatorBuilder<STATE>& setStack(std::unique_ptr<v8_inspector::protocol::Runtime::API::StackTrace> value)
        {
            m_result->setStack(std::move(value));
            return *this;
        }

        InitiatorBuilder<STATE>& setUrl(const String& value)
        {
            m_result->setUrl(value);
            return *this;
        }

        InitiatorBuilder<STATE>& setLineNumber(double value)
        {
            m_result->setLineNumber(value);
            return *this;
        }

        InitiatorBuilder<STATE>& setColumnNumber(double value)
        {
            m_result->setColumnNumber(value);
            return *this;
        }

        InitiatorBuilder<STATE>& setRequestId(const String& value)
        {
            m_result->setRequestId(value);
            return *this;
        }

        std::unique_ptr<Initiator> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class Initiator;
        InitiatorBuilder() : m_result(new Initiator()) { }

        template<int STEP> InitiatorBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<InitiatorBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::Initiator> m_result;
    };

    static InitiatorBuilder<0> create()
    {
        return InitiatorBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    Initiator()
    {
    }

    String m_type;
    Maybe<v8_inspector::protocol::Runtime::API::StackTrace> m_stack;
    Maybe<String> m_url;
    Maybe<double> m_lineNumber;
    Maybe<double> m_columnNumber;
    Maybe<String> m_requestId;
};


class CORE_EXPORT Cookie : public ::crdtp::ProtocolObject<Cookie> {
public:
    ~Cookie() override { }

    String getName() { return m_name; }
    void setName(const String& value) { m_name = value; }

    String getValue() { return m_value; }
    void setValue(const String& value) { m_value = value; }

    String getDomain() { return m_domain; }
    void setDomain(const String& value) { m_domain = value; }

    String getPath() { return m_path; }
    void setPath(const String& value) { m_path = value; }

    double getExpires() { return m_expires; }
    void setExpires(double value) { m_expires = value; }

    int getSize() { return m_size; }
    void setSize(int value) { m_size = value; }

    bool getHttpOnly() { return m_httpOnly; }
    void setHttpOnly(bool value) { m_httpOnly = value; }

    bool getSecure() { return m_secure; }
    void setSecure(bool value) { m_secure = value; }

    bool getSession() { return m_session; }
    void setSession(bool value) { m_session = value; }

    bool hasSameSite() { return m_sameSite.isJust(); }
    String getSameSite(const String& defaultValue) { return m_sameSite.isJust() ? m_sameSite.fromJust() : defaultValue; }
    void setSameSite(const String& value) { m_sameSite = value; }

    String getPriority() { return m_priority; }
    void setPriority(const String& value) { m_priority = value; }

    bool getSameParty() { return m_sameParty; }
    void setSameParty(bool value) { m_sameParty = value; }

    String getSourceScheme() { return m_sourceScheme; }
    void setSourceScheme(const String& value) { m_sourceScheme = value; }

    int getSourcePort() { return m_sourcePort; }
    void setSourcePort(int value) { m_sourcePort = value; }

    bool hasPartitionKey() { return m_partitionKey.isJust(); }
    String getPartitionKey(const String& defaultValue) { return m_partitionKey.isJust() ? m_partitionKey.fromJust() : defaultValue; }
    void setPartitionKey(const String& value) { m_partitionKey = value; }

    bool hasPartitionKeyOpaque() { return m_partitionKeyOpaque.isJust(); }
    bool getPartitionKeyOpaque(bool defaultValue) { return m_partitionKeyOpaque.isJust() ? m_partitionKeyOpaque.fromJust() : defaultValue; }
    void setPartitionKeyOpaque(bool value) { m_partitionKeyOpaque = value; }

    template<int STATE>
    class CookieBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            NameSet = 1 << 1,
            ValueSet = 1 << 2,
            DomainSet = 1 << 3,
            PathSet = 1 << 4,
            ExpiresSet = 1 << 5,
            SizeSet = 1 << 6,
            HttpOnlySet = 1 << 7,
            SecureSet = 1 << 8,
            SessionSet = 1 << 9,
            PrioritySet = 1 << 10,
            SamePartySet = 1 << 11,
            SourceSchemeSet = 1 << 12,
            SourcePortSet = 1 << 13,
            AllFieldsSet = (NameSet | ValueSet | DomainSet | PathSet | ExpiresSet | SizeSet | HttpOnlySet | SecureSet | SessionSet | PrioritySet | SamePartySet | SourceSchemeSet | SourcePortSet | 0)};


        CookieBuilder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setName(value);
            return castState<NameSet>();
        }

        CookieBuilder<STATE | ValueSet>& setValue(const String& value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setValue(value);
            return castState<ValueSet>();
        }

        CookieBuilder<STATE | DomainSet>& setDomain(const String& value)
        {
            static_assert(!(STATE & DomainSet), "property domain should not be set yet");
            m_result->setDomain(value);
            return castState<DomainSet>();
        }

        CookieBuilder<STATE | PathSet>& setPath(const String& value)
        {
            static_assert(!(STATE & PathSet), "property path should not be set yet");
            m_result->setPath(value);
            return castState<PathSet>();
        }

        CookieBuilder<STATE | ExpiresSet>& setExpires(double value)
        {
            static_assert(!(STATE & ExpiresSet), "property expires should not be set yet");
            m_result->setExpires(value);
            return castState<ExpiresSet>();
        }

        CookieBuilder<STATE | SizeSet>& setSize(int value)
        {
            static_assert(!(STATE & SizeSet), "property size should not be set yet");
            m_result->setSize(value);
            return castState<SizeSet>();
        }

        CookieBuilder<STATE | HttpOnlySet>& setHttpOnly(bool value)
        {
            static_assert(!(STATE & HttpOnlySet), "property httpOnly should not be set yet");
            m_result->setHttpOnly(value);
            return castState<HttpOnlySet>();
        }

        CookieBuilder<STATE | SecureSet>& setSecure(bool value)
        {
            static_assert(!(STATE & SecureSet), "property secure should not be set yet");
            m_result->setSecure(value);
            return castState<SecureSet>();
        }

        CookieBuilder<STATE | SessionSet>& setSession(bool value)
        {
            static_assert(!(STATE & SessionSet), "property session should not be set yet");
            m_result->setSession(value);
            return castState<SessionSet>();
        }

        CookieBuilder<STATE>& setSameSite(const String& value)
        {
            m_result->setSameSite(value);
            return *this;
        }

        CookieBuilder<STATE | PrioritySet>& setPriority(const String& value)
        {
            static_assert(!(STATE & PrioritySet), "property priority should not be set yet");
            m_result->setPriority(value);
            return castState<PrioritySet>();
        }

        CookieBuilder<STATE | SamePartySet>& setSameParty(bool value)
        {
            static_assert(!(STATE & SamePartySet), "property sameParty should not be set yet");
            m_result->setSameParty(value);
            return castState<SamePartySet>();
        }

        CookieBuilder<STATE | SourceSchemeSet>& setSourceScheme(const String& value)
        {
            static_assert(!(STATE & SourceSchemeSet), "property sourceScheme should not be set yet");
            m_result->setSourceScheme(value);
            return castState<SourceSchemeSet>();
        }

        CookieBuilder<STATE | SourcePortSet>& setSourcePort(int value)
        {
            static_assert(!(STATE & SourcePortSet), "property sourcePort should not be set yet");
            m_result->setSourcePort(value);
            return castState<SourcePortSet>();
        }

        CookieBuilder<STATE>& setPartitionKey(const String& value)
        {
            m_result->setPartitionKey(value);
            return *this;
        }

        CookieBuilder<STATE>& setPartitionKeyOpaque(bool value)
        {
            m_result->setPartitionKeyOpaque(value);
            return *this;
        }

        std::unique_ptr<Cookie> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class Cookie;
        CookieBuilder() : m_result(new Cookie()) { }

        template<int STEP> CookieBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<CookieBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::Cookie> m_result;
    };

    static CookieBuilder<0> create()
    {
        return CookieBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    Cookie()
    {
          m_expires = 0;
          m_size = 0;
          m_httpOnly = false;
          m_secure = false;
          m_session = false;
          m_sameParty = false;
          m_sourcePort = 0;
    }

    String m_name;
    String m_value;
    String m_domain;
    String m_path;
    double m_expires;
    int m_size;
    bool m_httpOnly;
    bool m_secure;
    bool m_session;
    Maybe<String> m_sameSite;
    String m_priority;
    bool m_sameParty;
    String m_sourceScheme;
    int m_sourcePort;
    Maybe<String> m_partitionKey;
    Maybe<bool> m_partitionKeyOpaque;
};


class CORE_EXPORT BlockedSetCookieWithReason : public ::crdtp::ProtocolObject<BlockedSetCookieWithReason> {
public:
    ~BlockedSetCookieWithReason() override { }

    protocol::Array<String>* getBlockedReasons() { return m_blockedReasons.get(); }
    void setBlockedReasons(std::unique_ptr<protocol::Array<String>> value) { m_blockedReasons = std::move(value); }

    String getCookieLine() { return m_cookieLine; }
    void setCookieLine(const String& value) { m_cookieLine = value; }

    bool hasCookie() { return m_cookie.isJust(); }
    protocol::Network::Cookie* getCookie(protocol::Network::Cookie* defaultValue) { return m_cookie.isJust() ? m_cookie.fromJust() : defaultValue; }
    void setCookie(std::unique_ptr<protocol::Network::Cookie> value) { m_cookie = std::move(value); }

    template<int STATE>
    class BlockedSetCookieWithReasonBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            BlockedReasonsSet = 1 << 1,
            CookieLineSet = 1 << 2,
            AllFieldsSet = (BlockedReasonsSet | CookieLineSet | 0)};


        BlockedSetCookieWithReasonBuilder<STATE | BlockedReasonsSet>& setBlockedReasons(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & BlockedReasonsSet), "property blockedReasons should not be set yet");
            m_result->setBlockedReasons(std::move(value));
            return castState<BlockedReasonsSet>();
        }

        BlockedSetCookieWithReasonBuilder<STATE | CookieLineSet>& setCookieLine(const String& value)
        {
            static_assert(!(STATE & CookieLineSet), "property cookieLine should not be set yet");
            m_result->setCookieLine(value);
            return castState<CookieLineSet>();
        }

        BlockedSetCookieWithReasonBuilder<STATE>& setCookie(std::unique_ptr<protocol::Network::Cookie> value)
        {
            m_result->setCookie(std::move(value));
            return *this;
        }

        std::unique_ptr<BlockedSetCookieWithReason> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class BlockedSetCookieWithReason;
        BlockedSetCookieWithReasonBuilder() : m_result(new BlockedSetCookieWithReason()) { }

        template<int STEP> BlockedSetCookieWithReasonBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<BlockedSetCookieWithReasonBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::BlockedSetCookieWithReason> m_result;
    };

    static BlockedSetCookieWithReasonBuilder<0> create()
    {
        return BlockedSetCookieWithReasonBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    BlockedSetCookieWithReason()
    {
    }

    std::unique_ptr<protocol::Array<String>> m_blockedReasons;
    String m_cookieLine;
    Maybe<protocol::Network::Cookie> m_cookie;
};


class CORE_EXPORT BlockedCookieWithReason : public ::crdtp::ProtocolObject<BlockedCookieWithReason> {
public:
    ~BlockedCookieWithReason() override { }

    protocol::Array<String>* getBlockedReasons() { return m_blockedReasons.get(); }
    void setBlockedReasons(std::unique_ptr<protocol::Array<String>> value) { m_blockedReasons = std::move(value); }

    protocol::Network::Cookie* getCookie() { return m_cookie.get(); }
    void setCookie(std::unique_ptr<protocol::Network::Cookie> value) { m_cookie = std::move(value); }

    template<int STATE>
    class BlockedCookieWithReasonBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            BlockedReasonsSet = 1 << 1,
            CookieSet = 1 << 2,
            AllFieldsSet = (BlockedReasonsSet | CookieSet | 0)};


        BlockedCookieWithReasonBuilder<STATE | BlockedReasonsSet>& setBlockedReasons(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & BlockedReasonsSet), "property blockedReasons should not be set yet");
            m_result->setBlockedReasons(std::move(value));
            return castState<BlockedReasonsSet>();
        }

        BlockedCookieWithReasonBuilder<STATE | CookieSet>& setCookie(std::unique_ptr<protocol::Network::Cookie> value)
        {
            static_assert(!(STATE & CookieSet), "property cookie should not be set yet");
            m_result->setCookie(std::move(value));
            return castState<CookieSet>();
        }

        std::unique_ptr<BlockedCookieWithReason> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class BlockedCookieWithReason;
        BlockedCookieWithReasonBuilder() : m_result(new BlockedCookieWithReason()) { }

        template<int STEP> BlockedCookieWithReasonBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<BlockedCookieWithReasonBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::BlockedCookieWithReason> m_result;
    };

    static BlockedCookieWithReasonBuilder<0> create()
    {
        return BlockedCookieWithReasonBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    BlockedCookieWithReason()
    {
    }

    std::unique_ptr<protocol::Array<String>> m_blockedReasons;
    std::unique_ptr<protocol::Network::Cookie> m_cookie;
};


class CORE_EXPORT AuthChallenge : public ::crdtp::ProtocolObject<AuthChallenge> {
public:
    ~AuthChallenge() override { }

    struct CORE_EXPORT SourceEnum {
        static const char* Server;
        static const char* Proxy;
    }; // SourceEnum

    bool hasSource() { return m_source.isJust(); }
    String getSource(const String& defaultValue) { return m_source.isJust() ? m_source.fromJust() : defaultValue; }
    void setSource(const String& value) { m_source = value; }

    String getOrigin() { return m_origin; }
    void setOrigin(const String& value) { m_origin = value; }

    String getScheme() { return m_scheme; }
    void setScheme(const String& value) { m_scheme = value; }

    String getRealm() { return m_realm; }
    void setRealm(const String& value) { m_realm = value; }

    template<int STATE>
    class AuthChallengeBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            OriginSet = 1 << 1,
            SchemeSet = 1 << 2,
            RealmSet = 1 << 3,
            AllFieldsSet = (OriginSet | SchemeSet | RealmSet | 0)};


        AuthChallengeBuilder<STATE>& setSource(const String& value)
        {
            m_result->setSource(value);
            return *this;
        }

        AuthChallengeBuilder<STATE | OriginSet>& setOrigin(const String& value)
        {
            static_assert(!(STATE & OriginSet), "property origin should not be set yet");
            m_result->setOrigin(value);
            return castState<OriginSet>();
        }

        AuthChallengeBuilder<STATE | SchemeSet>& setScheme(const String& value)
        {
            static_assert(!(STATE & SchemeSet), "property scheme should not be set yet");
            m_result->setScheme(value);
            return castState<SchemeSet>();
        }

        AuthChallengeBuilder<STATE | RealmSet>& setRealm(const String& value)
        {
            static_assert(!(STATE & RealmSet), "property realm should not be set yet");
            m_result->setRealm(value);
            return castState<RealmSet>();
        }

        std::unique_ptr<AuthChallenge> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AuthChallenge;
        AuthChallengeBuilder() : m_result(new AuthChallenge()) { }

        template<int STEP> AuthChallengeBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AuthChallengeBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::AuthChallenge> m_result;
    };

    static AuthChallengeBuilder<0> create()
    {
        return AuthChallengeBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AuthChallenge()
    {
    }

    Maybe<String> m_source;
    String m_origin;
    String m_scheme;
    String m_realm;
};


class CORE_EXPORT SignedExchangeSignature : public ::crdtp::ProtocolObject<SignedExchangeSignature> {
public:
    ~SignedExchangeSignature() override { }

    String getLabel() { return m_label; }
    void setLabel(const String& value) { m_label = value; }

    String getSignature() { return m_signature; }
    void setSignature(const String& value) { m_signature = value; }

    String getIntegrity() { return m_integrity; }
    void setIntegrity(const String& value) { m_integrity = value; }

    bool hasCertUrl() { return m_certUrl.isJust(); }
    String getCertUrl(const String& defaultValue) { return m_certUrl.isJust() ? m_certUrl.fromJust() : defaultValue; }
    void setCertUrl(const String& value) { m_certUrl = value; }

    bool hasCertSha256() { return m_certSha256.isJust(); }
    String getCertSha256(const String& defaultValue) { return m_certSha256.isJust() ? m_certSha256.fromJust() : defaultValue; }
    void setCertSha256(const String& value) { m_certSha256 = value; }

    String getValidityUrl() { return m_validityUrl; }
    void setValidityUrl(const String& value) { m_validityUrl = value; }

    int getDate() { return m_date; }
    void setDate(int value) { m_date = value; }

    int getExpires() { return m_expires; }
    void setExpires(int value) { m_expires = value; }

    bool hasCertificates() { return m_certificates.isJust(); }
    protocol::Array<String>* getCertificates(protocol::Array<String>* defaultValue) { return m_certificates.isJust() ? m_certificates.fromJust() : defaultValue; }
    void setCertificates(std::unique_ptr<protocol::Array<String>> value) { m_certificates = std::move(value); }

    template<int STATE>
    class SignedExchangeSignatureBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            LabelSet = 1 << 1,
            SignatureSet = 1 << 2,
            IntegritySet = 1 << 3,
            ValidityUrlSet = 1 << 4,
            DateSet = 1 << 5,
            ExpiresSet = 1 << 6,
            AllFieldsSet = (LabelSet | SignatureSet | IntegritySet | ValidityUrlSet | DateSet | ExpiresSet | 0)};


        SignedExchangeSignatureBuilder<STATE | LabelSet>& setLabel(const String& value)
        {
            static_assert(!(STATE & LabelSet), "property label should not be set yet");
            m_result->setLabel(value);
            return castState<LabelSet>();
        }

        SignedExchangeSignatureBuilder<STATE | SignatureSet>& setSignature(const String& value)
        {
            static_assert(!(STATE & SignatureSet), "property signature should not be set yet");
            m_result->setSignature(value);
            return castState<SignatureSet>();
        }

        SignedExchangeSignatureBuilder<STATE | IntegritySet>& setIntegrity(const String& value)
        {
            static_assert(!(STATE & IntegritySet), "property integrity should not be set yet");
            m_result->setIntegrity(value);
            return castState<IntegritySet>();
        }

        SignedExchangeSignatureBuilder<STATE>& setCertUrl(const String& value)
        {
            m_result->setCertUrl(value);
            return *this;
        }

        SignedExchangeSignatureBuilder<STATE>& setCertSha256(const String& value)
        {
            m_result->setCertSha256(value);
            return *this;
        }

        SignedExchangeSignatureBuilder<STATE | ValidityUrlSet>& setValidityUrl(const String& value)
        {
            static_assert(!(STATE & ValidityUrlSet), "property validityUrl should not be set yet");
            m_result->setValidityUrl(value);
            return castState<ValidityUrlSet>();
        }

        SignedExchangeSignatureBuilder<STATE | DateSet>& setDate(int value)
        {
            static_assert(!(STATE & DateSet), "property date should not be set yet");
            m_result->setDate(value);
            return castState<DateSet>();
        }

        SignedExchangeSignatureBuilder<STATE | ExpiresSet>& setExpires(int value)
        {
            static_assert(!(STATE & ExpiresSet), "property expires should not be set yet");
            m_result->setExpires(value);
            return castState<ExpiresSet>();
        }

        SignedExchangeSignatureBuilder<STATE>& setCertificates(std::unique_ptr<protocol::Array<String>> value)
        {
            m_result->setCertificates(std::move(value));
            return *this;
        }

        std::unique_ptr<SignedExchangeSignature> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SignedExchangeSignature;
        SignedExchangeSignatureBuilder() : m_result(new SignedExchangeSignature()) { }

        template<int STEP> SignedExchangeSignatureBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SignedExchangeSignatureBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::SignedExchangeSignature> m_result;
    };

    static SignedExchangeSignatureBuilder<0> create()
    {
        return SignedExchangeSignatureBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    SignedExchangeSignature()
    {
          m_date = 0;
          m_expires = 0;
    }

    String m_label;
    String m_signature;
    String m_integrity;
    Maybe<String> m_certUrl;
    Maybe<String> m_certSha256;
    String m_validityUrl;
    int m_date;
    int m_expires;
    Maybe<protocol::Array<String>> m_certificates;
};


class CORE_EXPORT SignedExchangeHeader : public ::crdtp::ProtocolObject<SignedExchangeHeader> {
public:
    ~SignedExchangeHeader() override { }

    String getRequestUrl() { return m_requestUrl; }
    void setRequestUrl(const String& value) { m_requestUrl = value; }

    int getResponseCode() { return m_responseCode; }
    void setResponseCode(int value) { m_responseCode = value; }

    protocol::Network::Headers* getResponseHeaders() { return m_responseHeaders.get(); }
    void setResponseHeaders(std::unique_ptr<protocol::Network::Headers> value) { m_responseHeaders = std::move(value); }

    protocol::Array<protocol::Network::SignedExchangeSignature>* getSignatures() { return m_signatures.get(); }
    void setSignatures(std::unique_ptr<protocol::Array<protocol::Network::SignedExchangeSignature>> value) { m_signatures = std::move(value); }

    String getHeaderIntegrity() { return m_headerIntegrity; }
    void setHeaderIntegrity(const String& value) { m_headerIntegrity = value; }

    template<int STATE>
    class SignedExchangeHeaderBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            RequestUrlSet = 1 << 1,
            ResponseCodeSet = 1 << 2,
            ResponseHeadersSet = 1 << 3,
            SignaturesSet = 1 << 4,
            HeaderIntegritySet = 1 << 5,
            AllFieldsSet = (RequestUrlSet | ResponseCodeSet | ResponseHeadersSet | SignaturesSet | HeaderIntegritySet | 0)};


        SignedExchangeHeaderBuilder<STATE | RequestUrlSet>& setRequestUrl(const String& value)
        {
            static_assert(!(STATE & RequestUrlSet), "property requestUrl should not be set yet");
            m_result->setRequestUrl(value);
            return castState<RequestUrlSet>();
        }

        SignedExchangeHeaderBuilder<STATE | ResponseCodeSet>& setResponseCode(int value)
        {
            static_assert(!(STATE & ResponseCodeSet), "property responseCode should not be set yet");
            m_result->setResponseCode(value);
            return castState<ResponseCodeSet>();
        }

        SignedExchangeHeaderBuilder<STATE | ResponseHeadersSet>& setResponseHeaders(std::unique_ptr<protocol::Network::Headers> value)
        {
            static_assert(!(STATE & ResponseHeadersSet), "property responseHeaders should not be set yet");
            m_result->setResponseHeaders(std::move(value));
            return castState<ResponseHeadersSet>();
        }

        SignedExchangeHeaderBuilder<STATE | SignaturesSet>& setSignatures(std::unique_ptr<protocol::Array<protocol::Network::SignedExchangeSignature>> value)
        {
            static_assert(!(STATE & SignaturesSet), "property signatures should not be set yet");
            m_result->setSignatures(std::move(value));
            return castState<SignaturesSet>();
        }

        SignedExchangeHeaderBuilder<STATE | HeaderIntegritySet>& setHeaderIntegrity(const String& value)
        {
            static_assert(!(STATE & HeaderIntegritySet), "property headerIntegrity should not be set yet");
            m_result->setHeaderIntegrity(value);
            return castState<HeaderIntegritySet>();
        }

        std::unique_ptr<SignedExchangeHeader> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SignedExchangeHeader;
        SignedExchangeHeaderBuilder() : m_result(new SignedExchangeHeader()) { }

        template<int STEP> SignedExchangeHeaderBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SignedExchangeHeaderBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::SignedExchangeHeader> m_result;
    };

    static SignedExchangeHeaderBuilder<0> create()
    {
        return SignedExchangeHeaderBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    SignedExchangeHeader()
    {
          m_responseCode = 0;
    }

    String m_requestUrl;
    int m_responseCode;
    std::unique_ptr<protocol::Network::Headers> m_responseHeaders;
    std::unique_ptr<protocol::Array<protocol::Network::SignedExchangeSignature>> m_signatures;
    String m_headerIntegrity;
};


class CORE_EXPORT SignedExchangeError : public ::crdtp::ProtocolObject<SignedExchangeError> {
public:
    ~SignedExchangeError() override { }

    String getMessage() { return m_message; }
    void setMessage(const String& value) { m_message = value; }

    bool hasSignatureIndex() { return m_signatureIndex.isJust(); }
    int getSignatureIndex(int defaultValue) { return m_signatureIndex.isJust() ? m_signatureIndex.fromJust() : defaultValue; }
    void setSignatureIndex(int value) { m_signatureIndex = value; }

    bool hasErrorField() { return m_errorField.isJust(); }
    String getErrorField(const String& defaultValue) { return m_errorField.isJust() ? m_errorField.fromJust() : defaultValue; }
    void setErrorField(const String& value) { m_errorField = value; }

    template<int STATE>
    class SignedExchangeErrorBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            MessageSet = 1 << 1,
            AllFieldsSet = (MessageSet | 0)};


        SignedExchangeErrorBuilder<STATE | MessageSet>& setMessage(const String& value)
        {
            static_assert(!(STATE & MessageSet), "property message should not be set yet");
            m_result->setMessage(value);
            return castState<MessageSet>();
        }

        SignedExchangeErrorBuilder<STATE>& setSignatureIndex(int value)
        {
            m_result->setSignatureIndex(value);
            return *this;
        }

        SignedExchangeErrorBuilder<STATE>& setErrorField(const String& value)
        {
            m_result->setErrorField(value);
            return *this;
        }

        std::unique_ptr<SignedExchangeError> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SignedExchangeError;
        SignedExchangeErrorBuilder() : m_result(new SignedExchangeError()) { }

        template<int STEP> SignedExchangeErrorBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SignedExchangeErrorBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::SignedExchangeError> m_result;
    };

    static SignedExchangeErrorBuilder<0> create()
    {
        return SignedExchangeErrorBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    SignedExchangeError()
    {
    }

    String m_message;
    Maybe<int> m_signatureIndex;
    Maybe<String> m_errorField;
};


class CORE_EXPORT SignedExchangeInfo : public ::crdtp::ProtocolObject<SignedExchangeInfo> {
public:
    ~SignedExchangeInfo() override { }

    protocol::Network::Response* getOuterResponse() { return m_outerResponse.get(); }
    void setOuterResponse(std::unique_ptr<protocol::Network::Response> value) { m_outerResponse = std::move(value); }

    bool hasHeader() { return m_header.isJust(); }
    protocol::Network::SignedExchangeHeader* getHeader(protocol::Network::SignedExchangeHeader* defaultValue) { return m_header.isJust() ? m_header.fromJust() : defaultValue; }
    void setHeader(std::unique_ptr<protocol::Network::SignedExchangeHeader> value) { m_header = std::move(value); }

    bool hasSecurityDetails() { return m_securityDetails.isJust(); }
    protocol::Network::SecurityDetails* getSecurityDetails(protocol::Network::SecurityDetails* defaultValue) { return m_securityDetails.isJust() ? m_securityDetails.fromJust() : defaultValue; }
    void setSecurityDetails(std::unique_ptr<protocol::Network::SecurityDetails> value) { m_securityDetails = std::move(value); }

    bool hasErrors() { return m_errors.isJust(); }
    protocol::Array<protocol::Network::SignedExchangeError>* getErrors(protocol::Array<protocol::Network::SignedExchangeError>* defaultValue) { return m_errors.isJust() ? m_errors.fromJust() : defaultValue; }
    void setErrors(std::unique_ptr<protocol::Array<protocol::Network::SignedExchangeError>> value) { m_errors = std::move(value); }

    template<int STATE>
    class SignedExchangeInfoBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            OuterResponseSet = 1 << 1,
            AllFieldsSet = (OuterResponseSet | 0)};


        SignedExchangeInfoBuilder<STATE | OuterResponseSet>& setOuterResponse(std::unique_ptr<protocol::Network::Response> value)
        {
            static_assert(!(STATE & OuterResponseSet), "property outerResponse should not be set yet");
            m_result->setOuterResponse(std::move(value));
            return castState<OuterResponseSet>();
        }

        SignedExchangeInfoBuilder<STATE>& setHeader(std::unique_ptr<protocol::Network::SignedExchangeHeader> value)
        {
            m_result->setHeader(std::move(value));
            return *this;
        }

        SignedExchangeInfoBuilder<STATE>& setSecurityDetails(std::unique_ptr<protocol::Network::SecurityDetails> value)
        {
            m_result->setSecurityDetails(std::move(value));
            return *this;
        }

        SignedExchangeInfoBuilder<STATE>& setErrors(std::unique_ptr<protocol::Array<protocol::Network::SignedExchangeError>> value)
        {
            m_result->setErrors(std::move(value));
            return *this;
        }

        std::unique_ptr<SignedExchangeInfo> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SignedExchangeInfo;
        SignedExchangeInfoBuilder() : m_result(new SignedExchangeInfo()) { }

        template<int STEP> SignedExchangeInfoBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SignedExchangeInfoBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::SignedExchangeInfo> m_result;
    };

    static SignedExchangeInfoBuilder<0> create()
    {
        return SignedExchangeInfoBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    SignedExchangeInfo()
    {
    }

    std::unique_ptr<protocol::Network::Response> m_outerResponse;
    Maybe<protocol::Network::SignedExchangeHeader> m_header;
    Maybe<protocol::Network::SecurityDetails> m_securityDetails;
    Maybe<protocol::Array<protocol::Network::SignedExchangeError>> m_errors;
};


class CORE_EXPORT ConnectTiming : public ::crdtp::ProtocolObject<ConnectTiming> {
public:
    ~ConnectTiming() override { }

    double getRequestTime() { return m_requestTime; }
    void setRequestTime(double value) { m_requestTime = value; }

    template<int STATE>
    class ConnectTimingBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            RequestTimeSet = 1 << 1,
            AllFieldsSet = (RequestTimeSet | 0)};


        ConnectTimingBuilder<STATE | RequestTimeSet>& setRequestTime(double value)
        {
            static_assert(!(STATE & RequestTimeSet), "property requestTime should not be set yet");
            m_result->setRequestTime(value);
            return castState<RequestTimeSet>();
        }

        std::unique_ptr<ConnectTiming> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ConnectTiming;
        ConnectTimingBuilder() : m_result(new ConnectTiming()) { }

        template<int STEP> ConnectTimingBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ConnectTimingBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::ConnectTiming> m_result;
    };

    static ConnectTimingBuilder<0> create()
    {
        return ConnectTimingBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    ConnectTiming()
    {
          m_requestTime = 0;
    }

    double m_requestTime;
};


class CORE_EXPORT ClientSecurityState : public ::crdtp::ProtocolObject<ClientSecurityState> {
public:
    ~ClientSecurityState() override { }

    bool getInitiatorIsSecureContext() { return m_initiatorIsSecureContext; }
    void setInitiatorIsSecureContext(bool value) { m_initiatorIsSecureContext = value; }

    String getInitiatorIPAddressSpace() { return m_initiatorIPAddressSpace; }
    void setInitiatorIPAddressSpace(const String& value) { m_initiatorIPAddressSpace = value; }

    String getPrivateNetworkRequestPolicy() { return m_privateNetworkRequestPolicy; }
    void setPrivateNetworkRequestPolicy(const String& value) { m_privateNetworkRequestPolicy = value; }

    template<int STATE>
    class ClientSecurityStateBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            InitiatorIsSecureContextSet = 1 << 1,
            InitiatorIPAddressSpaceSet = 1 << 2,
            PrivateNetworkRequestPolicySet = 1 << 3,
            AllFieldsSet = (InitiatorIsSecureContextSet | InitiatorIPAddressSpaceSet | PrivateNetworkRequestPolicySet | 0)};


        ClientSecurityStateBuilder<STATE | InitiatorIsSecureContextSet>& setInitiatorIsSecureContext(bool value)
        {
            static_assert(!(STATE & InitiatorIsSecureContextSet), "property initiatorIsSecureContext should not be set yet");
            m_result->setInitiatorIsSecureContext(value);
            return castState<InitiatorIsSecureContextSet>();
        }

        ClientSecurityStateBuilder<STATE | InitiatorIPAddressSpaceSet>& setInitiatorIPAddressSpace(const String& value)
        {
            static_assert(!(STATE & InitiatorIPAddressSpaceSet), "property initiatorIPAddressSpace should not be set yet");
            m_result->setInitiatorIPAddressSpace(value);
            return castState<InitiatorIPAddressSpaceSet>();
        }

        ClientSecurityStateBuilder<STATE | PrivateNetworkRequestPolicySet>& setPrivateNetworkRequestPolicy(const String& value)
        {
            static_assert(!(STATE & PrivateNetworkRequestPolicySet), "property privateNetworkRequestPolicy should not be set yet");
            m_result->setPrivateNetworkRequestPolicy(value);
            return castState<PrivateNetworkRequestPolicySet>();
        }

        std::unique_ptr<ClientSecurityState> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ClientSecurityState;
        ClientSecurityStateBuilder() : m_result(new ClientSecurityState()) { }

        template<int STEP> ClientSecurityStateBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ClientSecurityStateBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::ClientSecurityState> m_result;
    };

    static ClientSecurityStateBuilder<0> create()
    {
        return ClientSecurityStateBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    ClientSecurityState()
    {
          m_initiatorIsSecureContext = false;
    }

    bool m_initiatorIsSecureContext;
    String m_initiatorIPAddressSpace;
    String m_privateNetworkRequestPolicy;
};


class CORE_EXPORT ReportingApiReport : public ::crdtp::ProtocolObject<ReportingApiReport> {
public:
    ~ReportingApiReport() override { }

    String getId() { return m_id; }
    void setId(const String& value) { m_id = value; }

    String getInitiatorUrl() { return m_initiatorUrl; }
    void setInitiatorUrl(const String& value) { m_initiatorUrl = value; }

    String getDestination() { return m_destination; }
    void setDestination(const String& value) { m_destination = value; }

    String getType() { return m_type; }
    void setType(const String& value) { m_type = value; }

    double getTimestamp() { return m_timestamp; }
    void setTimestamp(double value) { m_timestamp = value; }

    int getDepth() { return m_depth; }
    void setDepth(int value) { m_depth = value; }

    int getCompletedAttempts() { return m_completedAttempts; }
    void setCompletedAttempts(int value) { m_completedAttempts = value; }

    protocol::DictionaryValue* getBody() { return m_body.get(); }
    void setBody(std::unique_ptr<protocol::DictionaryValue> value) { m_body = std::move(value); }

    String getStatus() { return m_status; }
    void setStatus(const String& value) { m_status = value; }

    template<int STATE>
    class ReportingApiReportBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            IdSet = 1 << 1,
            InitiatorUrlSet = 1 << 2,
            DestinationSet = 1 << 3,
            TypeSet = 1 << 4,
            TimestampSet = 1 << 5,
            DepthSet = 1 << 6,
            CompletedAttemptsSet = 1 << 7,
            BodySet = 1 << 8,
            StatusSet = 1 << 9,
            AllFieldsSet = (IdSet | InitiatorUrlSet | DestinationSet | TypeSet | TimestampSet | DepthSet | CompletedAttemptsSet | BodySet | StatusSet | 0)};


        ReportingApiReportBuilder<STATE | IdSet>& setId(const String& value)
        {
            static_assert(!(STATE & IdSet), "property id should not be set yet");
            m_result->setId(value);
            return castState<IdSet>();
        }

        ReportingApiReportBuilder<STATE | InitiatorUrlSet>& setInitiatorUrl(const String& value)
        {
            static_assert(!(STATE & InitiatorUrlSet), "property initiatorUrl should not be set yet");
            m_result->setInitiatorUrl(value);
            return castState<InitiatorUrlSet>();
        }

        ReportingApiReportBuilder<STATE | DestinationSet>& setDestination(const String& value)
        {
            static_assert(!(STATE & DestinationSet), "property destination should not be set yet");
            m_result->setDestination(value);
            return castState<DestinationSet>();
        }

        ReportingApiReportBuilder<STATE | TypeSet>& setType(const String& value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setType(value);
            return castState<TypeSet>();
        }

        ReportingApiReportBuilder<STATE | TimestampSet>& setTimestamp(double value)
        {
            static_assert(!(STATE & TimestampSet), "property timestamp should not be set yet");
            m_result->setTimestamp(value);
            return castState<TimestampSet>();
        }

        ReportingApiReportBuilder<STATE | DepthSet>& setDepth(int value)
        {
            static_assert(!(STATE & DepthSet), "property depth should not be set yet");
            m_result->setDepth(value);
            return castState<DepthSet>();
        }

        ReportingApiReportBuilder<STATE | CompletedAttemptsSet>& setCompletedAttempts(int value)
        {
            static_assert(!(STATE & CompletedAttemptsSet), "property completedAttempts should not be set yet");
            m_result->setCompletedAttempts(value);
            return castState<CompletedAttemptsSet>();
        }

        ReportingApiReportBuilder<STATE | BodySet>& setBody(std::unique_ptr<protocol::DictionaryValue> value)
        {
            static_assert(!(STATE & BodySet), "property body should not be set yet");
            m_result->setBody(std::move(value));
            return castState<BodySet>();
        }

        ReportingApiReportBuilder<STATE | StatusSet>& setStatus(const String& value)
        {
            static_assert(!(STATE & StatusSet), "property status should not be set yet");
            m_result->setStatus(value);
            return castState<StatusSet>();
        }

        std::unique_ptr<ReportingApiReport> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ReportingApiReport;
        ReportingApiReportBuilder() : m_result(new ReportingApiReport()) { }

        template<int STEP> ReportingApiReportBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ReportingApiReportBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::ReportingApiReport> m_result;
    };

    static ReportingApiReportBuilder<0> create()
    {
        return ReportingApiReportBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    ReportingApiReport()
    {
          m_timestamp = 0;
          m_depth = 0;
          m_completedAttempts = 0;
    }

    String m_id;
    String m_initiatorUrl;
    String m_destination;
    String m_type;
    double m_timestamp;
    int m_depth;
    int m_completedAttempts;
    std::unique_ptr<protocol::DictionaryValue> m_body;
    String m_status;
};


class CORE_EXPORT ReportingApiEndpoint : public ::crdtp::ProtocolObject<ReportingApiEndpoint> {
public:
    ~ReportingApiEndpoint() override { }

    String getUrl() { return m_url; }
    void setUrl(const String& value) { m_url = value; }

    String getGroupName() { return m_groupName; }
    void setGroupName(const String& value) { m_groupName = value; }

    template<int STATE>
    class ReportingApiEndpointBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            UrlSet = 1 << 1,
            GroupNameSet = 1 << 2,
            AllFieldsSet = (UrlSet | GroupNameSet | 0)};


        ReportingApiEndpointBuilder<STATE | UrlSet>& setUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->setUrl(value);
            return castState<UrlSet>();
        }

        ReportingApiEndpointBuilder<STATE | GroupNameSet>& setGroupName(const String& value)
        {
            static_assert(!(STATE & GroupNameSet), "property groupName should not be set yet");
            m_result->setGroupName(value);
            return castState<GroupNameSet>();
        }

        std::unique_ptr<ReportingApiEndpoint> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ReportingApiEndpoint;
        ReportingApiEndpointBuilder() : m_result(new ReportingApiEndpoint()) { }

        template<int STEP> ReportingApiEndpointBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ReportingApiEndpointBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Network::ReportingApiEndpoint> m_result;
    };

    static ReportingApiEndpointBuilder<0> create()
    {
        return ReportingApiEndpointBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    ReportingApiEndpoint()
    {
    }

    String m_url;
    String m_groupName;
};


// ------------- Backend interface.

class CORE_EXPORT Backend {
public:
    virtual ~Backend() { }

    virtual DispatchResponse setAcceptedEncodings(std::unique_ptr<protocol::Array<String>> in_encodings) = 0;
    virtual DispatchResponse clearAcceptedEncodingsOverride() = 0;
    virtual DispatchResponse canClearBrowserCache(bool* out_result) = 0;
    virtual DispatchResponse canClearBrowserCookies(bool* out_result) = 0;
    virtual DispatchResponse disable() = 0;
    virtual DispatchResponse emulateNetworkConditions(bool in_offline, double in_latency, double in_downloadThroughput, double in_uploadThroughput, Maybe<String> in_connectionType) = 0;
    virtual DispatchResponse enable(Maybe<int> in_maxTotalBufferSize, Maybe<int> in_maxResourceBufferSize, Maybe<int> in_maxPostDataSize) = 0;
    virtual DispatchResponse getCertificate(const String& in_origin, std::unique_ptr<protocol::Array<String>>* out_tableNames) = 0;
    class CORE_EXPORT GetResponseBodyCallback {
    public:
        virtual void sendSuccess(const String& body, bool base64Encoded) = 0;
        virtual void sendFailure(const DispatchResponse&) = 0;
        virtual void fallThrough() = 0;
        virtual ~GetResponseBodyCallback() { }
    };
    virtual void getResponseBody(const String& in_requestId, std::unique_ptr<GetResponseBodyCallback> callback) = 0;
    class CORE_EXPORT GetRequestPostDataCallback {
    public:
        virtual void sendSuccess(const String& postData) = 0;
        virtual void sendFailure(const DispatchResponse&) = 0;
        virtual void fallThrough() = 0;
        virtual ~GetRequestPostDataCallback() { }
    };
    virtual void getRequestPostData(const String& in_requestId, std::unique_ptr<GetRequestPostDataCallback> callback) = 0;
    virtual DispatchResponse replayXHR(const String& in_requestId) = 0;
    virtual DispatchResponse searchInResponseBody(const String& in_requestId, const String& in_query, Maybe<bool> in_caseSensitive, Maybe<bool> in_isRegex, std::unique_ptr<protocol::Array<v8_inspector::protocol::Debugger::API::SearchMatch>>* out_result) = 0;
    virtual DispatchResponse setBlockedURLs(std::unique_ptr<protocol::Array<String>> in_urls) = 0;
    virtual DispatchResponse setBypassServiceWorker(bool in_bypass) = 0;
    virtual DispatchResponse setCacheDisabled(bool in_cacheDisabled) = 0;
    virtual DispatchResponse setExtraHTTPHeaders(std::unique_ptr<protocol::Network::Headers> in_headers) = 0;
    virtual DispatchResponse setAttachDebugStack(bool in_enabled) = 0;

};

// ------------- Frontend interface.

class CORE_EXPORT Frontend {
public:
  explicit Frontend(FrontendChannel* frontend_channel) : frontend_channel_(frontend_channel) {}
    void dataReceived(const String& requestId, double timestamp, int dataLength, int encodedDataLength);
    void eventSourceMessageReceived(const String& requestId, double timestamp, const String& eventName, const String& eventId, const String& data);
    void loadingFailed(const String& requestId, double timestamp, const String& type, const String& errorText, Maybe<bool> canceled = Maybe<bool>(), Maybe<String> blockedReason = Maybe<String>(), Maybe<protocol::Network::CorsErrorStatus> corsErrorStatus = Maybe<protocol::Network::CorsErrorStatus>());
    void loadingFinished(const String& requestId, double timestamp, double encodedDataLength, Maybe<bool> shouldReportCorbBlocking = Maybe<bool>());
    void requestIntercepted(const String& interceptionId, std::unique_ptr<protocol::Network::Request> request, const String& frameId, const String& resourceType, bool isNavigationRequest, Maybe<bool> isDownload = Maybe<bool>(), Maybe<String> redirectUrl = Maybe<String>(), Maybe<protocol::Network::AuthChallenge> authChallenge = Maybe<protocol::Network::AuthChallenge>(), Maybe<String> responseErrorReason = Maybe<String>(), Maybe<int> responseStatusCode = Maybe<int>(), Maybe<protocol::Network::Headers> responseHeaders = Maybe<protocol::Network::Headers>(), Maybe<String> requestId = Maybe<String>());
    void requestServedFromCache(const String& requestId);
    void requestWillBeSent(const String& requestId, const String& loaderId, const String& documentURL, std::unique_ptr<protocol::Network::Request> request, double timestamp, double wallTime, std::unique_ptr<protocol::Network::Initiator> initiator, bool redirectHasExtraInfo, Maybe<protocol::Network::Response> redirectResponse = Maybe<protocol::Network::Response>(), Maybe<String> type = Maybe<String>(), Maybe<String> frameId = Maybe<String>(), Maybe<bool> hasUserGesture = Maybe<bool>());
    void resourceChangedPriority(const String& requestId, const String& newPriority, double timestamp);
    void signedExchangeReceived(const String& requestId, std::unique_ptr<protocol::Network::SignedExchangeInfo> info);
    void responseReceived(const String& requestId, const String& loaderId, double timestamp, const String& type, std::unique_ptr<protocol::Network::Response> response, bool hasExtraInfo, Maybe<String> frameId = Maybe<String>());
    void webSocketClosed(const String& requestId, double timestamp);
    void webSocketCreated(const String& requestId, const String& url, Maybe<protocol::Network::Initiator> initiator = Maybe<protocol::Network::Initiator>());
    void webSocketFrameError(const String& requestId, double timestamp, const String& errorMessage);
    void webSocketFrameReceived(const String& requestId, double timestamp, std::unique_ptr<protocol::Network::WebSocketFrame> response);
    void webSocketFrameSent(const String& requestId, double timestamp, std::unique_ptr<protocol::Network::WebSocketFrame> response);
    void webSocketHandshakeResponseReceived(const String& requestId, double timestamp, std::unique_ptr<protocol::Network::WebSocketResponse> response);
    void webSocketWillSendHandshakeRequest(const String& requestId, double timestamp, double wallTime, std::unique_ptr<protocol::Network::WebSocketRequest> request);
    void webTransportCreated(const String& transportId, const String& url, double timestamp, Maybe<protocol::Network::Initiator> initiator = Maybe<protocol::Network::Initiator>());
    void webTransportConnectionEstablished(const String& transportId, double timestamp);
    void webTransportClosed(const String& transportId, double timestamp);
    void requestWillBeSentExtraInfo(const String& requestId, std::unique_ptr<protocol::Array<protocol::Network::BlockedCookieWithReason>> associatedCookies, std::unique_ptr<protocol::Network::Headers> headers, std::unique_ptr<protocol::Network::ConnectTiming> connectTiming, Maybe<protocol::Network::ClientSecurityState> clientSecurityState = Maybe<protocol::Network::ClientSecurityState>());
    void responseReceivedExtraInfo(const String& requestId, std::unique_ptr<protocol::Array<protocol::Network::BlockedSetCookieWithReason>> blockedCookies, std::unique_ptr<protocol::Network::Headers> headers, const String& resourceIPAddressSpace, int statusCode, Maybe<String> headersText = Maybe<String>());
    void trustTokenOperationDone(const String& status, const String& type, const String& requestId, Maybe<String> topLevelOrigin = Maybe<String>(), Maybe<String> issuerOrigin = Maybe<String>(), Maybe<int> issuedTokenCount = Maybe<int>());
    void subresourceWebBundleMetadataReceived(const String& requestId, std::unique_ptr<protocol::Array<String>> urls);
    void subresourceWebBundleMetadataError(const String& requestId, const String& errorMessage);
    void subresourceWebBundleInnerResponseParsed(const String& innerRequestId, const String& innerRequestURL, Maybe<String> bundleRequestId = Maybe<String>());
    void subresourceWebBundleInnerResponseError(const String& innerRequestId, const String& innerRequestURL, const String& errorMessage, Maybe<String> bundleRequestId = Maybe<String>());
    void reportingApiReportAdded(std::unique_ptr<protocol::Network::ReportingApiReport> report);
    void reportingApiReportUpdated(std::unique_ptr<protocol::Network::ReportingApiReport> report);
    void reportingApiEndpointsChangedForOrigin(const String& origin, std::unique_ptr<protocol::Array<protocol::Network::ReportingApiEndpoint>> endpoints);

  void flush();
  void sendRawNotification(std::unique_ptr<Serializable>);
 private:
  FrontendChannel* frontend_channel_;
};

// ------------- Dispatcher.

class CORE_EXPORT Dispatcher {
public:
    static void wire(UberDispatcher*, Backend*);

private:
    Dispatcher() { }
};

// ------------- Metainfo.

class CORE_EXPORT Metainfo {
public:
    using BackendClass = Backend;
    using FrontendClass = Frontend;
    using DispatcherClass = Dispatcher;
    static const char domainName[];
    static const char commandPrefix[];
    static const char version[];
};

} // namespace Network
} // namespace blink
} // namespace protocol

#endif // !defined(blink_protocol_Network_h)
