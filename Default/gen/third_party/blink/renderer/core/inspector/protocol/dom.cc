// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "third_party/blink/renderer/core/inspector/protocol/dom.h"

#include "third_party/blink/renderer/core/inspector/protocol/protocol.h"

#include "third_party/inspector_protocol/crdtp/cbor.h"
#include "third_party/inspector_protocol/crdtp/find_by_first.h"
#include "third_party/inspector_protocol/crdtp/span.h"

namespace blink {
namespace protocol {
namespace DOM {

using crdtp::DeserializerState;
using crdtp::ProtocolTypeTraits;

// ------------- Enum values from types.

const char Metainfo::domainName[] = "DOM";
const char Metainfo::commandPrefix[] = "DOM.";
const char Metainfo::version[] = "1.3";



CRDTP_BEGIN_DESERIALIZER(BackendNode)
    CRDTP_DESERIALIZE_FIELD("backendNodeId", m_backendNodeId),
    CRDTP_DESERIALIZE_FIELD("nodeName", m_nodeName),
    CRDTP_DESERIALIZE_FIELD("nodeType", m_nodeType),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(BackendNode)
    CRDTP_SERIALIZE_FIELD("nodeType", m_nodeType);
    CRDTP_SERIALIZE_FIELD("nodeName", m_nodeName);
    CRDTP_SERIALIZE_FIELD("backendNodeId", m_backendNodeId);
CRDTP_END_SERIALIZER();


namespace PseudoTypeEnum {
const char FirstLine[] = "first-line";
const char FirstLetter[] = "first-letter";
const char Before[] = "before";
const char After[] = "after";
const char Marker[] = "marker";
const char Backdrop[] = "backdrop";
const char Selection[] = "selection";
const char TargetText[] = "target-text";
const char SpellingError[] = "spelling-error";
const char GrammarError[] = "grammar-error";
const char Highlight[] = "highlight";
const char FirstLineInherited[] = "first-line-inherited";
const char Scrollbar[] = "scrollbar";
const char ScrollbarThumb[] = "scrollbar-thumb";
const char ScrollbarButton[] = "scrollbar-button";
const char ScrollbarTrack[] = "scrollbar-track";
const char ScrollbarTrackPiece[] = "scrollbar-track-piece";
const char ScrollbarCorner[] = "scrollbar-corner";
const char Resizer[] = "resizer";
const char InputListButton[] = "input-list-button";
const char PageTransition[] = "page-transition";
const char PageTransitionContainer[] = "page-transition-container";
const char PageTransitionImageWrapper[] = "page-transition-image-wrapper";
const char PageTransitionOutgoingImage[] = "page-transition-outgoing-image";
const char PageTransitionIncomingImage[] = "page-transition-incoming-image";
} // namespace PseudoTypeEnum


namespace ShadowRootTypeEnum {
const char UserAgent[] = "user-agent";
const char Open[] = "open";
const char Closed[] = "closed";
} // namespace ShadowRootTypeEnum


namespace CompatibilityModeEnum {
const char QuirksMode[] = "QuirksMode";
const char LimitedQuirksMode[] = "LimitedQuirksMode";
const char NoQuirksMode[] = "NoQuirksMode";
} // namespace CompatibilityModeEnum


CRDTP_BEGIN_DESERIALIZER(Node)
    CRDTP_DESERIALIZE_FIELD_OPT("assignedSlot", m_assignedSlot),
    CRDTP_DESERIALIZE_FIELD_OPT("attributes", m_attributes),
    CRDTP_DESERIALIZE_FIELD("backendNodeId", m_backendNodeId),
    CRDTP_DESERIALIZE_FIELD_OPT("baseURL", m_baseURL),
    CRDTP_DESERIALIZE_FIELD_OPT("childNodeCount", m_childNodeCount),
    CRDTP_DESERIALIZE_FIELD_OPT("children", m_children),
    CRDTP_DESERIALIZE_FIELD_OPT("compatibilityMode", m_compatibilityMode),
    CRDTP_DESERIALIZE_FIELD_OPT("contentDocument", m_contentDocument),
    CRDTP_DESERIALIZE_FIELD_OPT("distributedNodes", m_distributedNodes),
    CRDTP_DESERIALIZE_FIELD_OPT("documentURL", m_documentURL),
    CRDTP_DESERIALIZE_FIELD_OPT("frameId", m_frameId),
    CRDTP_DESERIALIZE_FIELD_OPT("importedDocument", m_importedDocument),
    CRDTP_DESERIALIZE_FIELD_OPT("internalSubset", m_internalSubset),
    CRDTP_DESERIALIZE_FIELD_OPT("isSVG", m_isSVG),
    CRDTP_DESERIALIZE_FIELD("localName", m_localName),
    CRDTP_DESERIALIZE_FIELD_OPT("name", m_name),
    CRDTP_DESERIALIZE_FIELD("nodeId", m_nodeId),
    CRDTP_DESERIALIZE_FIELD("nodeName", m_nodeName),
    CRDTP_DESERIALIZE_FIELD("nodeType", m_nodeType),
    CRDTP_DESERIALIZE_FIELD("nodeValue", m_nodeValue),
    CRDTP_DESERIALIZE_FIELD_OPT("parentId", m_parentId),
    CRDTP_DESERIALIZE_FIELD_OPT("pseudoElements", m_pseudoElements),
    CRDTP_DESERIALIZE_FIELD_OPT("pseudoIdentifier", m_pseudoIdentifier),
    CRDTP_DESERIALIZE_FIELD_OPT("pseudoType", m_pseudoType),
    CRDTP_DESERIALIZE_FIELD_OPT("publicId", m_publicId),
    CRDTP_DESERIALIZE_FIELD_OPT("shadowRootType", m_shadowRootType),
    CRDTP_DESERIALIZE_FIELD_OPT("shadowRoots", m_shadowRoots),
    CRDTP_DESERIALIZE_FIELD_OPT("systemId", m_systemId),
    CRDTP_DESERIALIZE_FIELD_OPT("templateContent", m_templateContent),
    CRDTP_DESERIALIZE_FIELD_OPT("value", m_value),
    CRDTP_DESERIALIZE_FIELD_OPT("xmlVersion", m_xmlVersion),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(Node)
    CRDTP_SERIALIZE_FIELD("nodeId", m_nodeId);
    CRDTP_SERIALIZE_FIELD("parentId", m_parentId);
    CRDTP_SERIALIZE_FIELD("backendNodeId", m_backendNodeId);
    CRDTP_SERIALIZE_FIELD("nodeType", m_nodeType);
    CRDTP_SERIALIZE_FIELD("nodeName", m_nodeName);
    CRDTP_SERIALIZE_FIELD("localName", m_localName);
    CRDTP_SERIALIZE_FIELD("nodeValue", m_nodeValue);
    CRDTP_SERIALIZE_FIELD("childNodeCount", m_childNodeCount);
    CRDTP_SERIALIZE_FIELD("children", m_children);
    CRDTP_SERIALIZE_FIELD("attributes", m_attributes);
    CRDTP_SERIALIZE_FIELD("documentURL", m_documentURL);
    CRDTP_SERIALIZE_FIELD("baseURL", m_baseURL);
    CRDTP_SERIALIZE_FIELD("publicId", m_publicId);
    CRDTP_SERIALIZE_FIELD("systemId", m_systemId);
    CRDTP_SERIALIZE_FIELD("internalSubset", m_internalSubset);
    CRDTP_SERIALIZE_FIELD("xmlVersion", m_xmlVersion);
    CRDTP_SERIALIZE_FIELD("name", m_name);
    CRDTP_SERIALIZE_FIELD("value", m_value);
    CRDTP_SERIALIZE_FIELD("pseudoType", m_pseudoType);
    CRDTP_SERIALIZE_FIELD("pseudoIdentifier", m_pseudoIdentifier);
    CRDTP_SERIALIZE_FIELD("shadowRootType", m_shadowRootType);
    CRDTP_SERIALIZE_FIELD("frameId", m_frameId);
    CRDTP_SERIALIZE_FIELD("contentDocument", m_contentDocument);
    CRDTP_SERIALIZE_FIELD("shadowRoots", m_shadowRoots);
    CRDTP_SERIALIZE_FIELD("templateContent", m_templateContent);
    CRDTP_SERIALIZE_FIELD("pseudoElements", m_pseudoElements);
    CRDTP_SERIALIZE_FIELD("importedDocument", m_importedDocument);
    CRDTP_SERIALIZE_FIELD("distributedNodes", m_distributedNodes);
    CRDTP_SERIALIZE_FIELD("isSVG", m_isSVG);
    CRDTP_SERIALIZE_FIELD("compatibilityMode", m_compatibilityMode);
    CRDTP_SERIALIZE_FIELD("assignedSlot", m_assignedSlot);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(RGBA)
    CRDTP_DESERIALIZE_FIELD_OPT("a", m_a),
    CRDTP_DESERIALIZE_FIELD("b", m_b),
    CRDTP_DESERIALIZE_FIELD("g", m_g),
    CRDTP_DESERIALIZE_FIELD("r", m_r),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(RGBA)
    CRDTP_SERIALIZE_FIELD("r", m_r);
    CRDTP_SERIALIZE_FIELD("g", m_g);
    CRDTP_SERIALIZE_FIELD("b", m_b);
    CRDTP_SERIALIZE_FIELD("a", m_a);
CRDTP_END_SERIALIZER();



CRDTP_BEGIN_DESERIALIZER(BoxModel)
    CRDTP_DESERIALIZE_FIELD("border", m_border),
    CRDTP_DESERIALIZE_FIELD("content", m_content),
    CRDTP_DESERIALIZE_FIELD("height", m_height),
    CRDTP_DESERIALIZE_FIELD("margin", m_margin),
    CRDTP_DESERIALIZE_FIELD("padding", m_padding),
    CRDTP_DESERIALIZE_FIELD_OPT("shapeOutside", m_shapeOutside),
    CRDTP_DESERIALIZE_FIELD("width", m_width),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(BoxModel)
    CRDTP_SERIALIZE_FIELD("content", m_content);
    CRDTP_SERIALIZE_FIELD("padding", m_padding);
    CRDTP_SERIALIZE_FIELD("border", m_border);
    CRDTP_SERIALIZE_FIELD("margin", m_margin);
    CRDTP_SERIALIZE_FIELD("width", m_width);
    CRDTP_SERIALIZE_FIELD("height", m_height);
    CRDTP_SERIALIZE_FIELD("shapeOutside", m_shapeOutside);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(ShapeOutsideInfo)
    CRDTP_DESERIALIZE_FIELD("bounds", m_bounds),
    CRDTP_DESERIALIZE_FIELD("marginShape", m_marginShape),
    CRDTP_DESERIALIZE_FIELD("shape", m_shape),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(ShapeOutsideInfo)
    CRDTP_SERIALIZE_FIELD("bounds", m_bounds);
    CRDTP_SERIALIZE_FIELD("shape", m_shape);
    CRDTP_SERIALIZE_FIELD("marginShape", m_marginShape);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(Rect)
    CRDTP_DESERIALIZE_FIELD("height", m_height),
    CRDTP_DESERIALIZE_FIELD("width", m_width),
    CRDTP_DESERIALIZE_FIELD("x", m_x),
    CRDTP_DESERIALIZE_FIELD("y", m_y),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(Rect)
    CRDTP_SERIALIZE_FIELD("x", m_x);
    CRDTP_SERIALIZE_FIELD("y", m_y);
    CRDTP_SERIALIZE_FIELD("width", m_width);
    CRDTP_SERIALIZE_FIELD("height", m_height);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(CSSComputedStyleProperty)
    CRDTP_DESERIALIZE_FIELD("name", m_name),
    CRDTP_DESERIALIZE_FIELD("value", m_value),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(CSSComputedStyleProperty)
    CRDTP_SERIALIZE_FIELD("name", m_name);
    CRDTP_SERIALIZE_FIELD("value", m_value);
CRDTP_END_SERIALIZER();


// ------------- Enum values from params.


namespace Enable {
namespace IncludeWhitespaceEnum {
const char* None = "none";
const char* All = "all";
} // namespace IncludeWhitespaceEnum
} // namespace Enable

// ------------- Frontend notifications.

void Frontend::attributeModified(int nodeId, const String& name, const String& value)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("nodeId"), nodeId);
    serializer.AddField(crdtp::MakeSpan("name"), name);
    serializer.AddField(crdtp::MakeSpan("value"), value);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("DOM.attributeModified", serializer.Finish()));
}

void Frontend::attributeRemoved(int nodeId, const String& name)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("nodeId"), nodeId);
    serializer.AddField(crdtp::MakeSpan("name"), name);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("DOM.attributeRemoved", serializer.Finish()));
}

void Frontend::characterDataModified(int nodeId, const String& characterData)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("nodeId"), nodeId);
    serializer.AddField(crdtp::MakeSpan("characterData"), characterData);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("DOM.characterDataModified", serializer.Finish()));
}

void Frontend::childNodeCountUpdated(int nodeId, int childNodeCount)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("nodeId"), nodeId);
    serializer.AddField(crdtp::MakeSpan("childNodeCount"), childNodeCount);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("DOM.childNodeCountUpdated", serializer.Finish()));
}

void Frontend::childNodeInserted(int parentNodeId, int previousNodeId, std::unique_ptr<protocol::DOM::Node> node)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("parentNodeId"), parentNodeId);
    serializer.AddField(crdtp::MakeSpan("previousNodeId"), previousNodeId);
    serializer.AddField(crdtp::MakeSpan("node"), node);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("DOM.childNodeInserted", serializer.Finish()));
}

void Frontend::childNodeRemoved(int parentNodeId, int nodeId)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("parentNodeId"), parentNodeId);
    serializer.AddField(crdtp::MakeSpan("nodeId"), nodeId);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("DOM.childNodeRemoved", serializer.Finish()));
}

void Frontend::distributedNodesUpdated(int insertionPointId, std::unique_ptr<protocol::Array<protocol::DOM::BackendNode>> distributedNodes)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("insertionPointId"), insertionPointId);
    serializer.AddField(crdtp::MakeSpan("distributedNodes"), distributedNodes);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("DOM.distributedNodesUpdated", serializer.Finish()));
}

void Frontend::documentUpdated()
{
    if (!frontend_channel_)
        return;
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("DOM.documentUpdated"));
}

void Frontend::inlineStyleInvalidated(std::unique_ptr<protocol::Array<int>> nodeIds)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("nodeIds"), nodeIds);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("DOM.inlineStyleInvalidated", serializer.Finish()));
}

void Frontend::pseudoElementAdded(int parentId, std::unique_ptr<protocol::DOM::Node> pseudoElement)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("parentId"), parentId);
    serializer.AddField(crdtp::MakeSpan("pseudoElement"), pseudoElement);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("DOM.pseudoElementAdded", serializer.Finish()));
}

void Frontend::topLayerElementsUpdated()
{
    if (!frontend_channel_)
        return;
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("DOM.topLayerElementsUpdated"));
}

void Frontend::pseudoElementRemoved(int parentId, int pseudoElementId)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("parentId"), parentId);
    serializer.AddField(crdtp::MakeSpan("pseudoElementId"), pseudoElementId);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("DOM.pseudoElementRemoved", serializer.Finish()));
}

void Frontend::setChildNodes(int parentId, std::unique_ptr<protocol::Array<protocol::DOM::Node>> nodes)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("parentId"), parentId);
    serializer.AddField(crdtp::MakeSpan("nodes"), nodes);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("DOM.setChildNodes", serializer.Finish()));
}

void Frontend::shadowRootPopped(int hostId, int rootId)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("hostId"), hostId);
    serializer.AddField(crdtp::MakeSpan("rootId"), rootId);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("DOM.shadowRootPopped", serializer.Finish()));
}

void Frontend::shadowRootPushed(int hostId, std::unique_ptr<protocol::DOM::Node> root)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("hostId"), hostId);
    serializer.AddField(crdtp::MakeSpan("root"), root);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("DOM.shadowRootPushed", serializer.Finish()));
}

void Frontend::flush()
{
    frontend_channel_->FlushProtocolNotifications();
}

void Frontend::sendRawNotification(std::unique_ptr<Serializable> notification)
{
    frontend_channel_->SendProtocolNotification(std::move(notification));
}

// --------------------- Dispatcher.

class DomainDispatcherImpl : public protocol::DomainDispatcher {
public:
    DomainDispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DomainDispatcher(frontendChannel)
        , m_backend(backend) {}
    ~DomainDispatcherImpl() override { }

    using CallHandler = void (DomainDispatcherImpl::*)(const crdtp::Dispatchable& dispatchable);

    std::function<void(const crdtp::Dispatchable&)> Dispatch(crdtp::span<uint8_t> command_name) override;

    void collectClassNamesFromSubtree(const crdtp::Dispatchable& dispatchable);
    void copyTo(const crdtp::Dispatchable& dispatchable);
    void describeNode(const crdtp::Dispatchable& dispatchable);
    void scrollIntoViewIfNeeded(const crdtp::Dispatchable& dispatchable);
    void disable(const crdtp::Dispatchable& dispatchable);
    void discardSearchResults(const crdtp::Dispatchable& dispatchable);
    void enable(const crdtp::Dispatchable& dispatchable);
    void focus(const crdtp::Dispatchable& dispatchable);
    void getAttributes(const crdtp::Dispatchable& dispatchable);
    void getBoxModel(const crdtp::Dispatchable& dispatchable);
    void getContentQuads(const crdtp::Dispatchable& dispatchable);
    void getDocument(const crdtp::Dispatchable& dispatchable);
    void getFlattenedDocument(const crdtp::Dispatchable& dispatchable);
    void getNodesForSubtreeByStyle(const crdtp::Dispatchable& dispatchable);
    void getNodeForLocation(const crdtp::Dispatchable& dispatchable);
    void getOuterHTML(const crdtp::Dispatchable& dispatchable);
    void getRelayoutBoundary(const crdtp::Dispatchable& dispatchable);
    void getSearchResults(const crdtp::Dispatchable& dispatchable);
    void markUndoableState(const crdtp::Dispatchable& dispatchable);
    void moveTo(const crdtp::Dispatchable& dispatchable);
    void performSearch(const crdtp::Dispatchable& dispatchable);
    void pushNodeByPathToFrontend(const crdtp::Dispatchable& dispatchable);
    void pushNodesByBackendIdsToFrontend(const crdtp::Dispatchable& dispatchable);
    void querySelector(const crdtp::Dispatchable& dispatchable);
    void querySelectorAll(const crdtp::Dispatchable& dispatchable);
    void getTopLayerElements(const crdtp::Dispatchable& dispatchable);
    void redo(const crdtp::Dispatchable& dispatchable);
    void removeAttribute(const crdtp::Dispatchable& dispatchable);
    void removeNode(const crdtp::Dispatchable& dispatchable);
    void requestChildNodes(const crdtp::Dispatchable& dispatchable);
    void requestNode(const crdtp::Dispatchable& dispatchable);
    void resolveNode(const crdtp::Dispatchable& dispatchable);
    void setAttributeValue(const crdtp::Dispatchable& dispatchable);
    void setAttributesAsText(const crdtp::Dispatchable& dispatchable);
    void setFileInputFiles(const crdtp::Dispatchable& dispatchable);
    void setNodeStackTracesEnabled(const crdtp::Dispatchable& dispatchable);
    void getNodeStackTraces(const crdtp::Dispatchable& dispatchable);
    void getFileInfo(const crdtp::Dispatchable& dispatchable);
    void setInspectedNode(const crdtp::Dispatchable& dispatchable);
    void setNodeName(const crdtp::Dispatchable& dispatchable);
    void setNodeValue(const crdtp::Dispatchable& dispatchable);
    void setOuterHTML(const crdtp::Dispatchable& dispatchable);
    void undo(const crdtp::Dispatchable& dispatchable);
    void getFrameOwner(const crdtp::Dispatchable& dispatchable);
    void getContainerForNode(const crdtp::Dispatchable& dispatchable);
    void getQueryingDescendantsForContainer(const crdtp::Dispatchable& dispatchable);
 protected:
    Backend* m_backend;
};

namespace {
// This helper method with a static map of command methods (instance methods
// of DomainDispatcherImpl declared just above) by their name is used immediately below,
// in the DomainDispatcherImpl::Dispatch method.
DomainDispatcherImpl::CallHandler CommandByName(crdtp::span<uint8_t> command_name) {
  static auto* commands = [](){
    auto* commands = new std::vector<std::pair<crdtp::span<uint8_t>,
                              DomainDispatcherImpl::CallHandler>>{
    {
          crdtp::SpanFrom("collectClassNamesFromSubtree"),
          &DomainDispatcherImpl::collectClassNamesFromSubtree
    },
    {
          crdtp::SpanFrom("copyTo"),
          &DomainDispatcherImpl::copyTo
    },
    {
          crdtp::SpanFrom("describeNode"),
          &DomainDispatcherImpl::describeNode
    },
    {
          crdtp::SpanFrom("disable"),
          &DomainDispatcherImpl::disable
    },
    {
          crdtp::SpanFrom("discardSearchResults"),
          &DomainDispatcherImpl::discardSearchResults
    },
    {
          crdtp::SpanFrom("enable"),
          &DomainDispatcherImpl::enable
    },
    {
          crdtp::SpanFrom("focus"),
          &DomainDispatcherImpl::focus
    },
    {
          crdtp::SpanFrom("getAttributes"),
          &DomainDispatcherImpl::getAttributes
    },
    {
          crdtp::SpanFrom("getBoxModel"),
          &DomainDispatcherImpl::getBoxModel
    },
    {
          crdtp::SpanFrom("getContainerForNode"),
          &DomainDispatcherImpl::getContainerForNode
    },
    {
          crdtp::SpanFrom("getContentQuads"),
          &DomainDispatcherImpl::getContentQuads
    },
    {
          crdtp::SpanFrom("getDocument"),
          &DomainDispatcherImpl::getDocument
    },
    {
          crdtp::SpanFrom("getFileInfo"),
          &DomainDispatcherImpl::getFileInfo
    },
    {
          crdtp::SpanFrom("getFlattenedDocument"),
          &DomainDispatcherImpl::getFlattenedDocument
    },
    {
          crdtp::SpanFrom("getFrameOwner"),
          &DomainDispatcherImpl::getFrameOwner
    },
    {
          crdtp::SpanFrom("getNodeForLocation"),
          &DomainDispatcherImpl::getNodeForLocation
    },
    {
          crdtp::SpanFrom("getNodeStackTraces"),
          &DomainDispatcherImpl::getNodeStackTraces
    },
    {
          crdtp::SpanFrom("getNodesForSubtreeByStyle"),
          &DomainDispatcherImpl::getNodesForSubtreeByStyle
    },
    {
          crdtp::SpanFrom("getOuterHTML"),
          &DomainDispatcherImpl::getOuterHTML
    },
    {
          crdtp::SpanFrom("getQueryingDescendantsForContainer"),
          &DomainDispatcherImpl::getQueryingDescendantsForContainer
    },
    {
          crdtp::SpanFrom("getRelayoutBoundary"),
          &DomainDispatcherImpl::getRelayoutBoundary
    },
    {
          crdtp::SpanFrom("getSearchResults"),
          &DomainDispatcherImpl::getSearchResults
    },
    {
          crdtp::SpanFrom("getTopLayerElements"),
          &DomainDispatcherImpl::getTopLayerElements
    },
    {
          crdtp::SpanFrom("markUndoableState"),
          &DomainDispatcherImpl::markUndoableState
    },
    {
          crdtp::SpanFrom("moveTo"),
          &DomainDispatcherImpl::moveTo
    },
    {
          crdtp::SpanFrom("performSearch"),
          &DomainDispatcherImpl::performSearch
    },
    {
          crdtp::SpanFrom("pushNodeByPathToFrontend"),
          &DomainDispatcherImpl::pushNodeByPathToFrontend
    },
    {
          crdtp::SpanFrom("pushNodesByBackendIdsToFrontend"),
          &DomainDispatcherImpl::pushNodesByBackendIdsToFrontend
    },
    {
          crdtp::SpanFrom("querySelector"),
          &DomainDispatcherImpl::querySelector
    },
    {
          crdtp::SpanFrom("querySelectorAll"),
          &DomainDispatcherImpl::querySelectorAll
    },
    {
          crdtp::SpanFrom("redo"),
          &DomainDispatcherImpl::redo
    },
    {
          crdtp::SpanFrom("removeAttribute"),
          &DomainDispatcherImpl::removeAttribute
    },
    {
          crdtp::SpanFrom("removeNode"),
          &DomainDispatcherImpl::removeNode
    },
    {
          crdtp::SpanFrom("requestChildNodes"),
          &DomainDispatcherImpl::requestChildNodes
    },
    {
          crdtp::SpanFrom("requestNode"),
          &DomainDispatcherImpl::requestNode
    },
    {
          crdtp::SpanFrom("resolveNode"),
          &DomainDispatcherImpl::resolveNode
    },
    {
          crdtp::SpanFrom("scrollIntoViewIfNeeded"),
          &DomainDispatcherImpl::scrollIntoViewIfNeeded
    },
    {
          crdtp::SpanFrom("setAttributeValue"),
          &DomainDispatcherImpl::setAttributeValue
    },
    {
          crdtp::SpanFrom("setAttributesAsText"),
          &DomainDispatcherImpl::setAttributesAsText
    },
    {
          crdtp::SpanFrom("setFileInputFiles"),
          &DomainDispatcherImpl::setFileInputFiles
    },
    {
          crdtp::SpanFrom("setInspectedNode"),
          &DomainDispatcherImpl::setInspectedNode
    },
    {
          crdtp::SpanFrom("setNodeName"),
          &DomainDispatcherImpl::setNodeName
    },
    {
          crdtp::SpanFrom("setNodeStackTracesEnabled"),
          &DomainDispatcherImpl::setNodeStackTracesEnabled
    },
    {
          crdtp::SpanFrom("setNodeValue"),
          &DomainDispatcherImpl::setNodeValue
    },
    {
          crdtp::SpanFrom("setOuterHTML"),
          &DomainDispatcherImpl::setOuterHTML
    },
    {
          crdtp::SpanFrom("undo"),
          &DomainDispatcherImpl::undo
    },
    };
    return commands;
  }();
  return crdtp::FindByFirst<DomainDispatcherImpl::CallHandler>(*commands, command_name, nullptr);
}
}  // namespace

std::function<void(const crdtp::Dispatchable&)> DomainDispatcherImpl::Dispatch(crdtp::span<uint8_t> command_name) {
  CallHandler handler = CommandByName(command_name);
  if (!handler) return nullptr;

  return [this, handler](const crdtp::Dispatchable& dispatchable) {
    (this->*handler)(dispatchable);
  };
}


namespace {

struct collectClassNamesFromSubtreeParams : public crdtp::DeserializableProtocolObject<collectClassNamesFromSubtreeParams> {
    int nodeId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(collectClassNamesFromSubtreeParams)
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::collectClassNamesFromSubtree(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    collectClassNamesFromSubtreeParams params;
    if (!collectClassNamesFromSubtreeParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::Array<String>> out_classNames;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->collectClassNamesFromSubtree(params.nodeId, &out_classNames);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.collectClassNamesFromSubtree"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("classNames"), out_classNames);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct copyToParams : public crdtp::DeserializableProtocolObject<copyToParams> {
    int nodeId;
    int targetNodeId;
    Maybe<int> insertBeforeNodeId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(copyToParams)
    CRDTP_DESERIALIZE_FIELD_OPT("insertBeforeNodeId", insertBeforeNodeId),
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
    CRDTP_DESERIALIZE_FIELD("targetNodeId", targetNodeId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::copyTo(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    copyToParams params;
    if (!copyToParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    int out_nodeId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->copyTo(params.nodeId, params.targetNodeId, std::move(params.insertBeforeNodeId), &out_nodeId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.copyTo"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("nodeId"), out_nodeId);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct describeNodeParams : public crdtp::DeserializableProtocolObject<describeNodeParams> {
    Maybe<int> nodeId;
    Maybe<int> backendNodeId;
    Maybe<String> objectId;
    Maybe<int> depth;
    Maybe<bool> pierce;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(describeNodeParams)
    CRDTP_DESERIALIZE_FIELD_OPT("backendNodeId", backendNodeId),
    CRDTP_DESERIALIZE_FIELD_OPT("depth", depth),
    CRDTP_DESERIALIZE_FIELD_OPT("nodeId", nodeId),
    CRDTP_DESERIALIZE_FIELD_OPT("objectId", objectId),
    CRDTP_DESERIALIZE_FIELD_OPT("pierce", pierce),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::describeNode(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    describeNodeParams params;
    if (!describeNodeParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::DOM::Node> out_node;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->describeNode(std::move(params.nodeId), std::move(params.backendNodeId), std::move(params.objectId), std::move(params.depth), std::move(params.pierce), &out_node);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.describeNode"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("node"), out_node);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct scrollIntoViewIfNeededParams : public crdtp::DeserializableProtocolObject<scrollIntoViewIfNeededParams> {
    Maybe<int> nodeId;
    Maybe<int> backendNodeId;
    Maybe<String> objectId;
    Maybe<protocol::DOM::Rect> rect;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(scrollIntoViewIfNeededParams)
    CRDTP_DESERIALIZE_FIELD_OPT("backendNodeId", backendNodeId),
    CRDTP_DESERIALIZE_FIELD_OPT("nodeId", nodeId),
    CRDTP_DESERIALIZE_FIELD_OPT("objectId", objectId),
    CRDTP_DESERIALIZE_FIELD_OPT("rect", rect),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::scrollIntoViewIfNeeded(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    scrollIntoViewIfNeededParams params;
    if (!scrollIntoViewIfNeededParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->scrollIntoViewIfNeeded(std::move(params.nodeId), std::move(params.backendNodeId), std::move(params.objectId), std::move(params.rect));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.scrollIntoViewIfNeeded"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::disable(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->disable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.disable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct discardSearchResultsParams : public crdtp::DeserializableProtocolObject<discardSearchResultsParams> {
    String searchId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(discardSearchResultsParams)
    CRDTP_DESERIALIZE_FIELD("searchId", searchId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::discardSearchResults(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    discardSearchResultsParams params;
    if (!discardSearchResultsParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->discardSearchResults(params.searchId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.discardSearchResults"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct enableParams : public crdtp::DeserializableProtocolObject<enableParams> {
    Maybe<String> includeWhitespace;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(enableParams)
    CRDTP_DESERIALIZE_FIELD_OPT("includeWhitespace", includeWhitespace),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::enable(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    enableParams params;
    if (!enableParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->enable(std::move(params.includeWhitespace));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.enable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct focusParams : public crdtp::DeserializableProtocolObject<focusParams> {
    Maybe<int> nodeId;
    Maybe<int> backendNodeId;
    Maybe<String> objectId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(focusParams)
    CRDTP_DESERIALIZE_FIELD_OPT("backendNodeId", backendNodeId),
    CRDTP_DESERIALIZE_FIELD_OPT("nodeId", nodeId),
    CRDTP_DESERIALIZE_FIELD_OPT("objectId", objectId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::focus(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    focusParams params;
    if (!focusParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->focus(std::move(params.nodeId), std::move(params.backendNodeId), std::move(params.objectId));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.focus"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct getAttributesParams : public crdtp::DeserializableProtocolObject<getAttributesParams> {
    int nodeId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getAttributesParams)
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getAttributes(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getAttributesParams params;
    if (!getAttributesParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::Array<String>> out_attributes;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getAttributes(params.nodeId, &out_attributes);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.getAttributes"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("attributes"), out_attributes);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getBoxModelParams : public crdtp::DeserializableProtocolObject<getBoxModelParams> {
    Maybe<int> nodeId;
    Maybe<int> backendNodeId;
    Maybe<String> objectId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getBoxModelParams)
    CRDTP_DESERIALIZE_FIELD_OPT("backendNodeId", backendNodeId),
    CRDTP_DESERIALIZE_FIELD_OPT("nodeId", nodeId),
    CRDTP_DESERIALIZE_FIELD_OPT("objectId", objectId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getBoxModel(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getBoxModelParams params;
    if (!getBoxModelParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::DOM::BoxModel> out_model;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getBoxModel(std::move(params.nodeId), std::move(params.backendNodeId), std::move(params.objectId), &out_model);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.getBoxModel"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("model"), out_model);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getContentQuadsParams : public crdtp::DeserializableProtocolObject<getContentQuadsParams> {
    Maybe<int> nodeId;
    Maybe<int> backendNodeId;
    Maybe<String> objectId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getContentQuadsParams)
    CRDTP_DESERIALIZE_FIELD_OPT("backendNodeId", backendNodeId),
    CRDTP_DESERIALIZE_FIELD_OPT("nodeId", nodeId),
    CRDTP_DESERIALIZE_FIELD_OPT("objectId", objectId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getContentQuads(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getContentQuadsParams params;
    if (!getContentQuadsParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::Array<double>>> out_quads;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getContentQuads(std::move(params.nodeId), std::move(params.backendNodeId), std::move(params.objectId), &out_quads);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.getContentQuads"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("quads"), out_quads);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getDocumentParams : public crdtp::DeserializableProtocolObject<getDocumentParams> {
    Maybe<int> depth;
    Maybe<bool> pierce;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getDocumentParams)
    CRDTP_DESERIALIZE_FIELD_OPT("depth", depth),
    CRDTP_DESERIALIZE_FIELD_OPT("pierce", pierce),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getDocument(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getDocumentParams params;
    if (!getDocumentParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::DOM::Node> out_root;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getDocument(std::move(params.depth), std::move(params.pierce), &out_root);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.getDocument"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("root"), out_root);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getFlattenedDocumentParams : public crdtp::DeserializableProtocolObject<getFlattenedDocumentParams> {
    Maybe<int> depth;
    Maybe<bool> pierce;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getFlattenedDocumentParams)
    CRDTP_DESERIALIZE_FIELD_OPT("depth", depth),
    CRDTP_DESERIALIZE_FIELD_OPT("pierce", pierce),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getFlattenedDocument(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getFlattenedDocumentParams params;
    if (!getFlattenedDocumentParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::DOM::Node>> out_nodes;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getFlattenedDocument(std::move(params.depth), std::move(params.pierce), &out_nodes);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.getFlattenedDocument"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("nodes"), out_nodes);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getNodesForSubtreeByStyleParams : public crdtp::DeserializableProtocolObject<getNodesForSubtreeByStyleParams> {
    int nodeId;
    std::unique_ptr<protocol::Array<protocol::DOM::CSSComputedStyleProperty>> computedStyles;
    Maybe<bool> pierce;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getNodesForSubtreeByStyleParams)
    CRDTP_DESERIALIZE_FIELD("computedStyles", computedStyles),
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
    CRDTP_DESERIALIZE_FIELD_OPT("pierce", pierce),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getNodesForSubtreeByStyle(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getNodesForSubtreeByStyleParams params;
    if (!getNodesForSubtreeByStyleParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::Array<int>> out_nodeIds;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getNodesForSubtreeByStyle(params.nodeId, std::move(params.computedStyles), std::move(params.pierce), &out_nodeIds);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.getNodesForSubtreeByStyle"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("nodeIds"), out_nodeIds);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getNodeForLocationParams : public crdtp::DeserializableProtocolObject<getNodeForLocationParams> {
    int x;
    int y;
    Maybe<bool> includeUserAgentShadowDOM;
    Maybe<bool> ignorePointerEventsNone;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getNodeForLocationParams)
    CRDTP_DESERIALIZE_FIELD_OPT("ignorePointerEventsNone", ignorePointerEventsNone),
    CRDTP_DESERIALIZE_FIELD_OPT("includeUserAgentShadowDOM", includeUserAgentShadowDOM),
    CRDTP_DESERIALIZE_FIELD("x", x),
    CRDTP_DESERIALIZE_FIELD("y", y),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getNodeForLocation(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getNodeForLocationParams params;
    if (!getNodeForLocationParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    int out_backendNodeId;
    String out_frameId;
    Maybe<int> out_nodeId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getNodeForLocation(params.x, params.y, std::move(params.includeUserAgentShadowDOM), std::move(params.ignorePointerEventsNone), &out_backendNodeId, &out_frameId, &out_nodeId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.getNodeForLocation"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("backendNodeId"), out_backendNodeId);
          serializer.AddField(crdtp::MakeSpan("frameId"), out_frameId);
          serializer.AddField(crdtp::MakeSpan("nodeId"), out_nodeId);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getOuterHTMLParams : public crdtp::DeserializableProtocolObject<getOuterHTMLParams> {
    Maybe<int> nodeId;
    Maybe<int> backendNodeId;
    Maybe<String> objectId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getOuterHTMLParams)
    CRDTP_DESERIALIZE_FIELD_OPT("backendNodeId", backendNodeId),
    CRDTP_DESERIALIZE_FIELD_OPT("nodeId", nodeId),
    CRDTP_DESERIALIZE_FIELD_OPT("objectId", objectId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getOuterHTML(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getOuterHTMLParams params;
    if (!getOuterHTMLParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    String out_outerHTML;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getOuterHTML(std::move(params.nodeId), std::move(params.backendNodeId), std::move(params.objectId), &out_outerHTML);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.getOuterHTML"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("outerHTML"), out_outerHTML);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getRelayoutBoundaryParams : public crdtp::DeserializableProtocolObject<getRelayoutBoundaryParams> {
    int nodeId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getRelayoutBoundaryParams)
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getRelayoutBoundary(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getRelayoutBoundaryParams params;
    if (!getRelayoutBoundaryParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    int out_nodeId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getRelayoutBoundary(params.nodeId, &out_nodeId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.getRelayoutBoundary"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("nodeId"), out_nodeId);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getSearchResultsParams : public crdtp::DeserializableProtocolObject<getSearchResultsParams> {
    String searchId;
    int fromIndex;
    int toIndex;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getSearchResultsParams)
    CRDTP_DESERIALIZE_FIELD("fromIndex", fromIndex),
    CRDTP_DESERIALIZE_FIELD("searchId", searchId),
    CRDTP_DESERIALIZE_FIELD("toIndex", toIndex),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getSearchResults(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getSearchResultsParams params;
    if (!getSearchResultsParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::Array<int>> out_nodeIds;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getSearchResults(params.searchId, params.fromIndex, params.toIndex, &out_nodeIds);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.getSearchResults"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("nodeIds"), out_nodeIds);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::markUndoableState(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->markUndoableState();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.markUndoableState"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct moveToParams : public crdtp::DeserializableProtocolObject<moveToParams> {
    int nodeId;
    int targetNodeId;
    Maybe<int> insertBeforeNodeId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(moveToParams)
    CRDTP_DESERIALIZE_FIELD_OPT("insertBeforeNodeId", insertBeforeNodeId),
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
    CRDTP_DESERIALIZE_FIELD("targetNodeId", targetNodeId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::moveTo(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    moveToParams params;
    if (!moveToParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    int out_nodeId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->moveTo(params.nodeId, params.targetNodeId, std::move(params.insertBeforeNodeId), &out_nodeId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.moveTo"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("nodeId"), out_nodeId);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct performSearchParams : public crdtp::DeserializableProtocolObject<performSearchParams> {
    String query;
    Maybe<bool> includeUserAgentShadowDOM;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(performSearchParams)
    CRDTP_DESERIALIZE_FIELD_OPT("includeUserAgentShadowDOM", includeUserAgentShadowDOM),
    CRDTP_DESERIALIZE_FIELD("query", query),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::performSearch(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    performSearchParams params;
    if (!performSearchParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    String out_searchId;
    int out_resultCount;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->performSearch(params.query, std::move(params.includeUserAgentShadowDOM), &out_searchId, &out_resultCount);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.performSearch"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("searchId"), out_searchId);
          serializer.AddField(crdtp::MakeSpan("resultCount"), out_resultCount);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct pushNodeByPathToFrontendParams : public crdtp::DeserializableProtocolObject<pushNodeByPathToFrontendParams> {
    String path;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(pushNodeByPathToFrontendParams)
    CRDTP_DESERIALIZE_FIELD("path", path),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::pushNodeByPathToFrontend(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    pushNodeByPathToFrontendParams params;
    if (!pushNodeByPathToFrontendParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    int out_nodeId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->pushNodeByPathToFrontend(params.path, &out_nodeId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.pushNodeByPathToFrontend"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("nodeId"), out_nodeId);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct pushNodesByBackendIdsToFrontendParams : public crdtp::DeserializableProtocolObject<pushNodesByBackendIdsToFrontendParams> {
    std::unique_ptr<protocol::Array<int>> backendNodeIds;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(pushNodesByBackendIdsToFrontendParams)
    CRDTP_DESERIALIZE_FIELD("backendNodeIds", backendNodeIds),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::pushNodesByBackendIdsToFrontend(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    pushNodesByBackendIdsToFrontendParams params;
    if (!pushNodesByBackendIdsToFrontendParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::Array<int>> out_nodeIds;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->pushNodesByBackendIdsToFrontend(std::move(params.backendNodeIds), &out_nodeIds);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.pushNodesByBackendIdsToFrontend"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("nodeIds"), out_nodeIds);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct querySelectorParams : public crdtp::DeserializableProtocolObject<querySelectorParams> {
    int nodeId;
    String selector;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(querySelectorParams)
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
    CRDTP_DESERIALIZE_FIELD("selector", selector),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::querySelector(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    querySelectorParams params;
    if (!querySelectorParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    int out_nodeId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->querySelector(params.nodeId, params.selector, &out_nodeId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.querySelector"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("nodeId"), out_nodeId);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct querySelectorAllParams : public crdtp::DeserializableProtocolObject<querySelectorAllParams> {
    int nodeId;
    String selector;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(querySelectorAllParams)
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
    CRDTP_DESERIALIZE_FIELD("selector", selector),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::querySelectorAll(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    querySelectorAllParams params;
    if (!querySelectorAllParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::Array<int>> out_nodeIds;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->querySelectorAll(params.nodeId, params.selector, &out_nodeIds);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.querySelectorAll"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("nodeIds"), out_nodeIds);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::getTopLayerElements(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    // Declare output parameters.
    std::unique_ptr<protocol::Array<int>> out_nodeIds;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getTopLayerElements(&out_nodeIds);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.getTopLayerElements"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("nodeIds"), out_nodeIds);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::redo(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->redo();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.redo"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct removeAttributeParams : public crdtp::DeserializableProtocolObject<removeAttributeParams> {
    int nodeId;
    String name;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(removeAttributeParams)
    CRDTP_DESERIALIZE_FIELD("name", name),
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::removeAttribute(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    removeAttributeParams params;
    if (!removeAttributeParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->removeAttribute(params.nodeId, params.name);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.removeAttribute"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct removeNodeParams : public crdtp::DeserializableProtocolObject<removeNodeParams> {
    int nodeId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(removeNodeParams)
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::removeNode(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    removeNodeParams params;
    if (!removeNodeParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->removeNode(params.nodeId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.removeNode"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct requestChildNodesParams : public crdtp::DeserializableProtocolObject<requestChildNodesParams> {
    int nodeId;
    Maybe<int> depth;
    Maybe<bool> pierce;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(requestChildNodesParams)
    CRDTP_DESERIALIZE_FIELD_OPT("depth", depth),
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
    CRDTP_DESERIALIZE_FIELD_OPT("pierce", pierce),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::requestChildNodes(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    requestChildNodesParams params;
    if (!requestChildNodesParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->requestChildNodes(params.nodeId, std::move(params.depth), std::move(params.pierce));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.requestChildNodes"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct requestNodeParams : public crdtp::DeserializableProtocolObject<requestNodeParams> {
    String objectId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(requestNodeParams)
    CRDTP_DESERIALIZE_FIELD("objectId", objectId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::requestNode(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    requestNodeParams params;
    if (!requestNodeParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    int out_nodeId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->requestNode(params.objectId, &out_nodeId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.requestNode"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("nodeId"), out_nodeId);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct resolveNodeParams : public crdtp::DeserializableProtocolObject<resolveNodeParams> {
    Maybe<int> nodeId;
    Maybe<int> backendNodeId;
    Maybe<String> objectGroup;
    Maybe<int> executionContextId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(resolveNodeParams)
    CRDTP_DESERIALIZE_FIELD_OPT("backendNodeId", backendNodeId),
    CRDTP_DESERIALIZE_FIELD_OPT("executionContextId", executionContextId),
    CRDTP_DESERIALIZE_FIELD_OPT("nodeId", nodeId),
    CRDTP_DESERIALIZE_FIELD_OPT("objectGroup", objectGroup),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::resolveNode(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    resolveNodeParams params;
    if (!resolveNodeParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<v8_inspector::protocol::Runtime::API::RemoteObject> out_object;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->resolveNode(std::move(params.nodeId), std::move(params.backendNodeId), std::move(params.objectGroup), std::move(params.executionContextId), &out_object);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.resolveNode"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("object"), out_object);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct setAttributeValueParams : public crdtp::DeserializableProtocolObject<setAttributeValueParams> {
    int nodeId;
    String name;
    String value;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setAttributeValueParams)
    CRDTP_DESERIALIZE_FIELD("name", name),
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
    CRDTP_DESERIALIZE_FIELD("value", value),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setAttributeValue(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setAttributeValueParams params;
    if (!setAttributeValueParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setAttributeValue(params.nodeId, params.name, params.value);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.setAttributeValue"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setAttributesAsTextParams : public crdtp::DeserializableProtocolObject<setAttributesAsTextParams> {
    int nodeId;
    String text;
    Maybe<String> name;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setAttributesAsTextParams)
    CRDTP_DESERIALIZE_FIELD_OPT("name", name),
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
    CRDTP_DESERIALIZE_FIELD("text", text),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setAttributesAsText(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setAttributesAsTextParams params;
    if (!setAttributesAsTextParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setAttributesAsText(params.nodeId, params.text, std::move(params.name));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.setAttributesAsText"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setFileInputFilesParams : public crdtp::DeserializableProtocolObject<setFileInputFilesParams> {
    std::unique_ptr<protocol::Array<String>> files;
    Maybe<int> nodeId;
    Maybe<int> backendNodeId;
    Maybe<String> objectId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setFileInputFilesParams)
    CRDTP_DESERIALIZE_FIELD_OPT("backendNodeId", backendNodeId),
    CRDTP_DESERIALIZE_FIELD("files", files),
    CRDTP_DESERIALIZE_FIELD_OPT("nodeId", nodeId),
    CRDTP_DESERIALIZE_FIELD_OPT("objectId", objectId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setFileInputFiles(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setFileInputFilesParams params;
    if (!setFileInputFilesParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setFileInputFiles(std::move(params.files), std::move(params.nodeId), std::move(params.backendNodeId), std::move(params.objectId));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.setFileInputFiles"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setNodeStackTracesEnabledParams : public crdtp::DeserializableProtocolObject<setNodeStackTracesEnabledParams> {
    bool enable;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setNodeStackTracesEnabledParams)
    CRDTP_DESERIALIZE_FIELD("enable", enable),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setNodeStackTracesEnabled(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setNodeStackTracesEnabledParams params;
    if (!setNodeStackTracesEnabledParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setNodeStackTracesEnabled(params.enable);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.setNodeStackTracesEnabled"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct getNodeStackTracesParams : public crdtp::DeserializableProtocolObject<getNodeStackTracesParams> {
    int nodeId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getNodeStackTracesParams)
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getNodeStackTraces(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getNodeStackTracesParams params;
    if (!getNodeStackTracesParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    Maybe<v8_inspector::protocol::Runtime::API::StackTrace> out_creation;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getNodeStackTraces(params.nodeId, &out_creation);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.getNodeStackTraces"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("creation"), out_creation);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getFileInfoParams : public crdtp::DeserializableProtocolObject<getFileInfoParams> {
    String objectId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getFileInfoParams)
    CRDTP_DESERIALIZE_FIELD("objectId", objectId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getFileInfo(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getFileInfoParams params;
    if (!getFileInfoParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    String out_path;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getFileInfo(params.objectId, &out_path);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.getFileInfo"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("path"), out_path);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct setInspectedNodeParams : public crdtp::DeserializableProtocolObject<setInspectedNodeParams> {
    int nodeId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setInspectedNodeParams)
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setInspectedNode(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setInspectedNodeParams params;
    if (!setInspectedNodeParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setInspectedNode(params.nodeId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.setInspectedNode"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setNodeNameParams : public crdtp::DeserializableProtocolObject<setNodeNameParams> {
    int nodeId;
    String name;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setNodeNameParams)
    CRDTP_DESERIALIZE_FIELD("name", name),
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setNodeName(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setNodeNameParams params;
    if (!setNodeNameParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    int out_nodeId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setNodeName(params.nodeId, params.name, &out_nodeId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.setNodeName"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("nodeId"), out_nodeId);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct setNodeValueParams : public crdtp::DeserializableProtocolObject<setNodeValueParams> {
    int nodeId;
    String value;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setNodeValueParams)
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
    CRDTP_DESERIALIZE_FIELD("value", value),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setNodeValue(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setNodeValueParams params;
    if (!setNodeValueParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setNodeValue(params.nodeId, params.value);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.setNodeValue"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setOuterHTMLParams : public crdtp::DeserializableProtocolObject<setOuterHTMLParams> {
    int nodeId;
    String outerHTML;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setOuterHTMLParams)
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
    CRDTP_DESERIALIZE_FIELD("outerHTML", outerHTML),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setOuterHTML(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setOuterHTMLParams params;
    if (!setOuterHTMLParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setOuterHTML(params.nodeId, params.outerHTML);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.setOuterHTML"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::undo(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->undo();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.undo"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct getFrameOwnerParams : public crdtp::DeserializableProtocolObject<getFrameOwnerParams> {
    String frameId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getFrameOwnerParams)
    CRDTP_DESERIALIZE_FIELD("frameId", frameId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getFrameOwner(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getFrameOwnerParams params;
    if (!getFrameOwnerParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    int out_backendNodeId;
    Maybe<int> out_nodeId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getFrameOwner(params.frameId, &out_backendNodeId, &out_nodeId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.getFrameOwner"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("backendNodeId"), out_backendNodeId);
          serializer.AddField(crdtp::MakeSpan("nodeId"), out_nodeId);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getContainerForNodeParams : public crdtp::DeserializableProtocolObject<getContainerForNodeParams> {
    int nodeId;
    Maybe<String> containerName;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getContainerForNodeParams)
    CRDTP_DESERIALIZE_FIELD_OPT("containerName", containerName),
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getContainerForNode(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getContainerForNodeParams params;
    if (!getContainerForNodeParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    Maybe<int> out_nodeId;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getContainerForNode(params.nodeId, std::move(params.containerName), &out_nodeId);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.getContainerForNode"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("nodeId"), out_nodeId);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getQueryingDescendantsForContainerParams : public crdtp::DeserializableProtocolObject<getQueryingDescendantsForContainerParams> {
    int nodeId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getQueryingDescendantsForContainerParams)
    CRDTP_DESERIALIZE_FIELD("nodeId", nodeId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getQueryingDescendantsForContainer(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getQueryingDescendantsForContainerParams params;
    if (!getQueryingDescendantsForContainerParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::Array<int>> out_nodeIds;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getQueryingDescendantsForContainer(params.nodeId, &out_nodeIds);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("DOM.getQueryingDescendantsForContainer"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("nodeIds"), out_nodeIds);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {
// This helper method (with a static map of redirects) is used from Dispatcher::wire
// immediately below.
const std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>& SortedRedirects() {
  static auto* redirects = [](){
    auto* redirects = new std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>{
          { crdtp::SpanFrom("DOM.hideHighlight"), crdtp::SpanFrom("Overlay.hideHighlight") },
          { crdtp::SpanFrom("DOM.highlightNode"), crdtp::SpanFrom("Overlay.highlightNode") },
          { crdtp::SpanFrom("DOM.highlightRect"), crdtp::SpanFrom("Overlay.highlightRect") },
    };
    return redirects;
  }();
  return *redirects;
}
}  // namespace

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    auto dispatcher = std::make_unique<DomainDispatcherImpl>(uber->channel(), backend);
    uber->WireBackend(crdtp::SpanFrom("DOM"), SortedRedirects(), std::move(dispatcher));
}

} // DOM
} // namespace blink
} // namespace protocol
