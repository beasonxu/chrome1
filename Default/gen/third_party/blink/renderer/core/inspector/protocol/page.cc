// This file is generated by TypeBuilder_cpp.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "third_party/blink/renderer/core/inspector/protocol/page.h"

#include "third_party/blink/renderer/core/inspector/protocol/protocol.h"

#include "third_party/inspector_protocol/crdtp/cbor.h"
#include "third_party/inspector_protocol/crdtp/find_by_first.h"
#include "third_party/inspector_protocol/crdtp/span.h"

namespace blink {
namespace protocol {
namespace Page {

using crdtp::DeserializerState;
using crdtp::ProtocolTypeTraits;

// ------------- Enum values from types.

const char Metainfo::domainName[] = "Page";
const char Metainfo::commandPrefix[] = "Page.";
const char Metainfo::version[] = "1.3";


namespace AdFrameTypeEnum {
const char None[] = "none";
const char Child[] = "child";
const char Root[] = "root";
} // namespace AdFrameTypeEnum


namespace AdFrameExplanationEnum {
const char ParentIsAd[] = "ParentIsAd";
const char CreatedByAdScript[] = "CreatedByAdScript";
const char MatchedBlockingRule[] = "MatchedBlockingRule";
} // namespace AdFrameExplanationEnum


CRDTP_BEGIN_DESERIALIZER(AdFrameStatus)
    CRDTP_DESERIALIZE_FIELD("adFrameType", m_adFrameType),
    CRDTP_DESERIALIZE_FIELD_OPT("explanations", m_explanations),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(AdFrameStatus)
    CRDTP_SERIALIZE_FIELD("adFrameType", m_adFrameType);
    CRDTP_SERIALIZE_FIELD("explanations", m_explanations);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(AdScriptId)
    CRDTP_DESERIALIZE_FIELD("debuggerId", m_debuggerId),
    CRDTP_DESERIALIZE_FIELD("scriptId", m_scriptId),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(AdScriptId)
    CRDTP_SERIALIZE_FIELD("scriptId", m_scriptId);
    CRDTP_SERIALIZE_FIELD("debuggerId", m_debuggerId);
CRDTP_END_SERIALIZER();


namespace SecureContextTypeEnum {
const char Secure[] = "Secure";
const char SecureLocalhost[] = "SecureLocalhost";
const char InsecureScheme[] = "InsecureScheme";
const char InsecureAncestor[] = "InsecureAncestor";
} // namespace SecureContextTypeEnum


namespace CrossOriginIsolatedContextTypeEnum {
const char Isolated[] = "Isolated";
const char NotIsolated[] = "NotIsolated";
const char NotIsolatedFeatureDisabled[] = "NotIsolatedFeatureDisabled";
} // namespace CrossOriginIsolatedContextTypeEnum


namespace GatedAPIFeaturesEnum {
const char SharedArrayBuffers[] = "SharedArrayBuffers";
const char SharedArrayBuffersTransferAllowed[] = "SharedArrayBuffersTransferAllowed";
const char PerformanceMeasureMemory[] = "PerformanceMeasureMemory";
const char PerformanceProfile[] = "PerformanceProfile";
} // namespace GatedAPIFeaturesEnum


namespace PermissionsPolicyFeatureEnum {
const char Accelerometer[] = "accelerometer";
const char AmbientLightSensor[] = "ambient-light-sensor";
const char AttributionReporting[] = "attribution-reporting";
const char Autoplay[] = "autoplay";
const char Bluetooth[] = "bluetooth";
const char BrowsingTopics[] = "browsing-topics";
const char Camera[] = "camera";
const char ChDpr[] = "ch-dpr";
const char ChDeviceMemory[] = "ch-device-memory";
const char ChDownlink[] = "ch-downlink";
const char ChEct[] = "ch-ect";
const char ChPrefersColorScheme[] = "ch-prefers-color-scheme";
const char ChRtt[] = "ch-rtt";
const char ChSaveData[] = "ch-save-data";
const char ChUa[] = "ch-ua";
const char ChUaArch[] = "ch-ua-arch";
const char ChUaBitness[] = "ch-ua-bitness";
const char ChUaPlatform[] = "ch-ua-platform";
const char ChUaModel[] = "ch-ua-model";
const char ChUaMobile[] = "ch-ua-mobile";
const char ChUaFull[] = "ch-ua-full";
const char ChUaFullVersion[] = "ch-ua-full-version";
const char ChUaFullVersionList[] = "ch-ua-full-version-list";
const char ChUaPlatformVersion[] = "ch-ua-platform-version";
const char ChUaReduced[] = "ch-ua-reduced";
const char ChUaWow64[] = "ch-ua-wow64";
const char ChViewportHeight[] = "ch-viewport-height";
const char ChViewportWidth[] = "ch-viewport-width";
const char ChWidth[] = "ch-width";
const char ClipboardRead[] = "clipboard-read";
const char ClipboardWrite[] = "clipboard-write";
const char CrossOriginIsolated[] = "cross-origin-isolated";
const char DirectSockets[] = "direct-sockets";
const char DisplayCapture[] = "display-capture";
const char DocumentDomain[] = "document-domain";
const char EncryptedMedia[] = "encrypted-media";
const char ExecutionWhileOutOfViewport[] = "execution-while-out-of-viewport";
const char ExecutionWhileNotRendered[] = "execution-while-not-rendered";
const char FederatedCredentials[] = "federated-credentials";
const char FocusWithoutUserActivation[] = "focus-without-user-activation";
const char Fullscreen[] = "fullscreen";
const char Frobulate[] = "frobulate";
const char Gamepad[] = "gamepad";
const char Geolocation[] = "geolocation";
const char Gyroscope[] = "gyroscope";
const char Hid[] = "hid";
const char IdleDetection[] = "idle-detection";
const char InterestCohort[] = "interest-cohort";
const char JoinAdInterestGroup[] = "join-ad-interest-group";
const char KeyboardMap[] = "keyboard-map";
const char LocalFonts[] = "local-fonts";
const char Magnetometer[] = "magnetometer";
const char Microphone[] = "microphone";
const char Midi[] = "midi";
const char OtpCredentials[] = "otp-credentials";
const char Payment[] = "payment";
const char PictureInPicture[] = "picture-in-picture";
const char PublickeyCredentialsGet[] = "publickey-credentials-get";
const char RunAdAuction[] = "run-ad-auction";
const char ScreenWakeLock[] = "screen-wake-lock";
const char Serial[] = "serial";
const char SharedAutofill[] = "shared-autofill";
const char SharedStorage[] = "shared-storage";
const char StorageAccessApi[] = "storage-access-api";
const char SyncXhr[] = "sync-xhr";
const char TrustTokenRedemption[] = "trust-token-redemption";
const char Unload[] = "unload";
const char Usb[] = "usb";
const char VerticalScroll[] = "vertical-scroll";
const char WebShare[] = "web-share";
const char WindowPlacement[] = "window-placement";
const char XrSpatialTracking[] = "xr-spatial-tracking";
} // namespace PermissionsPolicyFeatureEnum


namespace PermissionsPolicyBlockReasonEnum {
const char Header[] = "Header";
const char IframeAttribute[] = "IframeAttribute";
const char InFencedFrameTree[] = "InFencedFrameTree";
const char InIsolatedApp[] = "InIsolatedApp";
} // namespace PermissionsPolicyBlockReasonEnum


CRDTP_BEGIN_DESERIALIZER(PermissionsPolicyBlockLocator)
    CRDTP_DESERIALIZE_FIELD("blockReason", m_blockReason),
    CRDTP_DESERIALIZE_FIELD("frameId", m_frameId),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(PermissionsPolicyBlockLocator)
    CRDTP_SERIALIZE_FIELD("frameId", m_frameId);
    CRDTP_SERIALIZE_FIELD("blockReason", m_blockReason);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(PermissionsPolicyFeatureState)
    CRDTP_DESERIALIZE_FIELD("allowed", m_allowed),
    CRDTP_DESERIALIZE_FIELD("feature", m_feature),
    CRDTP_DESERIALIZE_FIELD_OPT("locator", m_locator),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(PermissionsPolicyFeatureState)
    CRDTP_SERIALIZE_FIELD("feature", m_feature);
    CRDTP_SERIALIZE_FIELD("allowed", m_allowed);
    CRDTP_SERIALIZE_FIELD("locator", m_locator);
CRDTP_END_SERIALIZER();


namespace OriginTrialTokenStatusEnum {
const char Success[] = "Success";
const char NotSupported[] = "NotSupported";
const char Insecure[] = "Insecure";
const char Expired[] = "Expired";
const char WrongOrigin[] = "WrongOrigin";
const char InvalidSignature[] = "InvalidSignature";
const char Malformed[] = "Malformed";
const char WrongVersion[] = "WrongVersion";
const char FeatureDisabled[] = "FeatureDisabled";
const char TokenDisabled[] = "TokenDisabled";
const char FeatureDisabledForUser[] = "FeatureDisabledForUser";
const char UnknownTrial[] = "UnknownTrial";
} // namespace OriginTrialTokenStatusEnum


namespace OriginTrialStatusEnum {
const char Enabled[] = "Enabled";
const char ValidTokenNotProvided[] = "ValidTokenNotProvided";
const char OSNotSupported[] = "OSNotSupported";
const char TrialNotAllowed[] = "TrialNotAllowed";
} // namespace OriginTrialStatusEnum


namespace OriginTrialUsageRestrictionEnum {
const char None[] = "None";
const char Subset[] = "Subset";
} // namespace OriginTrialUsageRestrictionEnum


CRDTP_BEGIN_DESERIALIZER(OriginTrialToken)
    CRDTP_DESERIALIZE_FIELD("expiryTime", m_expiryTime),
    CRDTP_DESERIALIZE_FIELD("isThirdParty", m_isThirdParty),
    CRDTP_DESERIALIZE_FIELD("matchSubDomains", m_matchSubDomains),
    CRDTP_DESERIALIZE_FIELD("origin", m_origin),
    CRDTP_DESERIALIZE_FIELD("trialName", m_trialName),
    CRDTP_DESERIALIZE_FIELD("usageRestriction", m_usageRestriction),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(OriginTrialToken)
    CRDTP_SERIALIZE_FIELD("origin", m_origin);
    CRDTP_SERIALIZE_FIELD("matchSubDomains", m_matchSubDomains);
    CRDTP_SERIALIZE_FIELD("trialName", m_trialName);
    CRDTP_SERIALIZE_FIELD("expiryTime", m_expiryTime);
    CRDTP_SERIALIZE_FIELD("isThirdParty", m_isThirdParty);
    CRDTP_SERIALIZE_FIELD("usageRestriction", m_usageRestriction);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(OriginTrialTokenWithStatus)
    CRDTP_DESERIALIZE_FIELD_OPT("parsedToken", m_parsedToken),
    CRDTP_DESERIALIZE_FIELD("rawTokenText", m_rawTokenText),
    CRDTP_DESERIALIZE_FIELD("status", m_status),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(OriginTrialTokenWithStatus)
    CRDTP_SERIALIZE_FIELD("rawTokenText", m_rawTokenText);
    CRDTP_SERIALIZE_FIELD("parsedToken", m_parsedToken);
    CRDTP_SERIALIZE_FIELD("status", m_status);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(OriginTrial)
    CRDTP_DESERIALIZE_FIELD("status", m_status),
    CRDTP_DESERIALIZE_FIELD("tokensWithStatus", m_tokensWithStatus),
    CRDTP_DESERIALIZE_FIELD("trialName", m_trialName),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(OriginTrial)
    CRDTP_SERIALIZE_FIELD("trialName", m_trialName);
    CRDTP_SERIALIZE_FIELD("status", m_status);
    CRDTP_SERIALIZE_FIELD("tokensWithStatus", m_tokensWithStatus);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(Frame)
    CRDTP_DESERIALIZE_FIELD_OPT("adFrameStatus", m_adFrameStatus),
    CRDTP_DESERIALIZE_FIELD("crossOriginIsolatedContextType", m_crossOriginIsolatedContextType),
    CRDTP_DESERIALIZE_FIELD("domainAndRegistry", m_domainAndRegistry),
    CRDTP_DESERIALIZE_FIELD("gatedAPIFeatures", m_gatedAPIFeatures),
    CRDTP_DESERIALIZE_FIELD("id", m_id),
    CRDTP_DESERIALIZE_FIELD("loaderId", m_loaderId),
    CRDTP_DESERIALIZE_FIELD("mimeType", m_mimeType),
    CRDTP_DESERIALIZE_FIELD_OPT("name", m_name),
    CRDTP_DESERIALIZE_FIELD_OPT("parentId", m_parentId),
    CRDTP_DESERIALIZE_FIELD("secureContextType", m_secureContextType),
    CRDTP_DESERIALIZE_FIELD("securityOrigin", m_securityOrigin),
    CRDTP_DESERIALIZE_FIELD_OPT("unreachableUrl", m_unreachableUrl),
    CRDTP_DESERIALIZE_FIELD("url", m_url),
    CRDTP_DESERIALIZE_FIELD_OPT("urlFragment", m_urlFragment),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(Frame)
    CRDTP_SERIALIZE_FIELD("id", m_id);
    CRDTP_SERIALIZE_FIELD("parentId", m_parentId);
    CRDTP_SERIALIZE_FIELD("loaderId", m_loaderId);
    CRDTP_SERIALIZE_FIELD("name", m_name);
    CRDTP_SERIALIZE_FIELD("url", m_url);
    CRDTP_SERIALIZE_FIELD("urlFragment", m_urlFragment);
    CRDTP_SERIALIZE_FIELD("domainAndRegistry", m_domainAndRegistry);
    CRDTP_SERIALIZE_FIELD("securityOrigin", m_securityOrigin);
    CRDTP_SERIALIZE_FIELD("mimeType", m_mimeType);
    CRDTP_SERIALIZE_FIELD("unreachableUrl", m_unreachableUrl);
    CRDTP_SERIALIZE_FIELD("adFrameStatus", m_adFrameStatus);
    CRDTP_SERIALIZE_FIELD("secureContextType", m_secureContextType);
    CRDTP_SERIALIZE_FIELD("crossOriginIsolatedContextType", m_crossOriginIsolatedContextType);
    CRDTP_SERIALIZE_FIELD("gatedAPIFeatures", m_gatedAPIFeatures);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(FrameResource)
    CRDTP_DESERIALIZE_FIELD_OPT("canceled", m_canceled),
    CRDTP_DESERIALIZE_FIELD_OPT("contentSize", m_contentSize),
    CRDTP_DESERIALIZE_FIELD_OPT("failed", m_failed),
    CRDTP_DESERIALIZE_FIELD_OPT("lastModified", m_lastModified),
    CRDTP_DESERIALIZE_FIELD("mimeType", m_mimeType),
    CRDTP_DESERIALIZE_FIELD("type", m_type),
    CRDTP_DESERIALIZE_FIELD("url", m_url),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(FrameResource)
    CRDTP_SERIALIZE_FIELD("url", m_url);
    CRDTP_SERIALIZE_FIELD("type", m_type);
    CRDTP_SERIALIZE_FIELD("mimeType", m_mimeType);
    CRDTP_SERIALIZE_FIELD("lastModified", m_lastModified);
    CRDTP_SERIALIZE_FIELD("contentSize", m_contentSize);
    CRDTP_SERIALIZE_FIELD("failed", m_failed);
    CRDTP_SERIALIZE_FIELD("canceled", m_canceled);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(FrameResourceTree)
    CRDTP_DESERIALIZE_FIELD_OPT("childFrames", m_childFrames),
    CRDTP_DESERIALIZE_FIELD("frame", m_frame),
    CRDTP_DESERIALIZE_FIELD("resources", m_resources),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(FrameResourceTree)
    CRDTP_SERIALIZE_FIELD("frame", m_frame);
    CRDTP_SERIALIZE_FIELD("childFrames", m_childFrames);
    CRDTP_SERIALIZE_FIELD("resources", m_resources);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(FrameTree)
    CRDTP_DESERIALIZE_FIELD_OPT("childFrames", m_childFrames),
    CRDTP_DESERIALIZE_FIELD("frame", m_frame),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(FrameTree)
    CRDTP_SERIALIZE_FIELD("frame", m_frame);
    CRDTP_SERIALIZE_FIELD("childFrames", m_childFrames);
CRDTP_END_SERIALIZER();



CRDTP_BEGIN_DESERIALIZER(LayoutViewport)
    CRDTP_DESERIALIZE_FIELD("clientHeight", m_clientHeight),
    CRDTP_DESERIALIZE_FIELD("clientWidth", m_clientWidth),
    CRDTP_DESERIALIZE_FIELD("pageX", m_pageX),
    CRDTP_DESERIALIZE_FIELD("pageY", m_pageY),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(LayoutViewport)
    CRDTP_SERIALIZE_FIELD("pageX", m_pageX);
    CRDTP_SERIALIZE_FIELD("pageY", m_pageY);
    CRDTP_SERIALIZE_FIELD("clientWidth", m_clientWidth);
    CRDTP_SERIALIZE_FIELD("clientHeight", m_clientHeight);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(VisualViewport)
    CRDTP_DESERIALIZE_FIELD("clientHeight", m_clientHeight),
    CRDTP_DESERIALIZE_FIELD("clientWidth", m_clientWidth),
    CRDTP_DESERIALIZE_FIELD("offsetX", m_offsetX),
    CRDTP_DESERIALIZE_FIELD("offsetY", m_offsetY),
    CRDTP_DESERIALIZE_FIELD("pageX", m_pageX),
    CRDTP_DESERIALIZE_FIELD("pageY", m_pageY),
    CRDTP_DESERIALIZE_FIELD("scale", m_scale),
    CRDTP_DESERIALIZE_FIELD_OPT("zoom", m_zoom),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(VisualViewport)
    CRDTP_SERIALIZE_FIELD("offsetX", m_offsetX);
    CRDTP_SERIALIZE_FIELD("offsetY", m_offsetY);
    CRDTP_SERIALIZE_FIELD("pageX", m_pageX);
    CRDTP_SERIALIZE_FIELD("pageY", m_pageY);
    CRDTP_SERIALIZE_FIELD("clientWidth", m_clientWidth);
    CRDTP_SERIALIZE_FIELD("clientHeight", m_clientHeight);
    CRDTP_SERIALIZE_FIELD("scale", m_scale);
    CRDTP_SERIALIZE_FIELD("zoom", m_zoom);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(Viewport)
    CRDTP_DESERIALIZE_FIELD("height", m_height),
    CRDTP_DESERIALIZE_FIELD("scale", m_scale),
    CRDTP_DESERIALIZE_FIELD("width", m_width),
    CRDTP_DESERIALIZE_FIELD("x", m_x),
    CRDTP_DESERIALIZE_FIELD("y", m_y),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(Viewport)
    CRDTP_SERIALIZE_FIELD("x", m_x);
    CRDTP_SERIALIZE_FIELD("y", m_y);
    CRDTP_SERIALIZE_FIELD("width", m_width);
    CRDTP_SERIALIZE_FIELD("height", m_height);
    CRDTP_SERIALIZE_FIELD("scale", m_scale);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(FontFamilies)
    CRDTP_DESERIALIZE_FIELD_OPT("cursive", m_cursive),
    CRDTP_DESERIALIZE_FIELD_OPT("fantasy", m_fantasy),
    CRDTP_DESERIALIZE_FIELD_OPT("fixed", m_fixed),
    CRDTP_DESERIALIZE_FIELD_OPT("math", m_math),
    CRDTP_DESERIALIZE_FIELD_OPT("sansSerif", m_sansSerif),
    CRDTP_DESERIALIZE_FIELD_OPT("serif", m_serif),
    CRDTP_DESERIALIZE_FIELD_OPT("standard", m_standard),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(FontFamilies)
    CRDTP_SERIALIZE_FIELD("standard", m_standard);
    CRDTP_SERIALIZE_FIELD("fixed", m_fixed);
    CRDTP_SERIALIZE_FIELD("serif", m_serif);
    CRDTP_SERIALIZE_FIELD("sansSerif", m_sansSerif);
    CRDTP_SERIALIZE_FIELD("cursive", m_cursive);
    CRDTP_SERIALIZE_FIELD("fantasy", m_fantasy);
    CRDTP_SERIALIZE_FIELD("math", m_math);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(ScriptFontFamilies)
    CRDTP_DESERIALIZE_FIELD("fontFamilies", m_fontFamilies),
    CRDTP_DESERIALIZE_FIELD("script", m_script),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(ScriptFontFamilies)
    CRDTP_SERIALIZE_FIELD("script", m_script);
    CRDTP_SERIALIZE_FIELD("fontFamilies", m_fontFamilies);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(FontSizes)
    CRDTP_DESERIALIZE_FIELD_OPT("fixed", m_fixed),
    CRDTP_DESERIALIZE_FIELD_OPT("standard", m_standard),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(FontSizes)
    CRDTP_SERIALIZE_FIELD("standard", m_standard);
    CRDTP_SERIALIZE_FIELD("fixed", m_fixed);
CRDTP_END_SERIALIZER();


namespace ClientNavigationReasonEnum {
const char FormSubmissionGet[] = "formSubmissionGet";
const char FormSubmissionPost[] = "formSubmissionPost";
const char HttpHeaderRefresh[] = "httpHeaderRefresh";
const char ScriptInitiated[] = "scriptInitiated";
const char MetaTagRefresh[] = "metaTagRefresh";
const char PageBlockInterstitial[] = "pageBlockInterstitial";
const char Reload[] = "reload";
const char AnchorClick[] = "anchorClick";
} // namespace ClientNavigationReasonEnum


namespace ClientNavigationDispositionEnum {
const char CurrentTab[] = "currentTab";
const char NewTab[] = "newTab";
const char NewWindow[] = "newWindow";
const char Download[] = "download";
} // namespace ClientNavigationDispositionEnum


CRDTP_BEGIN_DESERIALIZER(CompilationCacheParams)
    CRDTP_DESERIALIZE_FIELD_OPT("eager", m_eager),
    CRDTP_DESERIALIZE_FIELD("url", m_url),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(CompilationCacheParams)
    CRDTP_SERIALIZE_FIELD("url", m_url);
    CRDTP_SERIALIZE_FIELD("eager", m_eager);
CRDTP_END_SERIALIZER();


namespace NavigationTypeEnum {
const char Navigation[] = "Navigation";
const char BackForwardCacheRestore[] = "BackForwardCacheRestore";
} // namespace NavigationTypeEnum


namespace BackForwardCacheNotRestoredReasonEnum {
const char NotPrimaryMainFrame[] = "NotPrimaryMainFrame";
const char BackForwardCacheDisabled[] = "BackForwardCacheDisabled";
const char RelatedActiveContentsExist[] = "RelatedActiveContentsExist";
const char HTTPStatusNotOK[] = "HTTPStatusNotOK";
const char SchemeNotHTTPOrHTTPS[] = "SchemeNotHTTPOrHTTPS";
const char Loading[] = "Loading";
const char WasGrantedMediaAccess[] = "WasGrantedMediaAccess";
const char DisableForRenderFrameHostCalled[] = "DisableForRenderFrameHostCalled";
const char DomainNotAllowed[] = "DomainNotAllowed";
const char HTTPMethodNotGET[] = "HTTPMethodNotGET";
const char SubframeIsNavigating[] = "SubframeIsNavigating";
const char Timeout[] = "Timeout";
const char CacheLimit[] = "CacheLimit";
const char JavaScriptExecution[] = "JavaScriptExecution";
const char RendererProcessKilled[] = "RendererProcessKilled";
const char RendererProcessCrashed[] = "RendererProcessCrashed";
const char SchedulerTrackedFeatureUsed[] = "SchedulerTrackedFeatureUsed";
const char ConflictingBrowsingInstance[] = "ConflictingBrowsingInstance";
const char CacheFlushed[] = "CacheFlushed";
const char ServiceWorkerVersionActivation[] = "ServiceWorkerVersionActivation";
const char SessionRestored[] = "SessionRestored";
const char ServiceWorkerPostMessage[] = "ServiceWorkerPostMessage";
const char EnteredBackForwardCacheBeforeServiceWorkerHostAdded[] = "EnteredBackForwardCacheBeforeServiceWorkerHostAdded";
const char RenderFrameHostReused_SameSite[] = "RenderFrameHostReused_SameSite";
const char RenderFrameHostReused_CrossSite[] = "RenderFrameHostReused_CrossSite";
const char ServiceWorkerClaim[] = "ServiceWorkerClaim";
const char IgnoreEventAndEvict[] = "IgnoreEventAndEvict";
const char HaveInnerContents[] = "HaveInnerContents";
const char TimeoutPuttingInCache[] = "TimeoutPuttingInCache";
const char BackForwardCacheDisabledByLowMemory[] = "BackForwardCacheDisabledByLowMemory";
const char BackForwardCacheDisabledByCommandLine[] = "BackForwardCacheDisabledByCommandLine";
const char NetworkRequestDatapipeDrainedAsBytesConsumer[] = "NetworkRequestDatapipeDrainedAsBytesConsumer";
const char NetworkRequestRedirected[] = "NetworkRequestRedirected";
const char NetworkRequestTimeout[] = "NetworkRequestTimeout";
const char NetworkExceedsBufferLimit[] = "NetworkExceedsBufferLimit";
const char NavigationCancelledWhileRestoring[] = "NavigationCancelledWhileRestoring";
const char NotMostRecentNavigationEntry[] = "NotMostRecentNavigationEntry";
const char BackForwardCacheDisabledForPrerender[] = "BackForwardCacheDisabledForPrerender";
const char UserAgentOverrideDiffers[] = "UserAgentOverrideDiffers";
const char ForegroundCacheLimit[] = "ForegroundCacheLimit";
const char BrowsingInstanceNotSwapped[] = "BrowsingInstanceNotSwapped";
const char BackForwardCacheDisabledForDelegate[] = "BackForwardCacheDisabledForDelegate";
const char UnloadHandlerExistsInMainFrame[] = "UnloadHandlerExistsInMainFrame";
const char UnloadHandlerExistsInSubFrame[] = "UnloadHandlerExistsInSubFrame";
const char ServiceWorkerUnregistration[] = "ServiceWorkerUnregistration";
const char CacheControlNoStore[] = "CacheControlNoStore";
const char CacheControlNoStoreCookieModified[] = "CacheControlNoStoreCookieModified";
const char CacheControlNoStoreHTTPOnlyCookieModified[] = "CacheControlNoStoreHTTPOnlyCookieModified";
const char NoResponseHead[] = "NoResponseHead";
const char Unknown[] = "Unknown";
const char ActivationNavigationsDisallowedForBug1234857[] = "ActivationNavigationsDisallowedForBug1234857";
const char ErrorDocument[] = "ErrorDocument";
const char FencedFramesEmbedder[] = "FencedFramesEmbedder";
const char WebSocket[] = "WebSocket";
const char WebTransport[] = "WebTransport";
const char WebRTC[] = "WebRTC";
const char MainResourceHasCacheControlNoStore[] = "MainResourceHasCacheControlNoStore";
const char MainResourceHasCacheControlNoCache[] = "MainResourceHasCacheControlNoCache";
const char SubresourceHasCacheControlNoStore[] = "SubresourceHasCacheControlNoStore";
const char SubresourceHasCacheControlNoCache[] = "SubresourceHasCacheControlNoCache";
const char ContainsPlugins[] = "ContainsPlugins";
const char DocumentLoaded[] = "DocumentLoaded";
const char DedicatedWorkerOrWorklet[] = "DedicatedWorkerOrWorklet";
const char OutstandingNetworkRequestOthers[] = "OutstandingNetworkRequestOthers";
const char OutstandingIndexedDBTransaction[] = "OutstandingIndexedDBTransaction";
const char RequestedNotificationsPermission[] = "RequestedNotificationsPermission";
const char RequestedMIDIPermission[] = "RequestedMIDIPermission";
const char RequestedAudioCapturePermission[] = "RequestedAudioCapturePermission";
const char RequestedVideoCapturePermission[] = "RequestedVideoCapturePermission";
const char RequestedBackForwardCacheBlockedSensors[] = "RequestedBackForwardCacheBlockedSensors";
const char RequestedBackgroundWorkPermission[] = "RequestedBackgroundWorkPermission";
const char BroadcastChannel[] = "BroadcastChannel";
const char IndexedDBConnection[] = "IndexedDBConnection";
const char WebXR[] = "WebXR";
const char SharedWorker[] = "SharedWorker";
const char WebLocks[] = "WebLocks";
const char WebHID[] = "WebHID";
const char WebShare[] = "WebShare";
const char RequestedStorageAccessGrant[] = "RequestedStorageAccessGrant";
const char WebNfc[] = "WebNfc";
const char OutstandingNetworkRequestFetch[] = "OutstandingNetworkRequestFetch";
const char OutstandingNetworkRequestXHR[] = "OutstandingNetworkRequestXHR";
const char AppBanner[] = "AppBanner";
const char Printing[] = "Printing";
const char WebDatabase[] = "WebDatabase";
const char PictureInPicture[] = "PictureInPicture";
const char Portal[] = "Portal";
const char SpeechRecognizer[] = "SpeechRecognizer";
const char IdleManager[] = "IdleManager";
const char PaymentManager[] = "PaymentManager";
const char SpeechSynthesis[] = "SpeechSynthesis";
const char KeyboardLock[] = "KeyboardLock";
const char WebOTPService[] = "WebOTPService";
const char OutstandingNetworkRequestDirectSocket[] = "OutstandingNetworkRequestDirectSocket";
const char InjectedJavascript[] = "InjectedJavascript";
const char InjectedStyleSheet[] = "InjectedStyleSheet";
const char Dummy[] = "Dummy";
const char ContentSecurityHandler[] = "ContentSecurityHandler";
const char ContentWebAuthenticationAPI[] = "ContentWebAuthenticationAPI";
const char ContentFileChooser[] = "ContentFileChooser";
const char ContentSerial[] = "ContentSerial";
const char ContentFileSystemAccess[] = "ContentFileSystemAccess";
const char ContentMediaDevicesDispatcherHost[] = "ContentMediaDevicesDispatcherHost";
const char ContentWebBluetooth[] = "ContentWebBluetooth";
const char ContentWebUSB[] = "ContentWebUSB";
const char ContentMediaSessionService[] = "ContentMediaSessionService";
const char ContentScreenReader[] = "ContentScreenReader";
const char EmbedderPopupBlockerTabHelper[] = "EmbedderPopupBlockerTabHelper";
const char EmbedderSafeBrowsingTriggeredPopupBlocker[] = "EmbedderSafeBrowsingTriggeredPopupBlocker";
const char EmbedderSafeBrowsingThreatDetails[] = "EmbedderSafeBrowsingThreatDetails";
const char EmbedderAppBannerManager[] = "EmbedderAppBannerManager";
const char EmbedderDomDistillerViewerSource[] = "EmbedderDomDistillerViewerSource";
const char EmbedderDomDistillerSelfDeletingRequestDelegate[] = "EmbedderDomDistillerSelfDeletingRequestDelegate";
const char EmbedderOomInterventionTabHelper[] = "EmbedderOomInterventionTabHelper";
const char EmbedderOfflinePage[] = "EmbedderOfflinePage";
const char EmbedderChromePasswordManagerClientBindCredentialManager[] = "EmbedderChromePasswordManagerClientBindCredentialManager";
const char EmbedderPermissionRequestManager[] = "EmbedderPermissionRequestManager";
const char EmbedderModalDialog[] = "EmbedderModalDialog";
const char EmbedderExtensions[] = "EmbedderExtensions";
const char EmbedderExtensionMessaging[] = "EmbedderExtensionMessaging";
const char EmbedderExtensionMessagingForOpenPort[] = "EmbedderExtensionMessagingForOpenPort";
const char EmbedderExtensionSentMessageToCachedFrame[] = "EmbedderExtensionSentMessageToCachedFrame";
} // namespace BackForwardCacheNotRestoredReasonEnum


namespace BackForwardCacheNotRestoredReasonTypeEnum {
const char SupportPending[] = "SupportPending";
const char PageSupportNeeded[] = "PageSupportNeeded";
const char Circumstantial[] = "Circumstantial";
} // namespace BackForwardCacheNotRestoredReasonTypeEnum


CRDTP_BEGIN_DESERIALIZER(BackForwardCacheNotRestoredExplanation)
    CRDTP_DESERIALIZE_FIELD_OPT("context", m_context),
    CRDTP_DESERIALIZE_FIELD("reason", m_reason),
    CRDTP_DESERIALIZE_FIELD("type", m_type),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(BackForwardCacheNotRestoredExplanation)
    CRDTP_SERIALIZE_FIELD("type", m_type);
    CRDTP_SERIALIZE_FIELD("reason", m_reason);
    CRDTP_SERIALIZE_FIELD("context", m_context);
CRDTP_END_SERIALIZER();


CRDTP_BEGIN_DESERIALIZER(BackForwardCacheNotRestoredExplanationTree)
    CRDTP_DESERIALIZE_FIELD("children", m_children),
    CRDTP_DESERIALIZE_FIELD("explanations", m_explanations),
    CRDTP_DESERIALIZE_FIELD("url", m_url),
CRDTP_END_DESERIALIZER()

CRDTP_BEGIN_SERIALIZER(BackForwardCacheNotRestoredExplanationTree)
    CRDTP_SERIALIZE_FIELD("url", m_url);
    CRDTP_SERIALIZE_FIELD("explanations", m_explanations);
    CRDTP_SERIALIZE_FIELD("children", m_children);
CRDTP_END_SERIALIZER();


namespace PrerenderFinalStatusEnum {
const char Activated[] = "Activated";
const char Destroyed[] = "Destroyed";
const char LowEndDevice[] = "LowEndDevice";
const char CrossOriginRedirect[] = "CrossOriginRedirect";
const char CrossOriginNavigation[] = "CrossOriginNavigation";
const char InvalidSchemeRedirect[] = "InvalidSchemeRedirect";
const char InvalidSchemeNavigation[] = "InvalidSchemeNavigation";
const char InProgressNavigation[] = "InProgressNavigation";
const char NavigationRequestBlockedByCsp[] = "NavigationRequestBlockedByCsp";
const char MainFrameNavigation[] = "MainFrameNavigation";
const char MojoBinderPolicy[] = "MojoBinderPolicy";
const char RendererProcessCrashed[] = "RendererProcessCrashed";
const char RendererProcessKilled[] = "RendererProcessKilled";
const char Download[] = "Download";
const char TriggerDestroyed[] = "TriggerDestroyed";
const char NavigationNotCommitted[] = "NavigationNotCommitted";
const char NavigationBadHttpStatus[] = "NavigationBadHttpStatus";
const char ClientCertRequested[] = "ClientCertRequested";
const char NavigationRequestNetworkError[] = "NavigationRequestNetworkError";
const char MaxNumOfRunningPrerendersExceeded[] = "MaxNumOfRunningPrerendersExceeded";
const char CancelAllHostsForTesting[] = "CancelAllHostsForTesting";
const char DidFailLoad[] = "DidFailLoad";
const char Stop[] = "Stop";
const char SslCertificateError[] = "SslCertificateError";
const char LoginAuthRequested[] = "LoginAuthRequested";
const char UaChangeRequiresReload[] = "UaChangeRequiresReload";
const char BlockedByClient[] = "BlockedByClient";
const char AudioOutputDeviceRequested[] = "AudioOutputDeviceRequested";
const char MixedContent[] = "MixedContent";
const char TriggerBackgrounded[] = "TriggerBackgrounded";
const char EmbedderTriggeredAndSameOriginRedirected[] = "EmbedderTriggeredAndSameOriginRedirected";
const char EmbedderTriggeredAndCrossOriginRedirected[] = "EmbedderTriggeredAndCrossOriginRedirected";
const char EmbedderTriggeredAndDestroyed[] = "EmbedderTriggeredAndDestroyed";
const char MemoryLimitExceeded[] = "MemoryLimitExceeded";
const char FailToGetMemoryUsage[] = "FailToGetMemoryUsage";
} // namespace PrerenderFinalStatusEnum


// ------------- Enum values from params.


namespace CaptureScreenshot {
namespace FormatEnum {
const char* Jpeg = "jpeg";
const char* Png = "png";
const char* Webp = "webp";
} // namespace FormatEnum
} // namespace CaptureScreenshot

namespace CaptureSnapshot {
namespace FormatEnum {
const char* Mhtml = "mhtml";
} // namespace FormatEnum
} // namespace CaptureSnapshot

namespace PrintToPDF {
namespace TransferModeEnum {
const char* ReturnAsBase64 = "ReturnAsBase64";
const char* ReturnAsStream = "ReturnAsStream";
} // namespace TransferModeEnum
} // namespace PrintToPDF

namespace SetDownloadBehavior {
namespace BehaviorEnum {
const char* Deny = "deny";
const char* Allow = "allow";
const char* Default = "default";
} // namespace BehaviorEnum
} // namespace SetDownloadBehavior

namespace SetTouchEmulationEnabled {
namespace ConfigurationEnum {
const char* Mobile = "mobile";
const char* Desktop = "desktop";
} // namespace ConfigurationEnum
} // namespace SetTouchEmulationEnabled

namespace StartScreencast {
namespace FormatEnum {
const char* Jpeg = "jpeg";
const char* Png = "png";
} // namespace FormatEnum
} // namespace StartScreencast

namespace SetWebLifecycleState {
namespace StateEnum {
const char* Frozen = "frozen";
const char* Active = "active";
} // namespace StateEnum
} // namespace SetWebLifecycleState

namespace SetSPCTransactionMode {
namespace ModeEnum {
const char* None = "none";
const char* Autoaccept = "autoaccept";
const char* Autoreject = "autoreject";
} // namespace ModeEnum
} // namespace SetSPCTransactionMode

namespace FileChooserOpened {
namespace ModeEnum {
const char* SelectSingle = "selectSingle";
const char* SelectMultiple = "selectMultiple";
} // namespace ModeEnum
} // namespace FileChooserOpened

namespace FrameDetached {
namespace ReasonEnum {
const char* Remove = "remove";
const char* Swap = "swap";
} // namespace ReasonEnum
} // namespace FrameDetached

namespace DownloadProgress {
namespace StateEnum {
const char* InProgress = "inProgress";
const char* Completed = "completed";
const char* Canceled = "canceled";
} // namespace StateEnum
} // namespace DownloadProgress

// ------------- Frontend notifications.

void Frontend::domContentEventFired(double timestamp)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("timestamp"), timestamp);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.domContentEventFired", serializer.Finish()));
}

void Frontend::fileChooserOpened(const String& frameId, const String& mode, Maybe<int> backendNodeId)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("frameId"), frameId);
    serializer.AddField(crdtp::MakeSpan("mode"), mode);
    serializer.AddField(crdtp::MakeSpan("backendNodeId"), backendNodeId);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.fileChooserOpened", serializer.Finish()));
}

void Frontend::frameAttached(const String& frameId, const String& parentFrameId, Maybe<v8_inspector::protocol::Runtime::API::StackTrace> stack, Maybe<protocol::Page::AdScriptId> adScriptId)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("frameId"), frameId);
    serializer.AddField(crdtp::MakeSpan("parentFrameId"), parentFrameId);
    serializer.AddField(crdtp::MakeSpan("stack"), stack);
    serializer.AddField(crdtp::MakeSpan("adScriptId"), adScriptId);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.frameAttached", serializer.Finish()));
}

void Frontend::frameClearedScheduledNavigation(const String& frameId)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("frameId"), frameId);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.frameClearedScheduledNavigation", serializer.Finish()));
}

void Frontend::frameDetached(const String& frameId, const String& reason)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("frameId"), frameId);
    serializer.AddField(crdtp::MakeSpan("reason"), reason);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.frameDetached", serializer.Finish()));
}

void Frontend::frameNavigated(std::unique_ptr<protocol::Page::Frame> frame, const String& type)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("frame"), frame);
    serializer.AddField(crdtp::MakeSpan("type"), type);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.frameNavigated", serializer.Finish()));
}

void Frontend::documentOpened(std::unique_ptr<protocol::Page::Frame> frame)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("frame"), frame);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.documentOpened", serializer.Finish()));
}

void Frontend::frameResized()
{
    if (!frontend_channel_)
        return;
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.frameResized"));
}

void Frontend::frameRequestedNavigation(const String& frameId, const String& reason, const String& url, const String& disposition)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("frameId"), frameId);
    serializer.AddField(crdtp::MakeSpan("reason"), reason);
    serializer.AddField(crdtp::MakeSpan("url"), url);
    serializer.AddField(crdtp::MakeSpan("disposition"), disposition);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.frameRequestedNavigation", serializer.Finish()));
}

void Frontend::frameScheduledNavigation(const String& frameId, double delay, const String& reason, const String& url)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("frameId"), frameId);
    serializer.AddField(crdtp::MakeSpan("delay"), delay);
    serializer.AddField(crdtp::MakeSpan("reason"), reason);
    serializer.AddField(crdtp::MakeSpan("url"), url);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.frameScheduledNavigation", serializer.Finish()));
}

void Frontend::frameStartedLoading(const String& frameId)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("frameId"), frameId);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.frameStartedLoading", serializer.Finish()));
}

void Frontend::frameStoppedLoading(const String& frameId)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("frameId"), frameId);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.frameStoppedLoading", serializer.Finish()));
}

void Frontend::downloadWillBegin(const String& frameId, const String& guid, const String& url, const String& suggestedFilename)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("frameId"), frameId);
    serializer.AddField(crdtp::MakeSpan("guid"), guid);
    serializer.AddField(crdtp::MakeSpan("url"), url);
    serializer.AddField(crdtp::MakeSpan("suggestedFilename"), suggestedFilename);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.downloadWillBegin", serializer.Finish()));
}

void Frontend::downloadProgress(const String& guid, double totalBytes, double receivedBytes, const String& state)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("guid"), guid);
    serializer.AddField(crdtp::MakeSpan("totalBytes"), totalBytes);
    serializer.AddField(crdtp::MakeSpan("receivedBytes"), receivedBytes);
    serializer.AddField(crdtp::MakeSpan("state"), state);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.downloadProgress", serializer.Finish()));
}

void Frontend::lifecycleEvent(const String& frameId, const String& loaderId, const String& name, double timestamp)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("frameId"), frameId);
    serializer.AddField(crdtp::MakeSpan("loaderId"), loaderId);
    serializer.AddField(crdtp::MakeSpan("name"), name);
    serializer.AddField(crdtp::MakeSpan("timestamp"), timestamp);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.lifecycleEvent", serializer.Finish()));
}

void Frontend::backForwardCacheNotUsed(const String& loaderId, const String& frameId, std::unique_ptr<protocol::Array<protocol::Page::BackForwardCacheNotRestoredExplanation>> notRestoredExplanations, Maybe<protocol::Page::BackForwardCacheNotRestoredExplanationTree> notRestoredExplanationsTree)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("loaderId"), loaderId);
    serializer.AddField(crdtp::MakeSpan("frameId"), frameId);
    serializer.AddField(crdtp::MakeSpan("notRestoredExplanations"), notRestoredExplanations);
    serializer.AddField(crdtp::MakeSpan("notRestoredExplanationsTree"), notRestoredExplanationsTree);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.backForwardCacheNotUsed", serializer.Finish()));
}

void Frontend::prerenderAttemptCompleted(const String& initiatingFrameId, const String& prerenderingUrl, const String& finalStatus, Maybe<String> reasonDetails)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("initiatingFrameId"), initiatingFrameId);
    serializer.AddField(crdtp::MakeSpan("prerenderingUrl"), prerenderingUrl);
    serializer.AddField(crdtp::MakeSpan("finalStatus"), finalStatus);
    serializer.AddField(crdtp::MakeSpan("reasonDetails"), reasonDetails);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.prerenderAttemptCompleted", serializer.Finish()));
}

void Frontend::loadEventFired(double timestamp)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("timestamp"), timestamp);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.loadEventFired", serializer.Finish()));
}

void Frontend::navigatedWithinDocument(const String& frameId, const String& url)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("frameId"), frameId);
    serializer.AddField(crdtp::MakeSpan("url"), url);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.navigatedWithinDocument", serializer.Finish()));
}

void Frontend::windowOpen(const String& url, const String& windowName, std::unique_ptr<protocol::Array<String>> windowFeatures, bool userGesture)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("url"), url);
    serializer.AddField(crdtp::MakeSpan("windowName"), windowName);
    serializer.AddField(crdtp::MakeSpan("windowFeatures"), windowFeatures);
    serializer.AddField(crdtp::MakeSpan("userGesture"), userGesture);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.windowOpen", serializer.Finish()));
}

void Frontend::compilationCacheProduced(const String& url, const Binary& data)
{
    if (!frontend_channel_)
        return;
    crdtp::ObjectSerializer serializer;
    serializer.AddField(crdtp::MakeSpan("url"), url);
    serializer.AddField(crdtp::MakeSpan("data"), data);
    frontend_channel_->SendProtocolNotification(crdtp::CreateNotification("Page.compilationCacheProduced", serializer.Finish()));
}

void Frontend::flush()
{
    frontend_channel_->FlushProtocolNotifications();
}

void Frontend::sendRawNotification(std::unique_ptr<Serializable> notification)
{
    frontend_channel_->SendProtocolNotification(std::move(notification));
}

// --------------------- Dispatcher.

class DomainDispatcherImpl : public protocol::DomainDispatcher {
public:
    DomainDispatcherImpl(FrontendChannel* frontendChannel, Backend* backend)
        : DomainDispatcher(frontendChannel)
        , m_backend(backend) {}
    ~DomainDispatcherImpl() override { }

    using CallHandler = void (DomainDispatcherImpl::*)(const crdtp::Dispatchable& dispatchable);

    std::function<void(const crdtp::Dispatchable&)> Dispatch(crdtp::span<uint8_t> command_name) override;

    void addScriptToEvaluateOnLoad(const crdtp::Dispatchable& dispatchable);
    void addScriptToEvaluateOnNewDocument(const crdtp::Dispatchable& dispatchable);
    void createIsolatedWorld(const crdtp::Dispatchable& dispatchable);
    void disable(const crdtp::Dispatchable& dispatchable);
    void enable(const crdtp::Dispatchable& dispatchable);
    void getFrameTree(const crdtp::Dispatchable& dispatchable);
    void getLayoutMetrics(const crdtp::Dispatchable& dispatchable);
    void getResourceContent(const crdtp::Dispatchable& dispatchable);
    void getResourceTree(const crdtp::Dispatchable& dispatchable);
    void reload(const crdtp::Dispatchable& dispatchable);
    void removeScriptToEvaluateOnLoad(const crdtp::Dispatchable& dispatchable);
    void removeScriptToEvaluateOnNewDocument(const crdtp::Dispatchable& dispatchable);
    void searchInResource(const crdtp::Dispatchable& dispatchable);
    void setAdBlockingEnabled(const crdtp::Dispatchable& dispatchable);
    void setBypassCSP(const crdtp::Dispatchable& dispatchable);
    void getPermissionsPolicyState(const crdtp::Dispatchable& dispatchable);
    void getOriginTrials(const crdtp::Dispatchable& dispatchable);
    void setFontFamilies(const crdtp::Dispatchable& dispatchable);
    void setFontSizes(const crdtp::Dispatchable& dispatchable);
    void setDocumentContent(const crdtp::Dispatchable& dispatchable);
    void setLifecycleEventsEnabled(const crdtp::Dispatchable& dispatchable);
    void startScreencast(const crdtp::Dispatchable& dispatchable);
    void stopLoading(const crdtp::Dispatchable& dispatchable);
    void stopScreencast(const crdtp::Dispatchable& dispatchable);
    void produceCompilationCache(const crdtp::Dispatchable& dispatchable);
    void addCompilationCache(const crdtp::Dispatchable& dispatchable);
    void clearCompilationCache(const crdtp::Dispatchable& dispatchable);
    void generateTestReport(const crdtp::Dispatchable& dispatchable);
    void waitForDebugger(const crdtp::Dispatchable& dispatchable);
    void setInterceptFileChooserDialog(const crdtp::Dispatchable& dispatchable);
 protected:
    Backend* m_backend;
};

namespace {
// This helper method with a static map of command methods (instance methods
// of DomainDispatcherImpl declared just above) by their name is used immediately below,
// in the DomainDispatcherImpl::Dispatch method.
DomainDispatcherImpl::CallHandler CommandByName(crdtp::span<uint8_t> command_name) {
  static auto* commands = [](){
    auto* commands = new std::vector<std::pair<crdtp::span<uint8_t>,
                              DomainDispatcherImpl::CallHandler>>{
    {
          crdtp::SpanFrom("addCompilationCache"),
          &DomainDispatcherImpl::addCompilationCache
    },
    {
          crdtp::SpanFrom("addScriptToEvaluateOnLoad"),
          &DomainDispatcherImpl::addScriptToEvaluateOnLoad
    },
    {
          crdtp::SpanFrom("addScriptToEvaluateOnNewDocument"),
          &DomainDispatcherImpl::addScriptToEvaluateOnNewDocument
    },
    {
          crdtp::SpanFrom("clearCompilationCache"),
          &DomainDispatcherImpl::clearCompilationCache
    },
    {
          crdtp::SpanFrom("createIsolatedWorld"),
          &DomainDispatcherImpl::createIsolatedWorld
    },
    {
          crdtp::SpanFrom("disable"),
          &DomainDispatcherImpl::disable
    },
    {
          crdtp::SpanFrom("enable"),
          &DomainDispatcherImpl::enable
    },
    {
          crdtp::SpanFrom("generateTestReport"),
          &DomainDispatcherImpl::generateTestReport
    },
    {
          crdtp::SpanFrom("getFrameTree"),
          &DomainDispatcherImpl::getFrameTree
    },
    {
          crdtp::SpanFrom("getLayoutMetrics"),
          &DomainDispatcherImpl::getLayoutMetrics
    },
    {
          crdtp::SpanFrom("getOriginTrials"),
          &DomainDispatcherImpl::getOriginTrials
    },
    {
          crdtp::SpanFrom("getPermissionsPolicyState"),
          &DomainDispatcherImpl::getPermissionsPolicyState
    },
    {
          crdtp::SpanFrom("getResourceContent"),
          &DomainDispatcherImpl::getResourceContent
    },
    {
          crdtp::SpanFrom("getResourceTree"),
          &DomainDispatcherImpl::getResourceTree
    },
    {
          crdtp::SpanFrom("produceCompilationCache"),
          &DomainDispatcherImpl::produceCompilationCache
    },
    {
          crdtp::SpanFrom("reload"),
          &DomainDispatcherImpl::reload
    },
    {
          crdtp::SpanFrom("removeScriptToEvaluateOnLoad"),
          &DomainDispatcherImpl::removeScriptToEvaluateOnLoad
    },
    {
          crdtp::SpanFrom("removeScriptToEvaluateOnNewDocument"),
          &DomainDispatcherImpl::removeScriptToEvaluateOnNewDocument
    },
    {
          crdtp::SpanFrom("searchInResource"),
          &DomainDispatcherImpl::searchInResource
    },
    {
          crdtp::SpanFrom("setAdBlockingEnabled"),
          &DomainDispatcherImpl::setAdBlockingEnabled
    },
    {
          crdtp::SpanFrom("setBypassCSP"),
          &DomainDispatcherImpl::setBypassCSP
    },
    {
          crdtp::SpanFrom("setDocumentContent"),
          &DomainDispatcherImpl::setDocumentContent
    },
    {
          crdtp::SpanFrom("setFontFamilies"),
          &DomainDispatcherImpl::setFontFamilies
    },
    {
          crdtp::SpanFrom("setFontSizes"),
          &DomainDispatcherImpl::setFontSizes
    },
    {
          crdtp::SpanFrom("setInterceptFileChooserDialog"),
          &DomainDispatcherImpl::setInterceptFileChooserDialog
    },
    {
          crdtp::SpanFrom("setLifecycleEventsEnabled"),
          &DomainDispatcherImpl::setLifecycleEventsEnabled
    },
    {
          crdtp::SpanFrom("startScreencast"),
          &DomainDispatcherImpl::startScreencast
    },
    {
          crdtp::SpanFrom("stopLoading"),
          &DomainDispatcherImpl::stopLoading
    },
    {
          crdtp::SpanFrom("stopScreencast"),
          &DomainDispatcherImpl::stopScreencast
    },
    {
          crdtp::SpanFrom("waitForDebugger"),
          &DomainDispatcherImpl::waitForDebugger
    },
    };
    return commands;
  }();
  return crdtp::FindByFirst<DomainDispatcherImpl::CallHandler>(*commands, command_name, nullptr);
}
}  // namespace

std::function<void(const crdtp::Dispatchable&)> DomainDispatcherImpl::Dispatch(crdtp::span<uint8_t> command_name) {
  CallHandler handler = CommandByName(command_name);
  if (!handler) return nullptr;

  return [this, handler](const crdtp::Dispatchable& dispatchable) {
    (this->*handler)(dispatchable);
  };
}


namespace {

struct addScriptToEvaluateOnLoadParams : public crdtp::DeserializableProtocolObject<addScriptToEvaluateOnLoadParams> {
    String scriptSource;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(addScriptToEvaluateOnLoadParams)
    CRDTP_DESERIALIZE_FIELD("scriptSource", scriptSource),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::addScriptToEvaluateOnLoad(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    addScriptToEvaluateOnLoadParams params;
    if (!addScriptToEvaluateOnLoadParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    String out_identifier;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->addScriptToEvaluateOnLoad(params.scriptSource, &out_identifier);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.addScriptToEvaluateOnLoad"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("identifier"), out_identifier);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct addScriptToEvaluateOnNewDocumentParams : public crdtp::DeserializableProtocolObject<addScriptToEvaluateOnNewDocumentParams> {
    String source;
    Maybe<String> worldName;
    Maybe<bool> includeCommandLineAPI;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(addScriptToEvaluateOnNewDocumentParams)
    CRDTP_DESERIALIZE_FIELD_OPT("includeCommandLineAPI", includeCommandLineAPI),
    CRDTP_DESERIALIZE_FIELD("source", source),
    CRDTP_DESERIALIZE_FIELD_OPT("worldName", worldName),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::addScriptToEvaluateOnNewDocument(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    addScriptToEvaluateOnNewDocumentParams params;
    if (!addScriptToEvaluateOnNewDocumentParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    String out_identifier;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->addScriptToEvaluateOnNewDocument(params.source, std::move(params.worldName), std::move(params.includeCommandLineAPI), &out_identifier);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.addScriptToEvaluateOnNewDocument"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("identifier"), out_identifier);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

class CreateIsolatedWorldCallbackImpl : public Backend::CreateIsolatedWorldCallback, public DomainDispatcher::Callback {
public:
    CreateIsolatedWorldCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Page.createIsolatedWorld"), message) { }

    void sendSuccess(int executionContextId) override
    {
        crdtp::ObjectSerializer serializer;
        serializer.AddField(crdtp::MakeSpan("executionContextId"), executionContextId);
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {

struct createIsolatedWorldParams : public crdtp::DeserializableProtocolObject<createIsolatedWorldParams> {
    String frameId;
    Maybe<String> worldName;
    Maybe<bool> grantUniveralAccess;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(createIsolatedWorldParams)
    CRDTP_DESERIALIZE_FIELD("frameId", frameId),
    CRDTP_DESERIALIZE_FIELD_OPT("grantUniveralAccess", grantUniveralAccess),
    CRDTP_DESERIALIZE_FIELD_OPT("worldName", worldName),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::createIsolatedWorld(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    createIsolatedWorldParams params;
    if (!createIsolatedWorldParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    m_backend->createIsolatedWorld(params.frameId, std::move(params.worldName), std::move(params.grantUniveralAccess), std::make_unique<CreateIsolatedWorldCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

namespace {


}  // namespace

void DomainDispatcherImpl::disable(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->disable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.disable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::enable(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->enable();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.enable"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::getFrameTree(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    // Declare output parameters.
    std::unique_ptr<protocol::Page::FrameTree> out_frameTree;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getFrameTree(&out_frameTree);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.getFrameTree"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("frameTree"), out_frameTree);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::getLayoutMetrics(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    // Declare output parameters.
    std::unique_ptr<protocol::Page::LayoutViewport> out_layoutViewport;
    std::unique_ptr<protocol::Page::VisualViewport> out_visualViewport;
    std::unique_ptr<protocol::DOM::Rect> out_contentSize;
    std::unique_ptr<protocol::Page::LayoutViewport> out_cssLayoutViewport;
    std::unique_ptr<protocol::Page::VisualViewport> out_cssVisualViewport;
    std::unique_ptr<protocol::DOM::Rect> out_cssContentSize;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getLayoutMetrics(&out_layoutViewport, &out_visualViewport, &out_contentSize, &out_cssLayoutViewport, &out_cssVisualViewport, &out_cssContentSize);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.getLayoutMetrics"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("layoutViewport"), out_layoutViewport);
          serializer.AddField(crdtp::MakeSpan("visualViewport"), out_visualViewport);
          serializer.AddField(crdtp::MakeSpan("contentSize"), out_contentSize);
          serializer.AddField(crdtp::MakeSpan("cssLayoutViewport"), out_cssLayoutViewport);
          serializer.AddField(crdtp::MakeSpan("cssVisualViewport"), out_cssVisualViewport);
          serializer.AddField(crdtp::MakeSpan("cssContentSize"), out_cssContentSize);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

class GetResourceContentCallbackImpl : public Backend::GetResourceContentCallback, public DomainDispatcher::Callback {
public:
    GetResourceContentCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Page.getResourceContent"), message) { }

    void sendSuccess(const String& content, bool base64Encoded) override
    {
        crdtp::ObjectSerializer serializer;
        serializer.AddField(crdtp::MakeSpan("content"), content);
        serializer.AddField(crdtp::MakeSpan("base64Encoded"), base64Encoded);
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {

struct getResourceContentParams : public crdtp::DeserializableProtocolObject<getResourceContentParams> {
    String frameId;
    String url;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getResourceContentParams)
    CRDTP_DESERIALIZE_FIELD("frameId", frameId),
    CRDTP_DESERIALIZE_FIELD("url", url),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getResourceContent(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getResourceContentParams params;
    if (!getResourceContentParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    m_backend->getResourceContent(params.frameId, params.url, std::make_unique<GetResourceContentCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

namespace {


}  // namespace

void DomainDispatcherImpl::getResourceTree(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    // Declare output parameters.
    std::unique_ptr<protocol::Page::FrameResourceTree> out_frameTree;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getResourceTree(&out_frameTree);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.getResourceTree"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("frameTree"), out_frameTree);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct reloadParams : public crdtp::DeserializableProtocolObject<reloadParams> {
    Maybe<bool> ignoreCache;
    Maybe<String> scriptToEvaluateOnLoad;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(reloadParams)
    CRDTP_DESERIALIZE_FIELD_OPT("ignoreCache", ignoreCache),
    CRDTP_DESERIALIZE_FIELD_OPT("scriptToEvaluateOnLoad", scriptToEvaluateOnLoad),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::reload(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    reloadParams params;
    if (!reloadParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->reload(std::move(params.ignoreCache), std::move(params.scriptToEvaluateOnLoad));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.reload"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct removeScriptToEvaluateOnLoadParams : public crdtp::DeserializableProtocolObject<removeScriptToEvaluateOnLoadParams> {
    String identifier;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(removeScriptToEvaluateOnLoadParams)
    CRDTP_DESERIALIZE_FIELD("identifier", identifier),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::removeScriptToEvaluateOnLoad(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    removeScriptToEvaluateOnLoadParams params;
    if (!removeScriptToEvaluateOnLoadParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->removeScriptToEvaluateOnLoad(params.identifier);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.removeScriptToEvaluateOnLoad"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct removeScriptToEvaluateOnNewDocumentParams : public crdtp::DeserializableProtocolObject<removeScriptToEvaluateOnNewDocumentParams> {
    String identifier;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(removeScriptToEvaluateOnNewDocumentParams)
    CRDTP_DESERIALIZE_FIELD("identifier", identifier),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::removeScriptToEvaluateOnNewDocument(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    removeScriptToEvaluateOnNewDocumentParams params;
    if (!removeScriptToEvaluateOnNewDocumentParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->removeScriptToEvaluateOnNewDocument(params.identifier);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.removeScriptToEvaluateOnNewDocument"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

class SearchInResourceCallbackImpl : public Backend::SearchInResourceCallback, public DomainDispatcher::Callback {
public:
    SearchInResourceCallbackImpl(std::unique_ptr<DomainDispatcher::WeakPtr> backendImpl, int callId, crdtp::span<uint8_t> message)
        : DomainDispatcher::Callback(std::move(backendImpl), callId,
crdtp::SpanFrom("Page.searchInResource"), message) { }

    void sendSuccess(std::unique_ptr<protocol::Array<v8_inspector::protocol::Debugger::API::SearchMatch>> result) override
    {
        crdtp::ObjectSerializer serializer;
        serializer.AddField(crdtp::MakeSpan("result"), result);
        sendIfActive(serializer.Finish(), DispatchResponse::Success());
    }

    void fallThrough() override
    {
        fallThroughIfActive();
    }

    void sendFailure(const DispatchResponse& response) override
    {
        DCHECK(response.IsError());
        sendIfActive(nullptr, response);
    }
};

namespace {

struct searchInResourceParams : public crdtp::DeserializableProtocolObject<searchInResourceParams> {
    String frameId;
    String url;
    String query;
    Maybe<bool> caseSensitive;
    Maybe<bool> isRegex;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(searchInResourceParams)
    CRDTP_DESERIALIZE_FIELD_OPT("caseSensitive", caseSensitive),
    CRDTP_DESERIALIZE_FIELD("frameId", frameId),
    CRDTP_DESERIALIZE_FIELD_OPT("isRegex", isRegex),
    CRDTP_DESERIALIZE_FIELD("query", query),
    CRDTP_DESERIALIZE_FIELD("url", url),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::searchInResource(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    searchInResourceParams params;
    if (!searchInResourceParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    m_backend->searchInResource(params.frameId, params.url, params.query, std::move(params.caseSensitive), std::move(params.isRegex), std::make_unique<SearchInResourceCallbackImpl>(weakPtr(), dispatchable.CallId(), dispatchable.Serialized()));
}

namespace {

struct setAdBlockingEnabledParams : public crdtp::DeserializableProtocolObject<setAdBlockingEnabledParams> {
    bool enabled;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setAdBlockingEnabledParams)
    CRDTP_DESERIALIZE_FIELD("enabled", enabled),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setAdBlockingEnabled(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setAdBlockingEnabledParams params;
    if (!setAdBlockingEnabledParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setAdBlockingEnabled(params.enabled);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.setAdBlockingEnabled"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setBypassCSPParams : public crdtp::DeserializableProtocolObject<setBypassCSPParams> {
    bool enabled;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setBypassCSPParams)
    CRDTP_DESERIALIZE_FIELD("enabled", enabled),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setBypassCSP(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setBypassCSPParams params;
    if (!setBypassCSPParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setBypassCSP(params.enabled);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.setBypassCSP"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct getPermissionsPolicyStateParams : public crdtp::DeserializableProtocolObject<getPermissionsPolicyStateParams> {
    String frameId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getPermissionsPolicyStateParams)
    CRDTP_DESERIALIZE_FIELD("frameId", frameId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getPermissionsPolicyState(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getPermissionsPolicyStateParams params;
    if (!getPermissionsPolicyStateParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::Page::PermissionsPolicyFeatureState>> out_states;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getPermissionsPolicyState(params.frameId, &out_states);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.getPermissionsPolicyState"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("states"), out_states);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct getOriginTrialsParams : public crdtp::DeserializableProtocolObject<getOriginTrialsParams> {
    String frameId;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(getOriginTrialsParams)
    CRDTP_DESERIALIZE_FIELD("frameId", frameId),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::getOriginTrials(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    getOriginTrialsParams params;
    if (!getOriginTrialsParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }
    // Declare output parameters.
    std::unique_ptr<protocol::Array<protocol::Page::OriginTrial>> out_originTrials;

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->getOriginTrials(params.frameId, &out_originTrials);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.getOriginTrials"), dispatchable.Serialized());
        return;
    }
      if (weak->get()) {
        std::unique_ptr<crdtp::Serializable> result;
        if (response.IsSuccess()) {
          crdtp::ObjectSerializer serializer;
          serializer.AddField(crdtp::MakeSpan("originTrials"), out_originTrials);
          result = serializer.Finish();
        } else {
          result = Serializable::From({});
        }
        weak->get()->sendResponse(dispatchable.CallId(), response, std::move(result));
      }
    return;
}

namespace {

struct setFontFamiliesParams : public crdtp::DeserializableProtocolObject<setFontFamiliesParams> {
    std::unique_ptr<protocol::Page::FontFamilies> fontFamilies;
    Maybe<protocol::Array<protocol::Page::ScriptFontFamilies>> forScripts;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setFontFamiliesParams)
    CRDTP_DESERIALIZE_FIELD("fontFamilies", fontFamilies),
    CRDTP_DESERIALIZE_FIELD_OPT("forScripts", forScripts),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setFontFamilies(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setFontFamiliesParams params;
    if (!setFontFamiliesParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setFontFamilies(std::move(params.fontFamilies), std::move(params.forScripts));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.setFontFamilies"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setFontSizesParams : public crdtp::DeserializableProtocolObject<setFontSizesParams> {
    std::unique_ptr<protocol::Page::FontSizes> fontSizes;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setFontSizesParams)
    CRDTP_DESERIALIZE_FIELD("fontSizes", fontSizes),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setFontSizes(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setFontSizesParams params;
    if (!setFontSizesParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setFontSizes(std::move(params.fontSizes));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.setFontSizes"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setDocumentContentParams : public crdtp::DeserializableProtocolObject<setDocumentContentParams> {
    String frameId;
    String html;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setDocumentContentParams)
    CRDTP_DESERIALIZE_FIELD("frameId", frameId),
    CRDTP_DESERIALIZE_FIELD("html", html),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setDocumentContent(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setDocumentContentParams params;
    if (!setDocumentContentParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setDocumentContent(params.frameId, params.html);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.setDocumentContent"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setLifecycleEventsEnabledParams : public crdtp::DeserializableProtocolObject<setLifecycleEventsEnabledParams> {
    bool enabled;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setLifecycleEventsEnabledParams)
    CRDTP_DESERIALIZE_FIELD("enabled", enabled),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setLifecycleEventsEnabled(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setLifecycleEventsEnabledParams params;
    if (!setLifecycleEventsEnabledParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setLifecycleEventsEnabled(params.enabled);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.setLifecycleEventsEnabled"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct startScreencastParams : public crdtp::DeserializableProtocolObject<startScreencastParams> {
    Maybe<String> format;
    Maybe<int> quality;
    Maybe<int> maxWidth;
    Maybe<int> maxHeight;
    Maybe<int> everyNthFrame;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(startScreencastParams)
    CRDTP_DESERIALIZE_FIELD_OPT("everyNthFrame", everyNthFrame),
    CRDTP_DESERIALIZE_FIELD_OPT("format", format),
    CRDTP_DESERIALIZE_FIELD_OPT("maxHeight", maxHeight),
    CRDTP_DESERIALIZE_FIELD_OPT("maxWidth", maxWidth),
    CRDTP_DESERIALIZE_FIELD_OPT("quality", quality),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::startScreencast(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    startScreencastParams params;
    if (!startScreencastParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->startScreencast(std::move(params.format), std::move(params.quality), std::move(params.maxWidth), std::move(params.maxHeight), std::move(params.everyNthFrame));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.startScreencast"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::stopLoading(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->stopLoading();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.stopLoading"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::stopScreencast(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->stopScreencast();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.stopScreencast"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct produceCompilationCacheParams : public crdtp::DeserializableProtocolObject<produceCompilationCacheParams> {
    std::unique_ptr<protocol::Array<protocol::Page::CompilationCacheParams>> scripts;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(produceCompilationCacheParams)
    CRDTP_DESERIALIZE_FIELD("scripts", scripts),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::produceCompilationCache(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    produceCompilationCacheParams params;
    if (!produceCompilationCacheParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->produceCompilationCache(std::move(params.scripts));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.produceCompilationCache"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct addCompilationCacheParams : public crdtp::DeserializableProtocolObject<addCompilationCacheParams> {
    String url;
    Binary data;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(addCompilationCacheParams)
    CRDTP_DESERIALIZE_FIELD("data", data),
    CRDTP_DESERIALIZE_FIELD("url", url),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::addCompilationCache(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    addCompilationCacheParams params;
    if (!addCompilationCacheParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->addCompilationCache(params.url, params.data);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.addCompilationCache"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::clearCompilationCache(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->clearCompilationCache();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.clearCompilationCache"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct generateTestReportParams : public crdtp::DeserializableProtocolObject<generateTestReportParams> {
    String message;
    Maybe<String> group;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(generateTestReportParams)
    CRDTP_DESERIALIZE_FIELD_OPT("group", group),
    CRDTP_DESERIALIZE_FIELD("message", message),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::generateTestReport(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    generateTestReportParams params;
    if (!generateTestReportParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->generateTestReport(params.message, std::move(params.group));
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.generateTestReport"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {


}  // namespace

void DomainDispatcherImpl::waitForDebugger(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->waitForDebugger();
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.waitForDebugger"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {

struct setInterceptFileChooserDialogParams : public crdtp::DeserializableProtocolObject<setInterceptFileChooserDialogParams> {
    bool enabled;
    DECLARE_DESERIALIZATION_SUPPORT();
};

CRDTP_BEGIN_DESERIALIZER(setInterceptFileChooserDialogParams)
    CRDTP_DESERIALIZE_FIELD("enabled", enabled),
CRDTP_END_DESERIALIZER()

}  // namespace

void DomainDispatcherImpl::setInterceptFileChooserDialog(const crdtp::Dispatchable& dispatchable)
{
    // Prepare input parameters.
    auto deserializer = crdtp::DeferredMessage::FromSpan(dispatchable.Params())->MakeDeserializer();
    setInterceptFileChooserDialogParams params;
    if (!setInterceptFileChooserDialogParams::Deserialize(&deserializer, &params)) {
      ReportInvalidParams(dispatchable, deserializer);
      return;
    }

    std::unique_ptr<DomainDispatcher::WeakPtr> weak = weakPtr();
    DispatchResponse response = m_backend->setInterceptFileChooserDialog(params.enabled);
    if (response.IsFallThrough()) {
        channel()->FallThrough(dispatchable.CallId(), crdtp::SpanFrom("Page.setInterceptFileChooserDialog"), dispatchable.Serialized());
        return;
    }
    if (weak->get())
        weak->get()->sendResponse(dispatchable.CallId(), response);
    return;
}

namespace {
// This helper method (with a static map of redirects) is used from Dispatcher::wire
// immediately below.
const std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>& SortedRedirects() {
  static auto* redirects = [](){
    auto* redirects = new std::vector<std::pair<crdtp::span<uint8_t>, crdtp::span<uint8_t>>>{
          { crdtp::SpanFrom("Page.clearDeviceMetricsOverride"), crdtp::SpanFrom("Emulation.clearDeviceMetricsOverride") },
          { crdtp::SpanFrom("Page.clearDeviceOrientationOverride"), crdtp::SpanFrom("DeviceOrientation.clearDeviceOrientationOverride") },
          { crdtp::SpanFrom("Page.clearGeolocationOverride"), crdtp::SpanFrom("Emulation.clearGeolocationOverride") },
          { crdtp::SpanFrom("Page.deleteCookie"), crdtp::SpanFrom("Network.deleteCookie") },
          { crdtp::SpanFrom("Page.getCookies"), crdtp::SpanFrom("Network.getCookies") },
          { crdtp::SpanFrom("Page.setDeviceMetricsOverride"), crdtp::SpanFrom("Emulation.setDeviceMetricsOverride") },
          { crdtp::SpanFrom("Page.setDeviceOrientationOverride"), crdtp::SpanFrom("DeviceOrientation.setDeviceOrientationOverride") },
          { crdtp::SpanFrom("Page.setGeolocationOverride"), crdtp::SpanFrom("Emulation.setGeolocationOverride") },
          { crdtp::SpanFrom("Page.setTouchEmulationEnabled"), crdtp::SpanFrom("Emulation.setTouchEmulationEnabled") },
    };
    return redirects;
  }();
  return *redirects;
}
}  // namespace

// static
void Dispatcher::wire(UberDispatcher* uber, Backend* backend)
{
    auto dispatcher = std::make_unique<DomainDispatcherImpl>(uber->channel(), backend);
    uber->WireBackend(crdtp::SpanFrom("Page"), SortedRedirects(), std::move(dispatcher));
}

} // Page
} // namespace blink
} // namespace protocol
