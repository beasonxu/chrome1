// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dom_distiller.proto

#include "dom_distiller.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace dom_distiller {
namespace proto {
PROTOBUF_CONSTEXPR DistilledContent::DistilledContent(
    ::_pbi::ConstantInitialized)
  : html_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct DistilledContentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DistilledContentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DistilledContentDefaultTypeInternal() {}
  union {
    DistilledContent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DistilledContentDefaultTypeInternal _DistilledContent_default_instance_;
PROTOBUF_CONSTEXPR PaginationInfo::PaginationInfo(
    ::_pbi::ConstantInitialized)
  : next_page_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , prev_page_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , canonical_page_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct PaginationInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PaginationInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PaginationInfoDefaultTypeInternal() {}
  union {
    PaginationInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PaginationInfoDefaultTypeInternal _PaginationInfo_default_instance_;
PROTOBUF_CONSTEXPR MarkupArticle::MarkupArticle(
    ::_pbi::ConstantInitialized)
  : authors_()
  , published_time_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , modified_time_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , expiration_time_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , section_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct MarkupArticleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MarkupArticleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MarkupArticleDefaultTypeInternal() {}
  union {
    MarkupArticle _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MarkupArticleDefaultTypeInternal _MarkupArticle_default_instance_;
PROTOBUF_CONSTEXPR MarkupImage::MarkupImage(
    ::_pbi::ConstantInitialized)
  : url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , secure_url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , type_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , caption_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , width_(0)
  , height_(0){}
struct MarkupImageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MarkupImageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MarkupImageDefaultTypeInternal() {}
  union {
    MarkupImage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MarkupImageDefaultTypeInternal _MarkupImage_default_instance_;
PROTOBUF_CONSTEXPR MarkupInfo::MarkupInfo(
    ::_pbi::ConstantInitialized)
  : images_()
  , title_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , type_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , description_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , publisher_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , copyright_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , author_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , article_(nullptr){}
struct MarkupInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MarkupInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MarkupInfoDefaultTypeInternal() {}
  union {
    MarkupInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MarkupInfoDefaultTypeInternal _MarkupInfo_default_instance_;
PROTOBUF_CONSTEXPR TimingEntry::TimingEntry(
    ::_pbi::ConstantInitialized)
  : name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , time_(0){}
struct TimingEntryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TimingEntryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TimingEntryDefaultTypeInternal() {}
  union {
    TimingEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TimingEntryDefaultTypeInternal _TimingEntry_default_instance_;
PROTOBUF_CONSTEXPR TimingInfo::TimingInfo(
    ::_pbi::ConstantInitialized)
  : other_times_()
  , markup_parsing_time_(0)
  , document_construction_time_(0)
  , article_processing_time_(0)
  , formatting_time_(0)
  , total_time_(0){}
struct TimingInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TimingInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TimingInfoDefaultTypeInternal() {}
  union {
    TimingInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TimingInfoDefaultTypeInternal _TimingInfo_default_instance_;
PROTOBUF_CONSTEXPR DebugInfo::DebugInfo(
    ::_pbi::ConstantInitialized)
  : log_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct DebugInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DebugInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DebugInfoDefaultTypeInternal() {}
  union {
    DebugInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DebugInfoDefaultTypeInternal _DebugInfo_default_instance_;
PROTOBUF_CONSTEXPR StatisticsInfo::StatisticsInfo(
    ::_pbi::ConstantInitialized)
  : word_count_(0){}
struct StatisticsInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatisticsInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatisticsInfoDefaultTypeInternal() {}
  union {
    StatisticsInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatisticsInfoDefaultTypeInternal _StatisticsInfo_default_instance_;
PROTOBUF_CONSTEXPR DomDistillerResult_ContentImage::DomDistillerResult_ContentImage(
    ::_pbi::ConstantInitialized)
  : url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct DomDistillerResult_ContentImageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DomDistillerResult_ContentImageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DomDistillerResult_ContentImageDefaultTypeInternal() {}
  union {
    DomDistillerResult_ContentImage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DomDistillerResult_ContentImageDefaultTypeInternal _DomDistillerResult_ContentImage_default_instance_;
PROTOBUF_CONSTEXPR DomDistillerResult::DomDistillerResult(
    ::_pbi::ConstantInitialized)
  : content_images_()
  , title_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , text_direction_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , distilled_content_(nullptr)
  , pagination_info_(nullptr)
  , markup_info_(nullptr)
  , timing_info_(nullptr)
  , debug_info_(nullptr)
  , statistics_info_(nullptr){}
struct DomDistillerResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DomDistillerResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DomDistillerResultDefaultTypeInternal() {}
  union {
    DomDistillerResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DomDistillerResultDefaultTypeInternal _DomDistillerResult_default_instance_;
PROTOBUF_CONSTEXPR DomDistillerOptions::DomDistillerOptions(
    ::_pbi::ConstantInitialized)
  : original_url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , pagination_algo_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , extract_text_only_(false)
  , debug_level_(0){}
struct DomDistillerOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DomDistillerOptionsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DomDistillerOptionsDefaultTypeInternal() {}
  union {
    DomDistillerOptions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DomDistillerOptionsDefaultTypeInternal _DomDistillerOptions_default_instance_;
}  // namespace proto
}  // namespace dom_distiller
namespace dom_distiller {
namespace proto {

// ===================================================================

class DistilledContent::_Internal {
 public:
  using HasBits = decltype(std::declval<DistilledContent>()._has_bits_);
  static void set_has_html(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DistilledContent::DistilledContent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:dom_distiller.proto.DistilledContent)
}
DistilledContent::DistilledContent(const DistilledContent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  html_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    html_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_html()) {
    html_.Set(from._internal_html(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:dom_distiller.proto.DistilledContent)
}

inline void DistilledContent::SharedCtor() {
html_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  html_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DistilledContent::~DistilledContent() {
  // @@protoc_insertion_point(destructor:dom_distiller.proto.DistilledContent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DistilledContent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  html_.Destroy();
}

void DistilledContent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DistilledContent::Clear() {
// @@protoc_insertion_point(message_clear_start:dom_distiller.proto.DistilledContent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    html_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DistilledContent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string html = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_html();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DistilledContent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dom_distiller.proto.DistilledContent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string html = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_html(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dom_distiller.proto.DistilledContent)
  return target;
}

size_t DistilledContent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dom_distiller.proto.DistilledContent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string html = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_html());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DistilledContent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DistilledContent*>(
      &from));
}

void DistilledContent::MergeFrom(const DistilledContent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dom_distiller.proto.DistilledContent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_html()) {
    _internal_set_html(from._internal_html());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DistilledContent::CopyFrom(const DistilledContent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dom_distiller.proto.DistilledContent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DistilledContent::IsInitialized() const {
  return true;
}

void DistilledContent::InternalSwap(DistilledContent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &html_, lhs_arena,
      &other->html_, rhs_arena
  );
}

std::string DistilledContent::GetTypeName() const {
  return "dom_distiller.proto.DistilledContent";
}


// ===================================================================

class PaginationInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<PaginationInfo>()._has_bits_);
  static void set_has_next_page(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_prev_page(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_canonical_page(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

PaginationInfo::PaginationInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:dom_distiller.proto.PaginationInfo)
}
PaginationInfo::PaginationInfo(const PaginationInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  next_page_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    next_page_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_next_page()) {
    next_page_.Set(from._internal_next_page(), 
      GetArenaForAllocation());
  }
  prev_page_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    prev_page_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_prev_page()) {
    prev_page_.Set(from._internal_prev_page(), 
      GetArenaForAllocation());
  }
  canonical_page_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    canonical_page_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_canonical_page()) {
    canonical_page_.Set(from._internal_canonical_page(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:dom_distiller.proto.PaginationInfo)
}

inline void PaginationInfo::SharedCtor() {
next_page_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  next_page_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
prev_page_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  prev_page_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
canonical_page_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  canonical_page_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PaginationInfo::~PaginationInfo() {
  // @@protoc_insertion_point(destructor:dom_distiller.proto.PaginationInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PaginationInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  next_page_.Destroy();
  prev_page_.Destroy();
  canonical_page_.Destroy();
}

void PaginationInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PaginationInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:dom_distiller.proto.PaginationInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      next_page_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      prev_page_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      canonical_page_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PaginationInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string next_page = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_next_page();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string prev_page = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_prev_page();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string canonical_page = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_canonical_page();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PaginationInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dom_distiller.proto.PaginationInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string next_page = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_next_page(), target);
  }

  // optional string prev_page = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_prev_page(), target);
  }

  // optional string canonical_page = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_canonical_page(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dom_distiller.proto.PaginationInfo)
  return target;
}

size_t PaginationInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dom_distiller.proto.PaginationInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string next_page = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_next_page());
    }

    // optional string prev_page = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_prev_page());
    }

    // optional string canonical_page = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_canonical_page());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PaginationInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PaginationInfo*>(
      &from));
}

void PaginationInfo::MergeFrom(const PaginationInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dom_distiller.proto.PaginationInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_next_page(from._internal_next_page());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_prev_page(from._internal_prev_page());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_canonical_page(from._internal_canonical_page());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PaginationInfo::CopyFrom(const PaginationInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dom_distiller.proto.PaginationInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PaginationInfo::IsInitialized() const {
  return true;
}

void PaginationInfo::InternalSwap(PaginationInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &next_page_, lhs_arena,
      &other->next_page_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &prev_page_, lhs_arena,
      &other->prev_page_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &canonical_page_, lhs_arena,
      &other->canonical_page_, rhs_arena
  );
}

std::string PaginationInfo::GetTypeName() const {
  return "dom_distiller.proto.PaginationInfo";
}


// ===================================================================

class MarkupArticle::_Internal {
 public:
  using HasBits = decltype(std::declval<MarkupArticle>()._has_bits_);
  static void set_has_published_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_modified_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_expiration_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_section(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

MarkupArticle::MarkupArticle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  authors_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:dom_distiller.proto.MarkupArticle)
}
MarkupArticle::MarkupArticle(const MarkupArticle& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      authors_(from.authors_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  published_time_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    published_time_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_published_time()) {
    published_time_.Set(from._internal_published_time(), 
      GetArenaForAllocation());
  }
  modified_time_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    modified_time_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_modified_time()) {
    modified_time_.Set(from._internal_modified_time(), 
      GetArenaForAllocation());
  }
  expiration_time_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    expiration_time_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_expiration_time()) {
    expiration_time_.Set(from._internal_expiration_time(), 
      GetArenaForAllocation());
  }
  section_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    section_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_section()) {
    section_.Set(from._internal_section(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:dom_distiller.proto.MarkupArticle)
}

inline void MarkupArticle::SharedCtor() {
published_time_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  published_time_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
modified_time_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  modified_time_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
expiration_time_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  expiration_time_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
section_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  section_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MarkupArticle::~MarkupArticle() {
  // @@protoc_insertion_point(destructor:dom_distiller.proto.MarkupArticle)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MarkupArticle::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  published_time_.Destroy();
  modified_time_.Destroy();
  expiration_time_.Destroy();
  section_.Destroy();
}

void MarkupArticle::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MarkupArticle::Clear() {
// @@protoc_insertion_point(message_clear_start:dom_distiller.proto.MarkupArticle)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  authors_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      published_time_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      modified_time_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      expiration_time_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      section_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MarkupArticle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string published_time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_published_time();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string modified_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_modified_time();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string expiration_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_expiration_time();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string section = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_section();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string authors = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_authors();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MarkupArticle::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dom_distiller.proto.MarkupArticle)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string published_time = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_published_time(), target);
  }

  // optional string modified_time = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_modified_time(), target);
  }

  // optional string expiration_time = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_expiration_time(), target);
  }

  // optional string section = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_section(), target);
  }

  // repeated string authors = 5;
  for (int i = 0, n = this->_internal_authors_size(); i < n; i++) {
    const auto& s = this->_internal_authors(i);
    target = stream->WriteString(5, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dom_distiller.proto.MarkupArticle)
  return target;
}

size_t MarkupArticle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dom_distiller.proto.MarkupArticle)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string authors = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(authors_.size());
  for (int i = 0, n = authors_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      authors_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string published_time = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_published_time());
    }

    // optional string modified_time = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_modified_time());
    }

    // optional string expiration_time = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_expiration_time());
    }

    // optional string section = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_section());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MarkupArticle::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MarkupArticle*>(
      &from));
}

void MarkupArticle::MergeFrom(const MarkupArticle& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dom_distiller.proto.MarkupArticle)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  authors_.MergeFrom(from.authors_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_published_time(from._internal_published_time());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_modified_time(from._internal_modified_time());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_expiration_time(from._internal_expiration_time());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_section(from._internal_section());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MarkupArticle::CopyFrom(const MarkupArticle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dom_distiller.proto.MarkupArticle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MarkupArticle::IsInitialized() const {
  return true;
}

void MarkupArticle::InternalSwap(MarkupArticle* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  authors_.InternalSwap(&other->authors_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &published_time_, lhs_arena,
      &other->published_time_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &modified_time_, lhs_arena,
      &other->modified_time_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &expiration_time_, lhs_arena,
      &other->expiration_time_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &section_, lhs_arena,
      &other->section_, rhs_arena
  );
}

std::string MarkupArticle::GetTypeName() const {
  return "dom_distiller.proto.MarkupArticle";
}


// ===================================================================

class MarkupImage::_Internal {
 public:
  using HasBits = decltype(std::declval<MarkupImage>()._has_bits_);
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_secure_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_caption(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

MarkupImage::MarkupImage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:dom_distiller.proto.MarkupImage)
}
MarkupImage::MarkupImage(const MarkupImage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    url_.Set(from._internal_url(), 
      GetArenaForAllocation());
  }
  secure_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    secure_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_secure_url()) {
    secure_url_.Set(from._internal_secure_url(), 
      GetArenaForAllocation());
  }
  type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    type_.Set(from._internal_type(), 
      GetArenaForAllocation());
  }
  caption_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    caption_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_caption()) {
    caption_.Set(from._internal_caption(), 
      GetArenaForAllocation());
  }
  ::memcpy(&width_, &from.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&width_)) + sizeof(height_));
  // @@protoc_insertion_point(copy_constructor:dom_distiller.proto.MarkupImage)
}

inline void MarkupImage::SharedCtor() {
url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
secure_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  secure_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
caption_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  caption_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&width_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&width_)) + sizeof(height_));
}

MarkupImage::~MarkupImage() {
  // @@protoc_insertion_point(destructor:dom_distiller.proto.MarkupImage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MarkupImage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  url_.Destroy();
  secure_url_.Destroy();
  type_.Destroy();
  caption_.Destroy();
}

void MarkupImage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MarkupImage::Clear() {
// @@protoc_insertion_point(message_clear_start:dom_distiller.proto.MarkupImage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      secure_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      caption_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&height_) -
        reinterpret_cast<char*>(&width_)) + sizeof(height_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MarkupImage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string secure_url = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_secure_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string caption = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_caption();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 width = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_width(&has_bits);
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 height = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_height(&has_bits);
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MarkupImage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dom_distiller.proto.MarkupImage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url(), target);
  }

  // optional string secure_url = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_secure_url(), target);
  }

  // optional string type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_type(), target);
  }

  // optional string caption = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_caption(), target);
  }

  // optional int32 width = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_width(), target);
  }

  // optional int32 height = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dom_distiller.proto.MarkupImage)
  return target;
}

size_t MarkupImage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dom_distiller.proto.MarkupImage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

    // optional string secure_url = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_secure_url());
    }

    // optional string type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_type());
    }

    // optional string caption = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_caption());
    }

    // optional int32 width = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_width());
    }

    // optional int32 height = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_height());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MarkupImage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MarkupImage*>(
      &from));
}

void MarkupImage::MergeFrom(const MarkupImage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dom_distiller.proto.MarkupImage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_secure_url(from._internal_secure_url());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_caption(from._internal_caption());
    }
    if (cached_has_bits & 0x00000010u) {
      width_ = from.width_;
    }
    if (cached_has_bits & 0x00000020u) {
      height_ = from.height_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MarkupImage::CopyFrom(const MarkupImage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dom_distiller.proto.MarkupImage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MarkupImage::IsInitialized() const {
  return true;
}

void MarkupImage::InternalSwap(MarkupImage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &url_, lhs_arena,
      &other->url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &secure_url_, lhs_arena,
      &other->secure_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &type_, lhs_arena,
      &other->type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &caption_, lhs_arena,
      &other->caption_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MarkupImage, height_)
      + sizeof(MarkupImage::height_)
      - PROTOBUF_FIELD_OFFSET(MarkupImage, width_)>(
          reinterpret_cast<char*>(&width_),
          reinterpret_cast<char*>(&other->width_));
}

std::string MarkupImage::GetTypeName() const {
  return "dom_distiller.proto.MarkupImage";
}


// ===================================================================

class MarkupInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<MarkupInfo>()._has_bits_);
  static void set_has_title(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_publisher(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_copyright(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_author(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::dom_distiller::proto::MarkupArticle& article(const MarkupInfo* msg);
  static void set_has_article(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::dom_distiller::proto::MarkupArticle&
MarkupInfo::_Internal::article(const MarkupInfo* msg) {
  return *msg->article_;
}
MarkupInfo::MarkupInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  images_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:dom_distiller.proto.MarkupInfo)
}
MarkupInfo::MarkupInfo(const MarkupInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      images_(from.images_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_title()) {
    title_.Set(from._internal_title(), 
      GetArenaForAllocation());
  }
  type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    type_.Set(from._internal_type(), 
      GetArenaForAllocation());
  }
  url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    url_.Set(from._internal_url(), 
      GetArenaForAllocation());
  }
  description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description()) {
    description_.Set(from._internal_description(), 
      GetArenaForAllocation());
  }
  publisher_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    publisher_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_publisher()) {
    publisher_.Set(from._internal_publisher(), 
      GetArenaForAllocation());
  }
  copyright_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    copyright_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_copyright()) {
    copyright_.Set(from._internal_copyright(), 
      GetArenaForAllocation());
  }
  author_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    author_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_author()) {
    author_.Set(from._internal_author(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_article()) {
    article_ = new ::dom_distiller::proto::MarkupArticle(*from.article_);
  } else {
    article_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:dom_distiller.proto.MarkupInfo)
}

inline void MarkupInfo::SharedCtor() {
title_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  title_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
description_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  description_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
publisher_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  publisher_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
copyright_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  copyright_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
author_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  author_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
article_ = nullptr;
}

MarkupInfo::~MarkupInfo() {
  // @@protoc_insertion_point(destructor:dom_distiller.proto.MarkupInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MarkupInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  title_.Destroy();
  type_.Destroy();
  url_.Destroy();
  description_.Destroy();
  publisher_.Destroy();
  copyright_.Destroy();
  author_.Destroy();
  if (this != internal_default_instance()) delete article_;
}

void MarkupInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MarkupInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:dom_distiller.proto.MarkupInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  images_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      title_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      publisher_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      copyright_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      author_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(article_ != nullptr);
      article_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MarkupInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string title = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string url = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string description = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string publisher = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_publisher();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string copyright = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_copyright();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string author = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_author();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .dom_distiller.proto.MarkupArticle article = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_article(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .dom_distiller.proto.MarkupImage images = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_images(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MarkupInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dom_distiller.proto.MarkupInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string title = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_title(), target);
  }

  // optional string type = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_type(), target);
  }

  // optional string url = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_url(), target);
  }

  // optional string description = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_description(), target);
  }

  // optional string publisher = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_publisher(), target);
  }

  // optional string copyright = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_copyright(), target);
  }

  // optional string author = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_author(), target);
  }

  // optional .dom_distiller.proto.MarkupArticle article = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::article(this),
        _Internal::article(this).GetCachedSize(), target, stream);
  }

  // repeated .dom_distiller.proto.MarkupImage images = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_images_size()); i < n; i++) {
    const auto& repfield = this->_internal_images(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dom_distiller.proto.MarkupInfo)
  return target;
}

size_t MarkupInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dom_distiller.proto.MarkupInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .dom_distiller.proto.MarkupImage images = 9;
  total_size += 1UL * this->_internal_images_size();
  for (const auto& msg : this->images_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string title = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_title());
    }

    // optional string type = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_type());
    }

    // optional string url = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_url());
    }

    // optional string description = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description());
    }

    // optional string publisher = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_publisher());
    }

    // optional string copyright = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_copyright());
    }

    // optional string author = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_author());
    }

    // optional .dom_distiller.proto.MarkupArticle article = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *article_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MarkupInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MarkupInfo*>(
      &from));
}

void MarkupInfo::MergeFrom(const MarkupInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dom_distiller.proto.MarkupInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  images_.MergeFrom(from.images_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_title(from._internal_title());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_publisher(from._internal_publisher());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_copyright(from._internal_copyright());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_author(from._internal_author());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_article()->::dom_distiller::proto::MarkupArticle::MergeFrom(from._internal_article());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MarkupInfo::CopyFrom(const MarkupInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dom_distiller.proto.MarkupInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MarkupInfo::IsInitialized() const {
  return true;
}

void MarkupInfo::InternalSwap(MarkupInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  images_.InternalSwap(&other->images_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &title_, lhs_arena,
      &other->title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &type_, lhs_arena,
      &other->type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &url_, lhs_arena,
      &other->url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &description_, lhs_arena,
      &other->description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &publisher_, lhs_arena,
      &other->publisher_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &copyright_, lhs_arena,
      &other->copyright_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &author_, lhs_arena,
      &other->author_, rhs_arena
  );
  swap(article_, other->article_);
}

std::string MarkupInfo::GetTypeName() const {
  return "dom_distiller.proto.MarkupInfo";
}


// ===================================================================

class TimingEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<TimingEntry>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

TimingEntry::TimingEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:dom_distiller.proto.TimingEntry)
}
TimingEntry::TimingEntry(const TimingEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  time_ = from.time_;
  // @@protoc_insertion_point(copy_constructor:dom_distiller.proto.TimingEntry)
}

inline void TimingEntry::SharedCtor() {
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
time_ = 0;
}

TimingEntry::~TimingEntry() {
  // @@protoc_insertion_point(destructor:dom_distiller.proto.TimingEntry)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TimingEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.Destroy();
}

void TimingEntry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TimingEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:dom_distiller.proto.TimingEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  time_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TimingEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_time(&has_bits);
          time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TimingEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dom_distiller.proto.TimingEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional double time = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dom_distiller.proto.TimingEntry)
  return target;
}

size_t TimingEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dom_distiller.proto.TimingEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional double time = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TimingEntry::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TimingEntry*>(
      &from));
}

void TimingEntry::MergeFrom(const TimingEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dom_distiller.proto.TimingEntry)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      time_ = from.time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TimingEntry::CopyFrom(const TimingEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dom_distiller.proto.TimingEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimingEntry::IsInitialized() const {
  return true;
}

void TimingEntry::InternalSwap(TimingEntry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  swap(time_, other->time_);
}

std::string TimingEntry::GetTypeName() const {
  return "dom_distiller.proto.TimingEntry";
}


// ===================================================================

class TimingInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TimingInfo>()._has_bits_);
  static void set_has_markup_parsing_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_document_construction_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_article_processing_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_formatting_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_total_time(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

TimingInfo::TimingInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  other_times_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:dom_distiller.proto.TimingInfo)
}
TimingInfo::TimingInfo(const TimingInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      other_times_(from.other_times_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&markup_parsing_time_, &from.markup_parsing_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&total_time_) -
    reinterpret_cast<char*>(&markup_parsing_time_)) + sizeof(total_time_));
  // @@protoc_insertion_point(copy_constructor:dom_distiller.proto.TimingInfo)
}

inline void TimingInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&markup_parsing_time_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&total_time_) -
    reinterpret_cast<char*>(&markup_parsing_time_)) + sizeof(total_time_));
}

TimingInfo::~TimingInfo() {
  // @@protoc_insertion_point(destructor:dom_distiller.proto.TimingInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TimingInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TimingInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TimingInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:dom_distiller.proto.TimingInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  other_times_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&markup_parsing_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&total_time_) -
        reinterpret_cast<char*>(&markup_parsing_time_)) + sizeof(total_time_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TimingInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double markup_parsing_time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_markup_parsing_time(&has_bits);
          markup_parsing_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double document_construction_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_document_construction_time(&has_bits);
          document_construction_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double article_processing_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_article_processing_time(&has_bits);
          article_processing_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double formatting_time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_formatting_time(&has_bits);
          formatting_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double total_time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_total_time(&has_bits);
          total_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated .dom_distiller.proto.TimingEntry other_times = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_other_times(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TimingInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dom_distiller.proto.TimingInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional double markup_parsing_time = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_markup_parsing_time(), target);
  }

  // optional double document_construction_time = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_document_construction_time(), target);
  }

  // optional double article_processing_time = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_article_processing_time(), target);
  }

  // optional double formatting_time = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_formatting_time(), target);
  }

  // optional double total_time = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_total_time(), target);
  }

  // repeated .dom_distiller.proto.TimingEntry other_times = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_other_times_size()); i < n; i++) {
    const auto& repfield = this->_internal_other_times(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dom_distiller.proto.TimingInfo)
  return target;
}

size_t TimingInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dom_distiller.proto.TimingInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .dom_distiller.proto.TimingEntry other_times = 6;
  total_size += 1UL * this->_internal_other_times_size();
  for (const auto& msg : this->other_times_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional double markup_parsing_time = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double document_construction_time = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double article_processing_time = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional double formatting_time = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional double total_time = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 8;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TimingInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TimingInfo*>(
      &from));
}

void TimingInfo::MergeFrom(const TimingInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dom_distiller.proto.TimingInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  other_times_.MergeFrom(from.other_times_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      markup_parsing_time_ = from.markup_parsing_time_;
    }
    if (cached_has_bits & 0x00000002u) {
      document_construction_time_ = from.document_construction_time_;
    }
    if (cached_has_bits & 0x00000004u) {
      article_processing_time_ = from.article_processing_time_;
    }
    if (cached_has_bits & 0x00000008u) {
      formatting_time_ = from.formatting_time_;
    }
    if (cached_has_bits & 0x00000010u) {
      total_time_ = from.total_time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TimingInfo::CopyFrom(const TimingInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dom_distiller.proto.TimingInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimingInfo::IsInitialized() const {
  return true;
}

void TimingInfo::InternalSwap(TimingInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  other_times_.InternalSwap(&other->other_times_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TimingInfo, total_time_)
      + sizeof(TimingInfo::total_time_)
      - PROTOBUF_FIELD_OFFSET(TimingInfo, markup_parsing_time_)>(
          reinterpret_cast<char*>(&markup_parsing_time_),
          reinterpret_cast<char*>(&other->markup_parsing_time_));
}

std::string TimingInfo::GetTypeName() const {
  return "dom_distiller.proto.TimingInfo";
}


// ===================================================================

class DebugInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<DebugInfo>()._has_bits_);
  static void set_has_log(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DebugInfo::DebugInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:dom_distiller.proto.DebugInfo)
}
DebugInfo::DebugInfo(const DebugInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  log_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    log_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_log()) {
    log_.Set(from._internal_log(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:dom_distiller.proto.DebugInfo)
}

inline void DebugInfo::SharedCtor() {
log_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  log_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DebugInfo::~DebugInfo() {
  // @@protoc_insertion_point(destructor:dom_distiller.proto.DebugInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DebugInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  log_.Destroy();
}

void DebugInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DebugInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:dom_distiller.proto.DebugInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    log_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DebugInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string log = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_log();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DebugInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dom_distiller.proto.DebugInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string log = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_log(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dom_distiller.proto.DebugInfo)
  return target;
}

size_t DebugInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dom_distiller.proto.DebugInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string log = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_log());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DebugInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DebugInfo*>(
      &from));
}

void DebugInfo::MergeFrom(const DebugInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dom_distiller.proto.DebugInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_log()) {
    _internal_set_log(from._internal_log());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DebugInfo::CopyFrom(const DebugInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dom_distiller.proto.DebugInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DebugInfo::IsInitialized() const {
  return true;
}

void DebugInfo::InternalSwap(DebugInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &log_, lhs_arena,
      &other->log_, rhs_arena
  );
}

std::string DebugInfo::GetTypeName() const {
  return "dom_distiller.proto.DebugInfo";
}


// ===================================================================

class StatisticsInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<StatisticsInfo>()._has_bits_);
  static void set_has_word_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

StatisticsInfo::StatisticsInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:dom_distiller.proto.StatisticsInfo)
}
StatisticsInfo::StatisticsInfo(const StatisticsInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  word_count_ = from.word_count_;
  // @@protoc_insertion_point(copy_constructor:dom_distiller.proto.StatisticsInfo)
}

inline void StatisticsInfo::SharedCtor() {
word_count_ = 0;
}

StatisticsInfo::~StatisticsInfo() {
  // @@protoc_insertion_point(destructor:dom_distiller.proto.StatisticsInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatisticsInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StatisticsInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StatisticsInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:dom_distiller.proto.StatisticsInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  word_count_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* StatisticsInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 word_count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_word_count(&has_bits);
          word_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatisticsInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dom_distiller.proto.StatisticsInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 word_count = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_word_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dom_distiller.proto.StatisticsInfo)
  return target;
}

size_t StatisticsInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dom_distiller.proto.StatisticsInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 word_count = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_word_count());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StatisticsInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const StatisticsInfo*>(
      &from));
}

void StatisticsInfo::MergeFrom(const StatisticsInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dom_distiller.proto.StatisticsInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_word_count()) {
    _internal_set_word_count(from._internal_word_count());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StatisticsInfo::CopyFrom(const StatisticsInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dom_distiller.proto.StatisticsInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatisticsInfo::IsInitialized() const {
  return true;
}

void StatisticsInfo::InternalSwap(StatisticsInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(word_count_, other->word_count_);
}

std::string StatisticsInfo::GetTypeName() const {
  return "dom_distiller.proto.StatisticsInfo";
}


// ===================================================================

class DomDistillerResult_ContentImage::_Internal {
 public:
  using HasBits = decltype(std::declval<DomDistillerResult_ContentImage>()._has_bits_);
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DomDistillerResult_ContentImage::DomDistillerResult_ContentImage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:dom_distiller.proto.DomDistillerResult.ContentImage)
}
DomDistillerResult_ContentImage::DomDistillerResult_ContentImage(const DomDistillerResult_ContentImage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_url()) {
    url_.Set(from._internal_url(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:dom_distiller.proto.DomDistillerResult.ContentImage)
}

inline void DomDistillerResult_ContentImage::SharedCtor() {
url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DomDistillerResult_ContentImage::~DomDistillerResult_ContentImage() {
  // @@protoc_insertion_point(destructor:dom_distiller.proto.DomDistillerResult.ContentImage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DomDistillerResult_ContentImage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  url_.Destroy();
}

void DomDistillerResult_ContentImage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DomDistillerResult_ContentImage::Clear() {
// @@protoc_insertion_point(message_clear_start:dom_distiller.proto.DomDistillerResult.ContentImage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    url_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DomDistillerResult_ContentImage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DomDistillerResult_ContentImage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dom_distiller.proto.DomDistillerResult.ContentImage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string url = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dom_distiller.proto.DomDistillerResult.ContentImage)
  return target;
}

size_t DomDistillerResult_ContentImage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dom_distiller.proto.DomDistillerResult.ContentImage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string url = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DomDistillerResult_ContentImage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DomDistillerResult_ContentImage*>(
      &from));
}

void DomDistillerResult_ContentImage::MergeFrom(const DomDistillerResult_ContentImage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dom_distiller.proto.DomDistillerResult.ContentImage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_url()) {
    _internal_set_url(from._internal_url());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DomDistillerResult_ContentImage::CopyFrom(const DomDistillerResult_ContentImage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dom_distiller.proto.DomDistillerResult.ContentImage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DomDistillerResult_ContentImage::IsInitialized() const {
  return true;
}

void DomDistillerResult_ContentImage::InternalSwap(DomDistillerResult_ContentImage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &url_, lhs_arena,
      &other->url_, rhs_arena
  );
}

std::string DomDistillerResult_ContentImage::GetTypeName() const {
  return "dom_distiller.proto.DomDistillerResult.ContentImage";
}


// ===================================================================

class DomDistillerResult::_Internal {
 public:
  using HasBits = decltype(std::declval<DomDistillerResult>()._has_bits_);
  static void set_has_title(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::dom_distiller::proto::DistilledContent& distilled_content(const DomDistillerResult* msg);
  static void set_has_distilled_content(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::dom_distiller::proto::PaginationInfo& pagination_info(const DomDistillerResult* msg);
  static void set_has_pagination_info(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::dom_distiller::proto::MarkupInfo& markup_info(const DomDistillerResult* msg);
  static void set_has_markup_info(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::dom_distiller::proto::TimingInfo& timing_info(const DomDistillerResult* msg);
  static void set_has_timing_info(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::dom_distiller::proto::DebugInfo& debug_info(const DomDistillerResult* msg);
  static void set_has_debug_info(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::dom_distiller::proto::StatisticsInfo& statistics_info(const DomDistillerResult* msg);
  static void set_has_statistics_info(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_text_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::dom_distiller::proto::DistilledContent&
DomDistillerResult::_Internal::distilled_content(const DomDistillerResult* msg) {
  return *msg->distilled_content_;
}
const ::dom_distiller::proto::PaginationInfo&
DomDistillerResult::_Internal::pagination_info(const DomDistillerResult* msg) {
  return *msg->pagination_info_;
}
const ::dom_distiller::proto::MarkupInfo&
DomDistillerResult::_Internal::markup_info(const DomDistillerResult* msg) {
  return *msg->markup_info_;
}
const ::dom_distiller::proto::TimingInfo&
DomDistillerResult::_Internal::timing_info(const DomDistillerResult* msg) {
  return *msg->timing_info_;
}
const ::dom_distiller::proto::DebugInfo&
DomDistillerResult::_Internal::debug_info(const DomDistillerResult* msg) {
  return *msg->debug_info_;
}
const ::dom_distiller::proto::StatisticsInfo&
DomDistillerResult::_Internal::statistics_info(const DomDistillerResult* msg) {
  return *msg->statistics_info_;
}
DomDistillerResult::DomDistillerResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  content_images_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:dom_distiller.proto.DomDistillerResult)
}
DomDistillerResult::DomDistillerResult(const DomDistillerResult& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      content_images_(from.content_images_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_title()) {
    title_.Set(from._internal_title(), 
      GetArenaForAllocation());
  }
  text_direction_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    text_direction_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_text_direction()) {
    text_direction_.Set(from._internal_text_direction(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_distilled_content()) {
    distilled_content_ = new ::dom_distiller::proto::DistilledContent(*from.distilled_content_);
  } else {
    distilled_content_ = nullptr;
  }
  if (from._internal_has_pagination_info()) {
    pagination_info_ = new ::dom_distiller::proto::PaginationInfo(*from.pagination_info_);
  } else {
    pagination_info_ = nullptr;
  }
  if (from._internal_has_markup_info()) {
    markup_info_ = new ::dom_distiller::proto::MarkupInfo(*from.markup_info_);
  } else {
    markup_info_ = nullptr;
  }
  if (from._internal_has_timing_info()) {
    timing_info_ = new ::dom_distiller::proto::TimingInfo(*from.timing_info_);
  } else {
    timing_info_ = nullptr;
  }
  if (from._internal_has_debug_info()) {
    debug_info_ = new ::dom_distiller::proto::DebugInfo(*from.debug_info_);
  } else {
    debug_info_ = nullptr;
  }
  if (from._internal_has_statistics_info()) {
    statistics_info_ = new ::dom_distiller::proto::StatisticsInfo(*from.statistics_info_);
  } else {
    statistics_info_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:dom_distiller.proto.DomDistillerResult)
}

inline void DomDistillerResult::SharedCtor() {
title_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  title_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
text_direction_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  text_direction_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&distilled_content_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&statistics_info_) -
    reinterpret_cast<char*>(&distilled_content_)) + sizeof(statistics_info_));
}

DomDistillerResult::~DomDistillerResult() {
  // @@protoc_insertion_point(destructor:dom_distiller.proto.DomDistillerResult)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DomDistillerResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  title_.Destroy();
  text_direction_.Destroy();
  if (this != internal_default_instance()) delete distilled_content_;
  if (this != internal_default_instance()) delete pagination_info_;
  if (this != internal_default_instance()) delete markup_info_;
  if (this != internal_default_instance()) delete timing_info_;
  if (this != internal_default_instance()) delete debug_info_;
  if (this != internal_default_instance()) delete statistics_info_;
}

void DomDistillerResult::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DomDistillerResult::Clear() {
// @@protoc_insertion_point(message_clear_start:dom_distiller.proto.DomDistillerResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  content_images_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      title_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      text_direction_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(distilled_content_ != nullptr);
      distilled_content_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(pagination_info_ != nullptr);
      pagination_info_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(markup_info_ != nullptr);
      markup_info_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(timing_info_ != nullptr);
      timing_info_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(debug_info_ != nullptr);
      debug_info_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(statistics_info_ != nullptr);
      statistics_info_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DomDistillerResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string title = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .dom_distiller.proto.DistilledContent distilled_content = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_distilled_content(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .dom_distiller.proto.PaginationInfo pagination_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_pagination_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .dom_distiller.proto.MarkupInfo markup_info = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_markup_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .dom_distiller.proto.TimingInfo timing_info = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_timing_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .dom_distiller.proto.DebugInfo debug_info = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_debug_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .dom_distiller.proto.StatisticsInfo statistics_info = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_statistics_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string text_direction = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_text_direction();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .dom_distiller.proto.DomDistillerResult.ContentImage content_images = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_content_images(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DomDistillerResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dom_distiller.proto.DomDistillerResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string title = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_title(), target);
  }

  // optional .dom_distiller.proto.DistilledContent distilled_content = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::distilled_content(this),
        _Internal::distilled_content(this).GetCachedSize(), target, stream);
  }

  // optional .dom_distiller.proto.PaginationInfo pagination_info = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::pagination_info(this),
        _Internal::pagination_info(this).GetCachedSize(), target, stream);
  }

  // optional .dom_distiller.proto.MarkupInfo markup_info = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::markup_info(this),
        _Internal::markup_info(this).GetCachedSize(), target, stream);
  }

  // optional .dom_distiller.proto.TimingInfo timing_info = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::timing_info(this),
        _Internal::timing_info(this).GetCachedSize(), target, stream);
  }

  // optional .dom_distiller.proto.DebugInfo debug_info = 7;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::debug_info(this),
        _Internal::debug_info(this).GetCachedSize(), target, stream);
  }

  // optional .dom_distiller.proto.StatisticsInfo statistics_info = 8;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::statistics_info(this),
        _Internal::statistics_info(this).GetCachedSize(), target, stream);
  }

  // optional string text_direction = 9;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_text_direction(), target);
  }

  // repeated .dom_distiller.proto.DomDistillerResult.ContentImage content_images = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_content_images_size()); i < n; i++) {
    const auto& repfield = this->_internal_content_images(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dom_distiller.proto.DomDistillerResult)
  return target;
}

size_t DomDistillerResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dom_distiller.proto.DomDistillerResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .dom_distiller.proto.DomDistillerResult.ContentImage content_images = 10;
  total_size += 1UL * this->_internal_content_images_size();
  for (const auto& msg : this->content_images_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string title = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_title());
    }

    // optional string text_direction = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_text_direction());
    }

    // optional .dom_distiller.proto.DistilledContent distilled_content = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *distilled_content_);
    }

    // optional .dom_distiller.proto.PaginationInfo pagination_info = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *pagination_info_);
    }

    // optional .dom_distiller.proto.MarkupInfo markup_info = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *markup_info_);
    }

    // optional .dom_distiller.proto.TimingInfo timing_info = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *timing_info_);
    }

    // optional .dom_distiller.proto.DebugInfo debug_info = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *debug_info_);
    }

    // optional .dom_distiller.proto.StatisticsInfo statistics_info = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *statistics_info_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DomDistillerResult::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DomDistillerResult*>(
      &from));
}

void DomDistillerResult::MergeFrom(const DomDistillerResult& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dom_distiller.proto.DomDistillerResult)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  content_images_.MergeFrom(from.content_images_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_title(from._internal_title());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_text_direction(from._internal_text_direction());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_distilled_content()->::dom_distiller::proto::DistilledContent::MergeFrom(from._internal_distilled_content());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_pagination_info()->::dom_distiller::proto::PaginationInfo::MergeFrom(from._internal_pagination_info());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_markup_info()->::dom_distiller::proto::MarkupInfo::MergeFrom(from._internal_markup_info());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_timing_info()->::dom_distiller::proto::TimingInfo::MergeFrom(from._internal_timing_info());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_debug_info()->::dom_distiller::proto::DebugInfo::MergeFrom(from._internal_debug_info());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_statistics_info()->::dom_distiller::proto::StatisticsInfo::MergeFrom(from._internal_statistics_info());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DomDistillerResult::CopyFrom(const DomDistillerResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dom_distiller.proto.DomDistillerResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DomDistillerResult::IsInitialized() const {
  return true;
}

void DomDistillerResult::InternalSwap(DomDistillerResult* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  content_images_.InternalSwap(&other->content_images_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &title_, lhs_arena,
      &other->title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &text_direction_, lhs_arena,
      &other->text_direction_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DomDistillerResult, statistics_info_)
      + sizeof(DomDistillerResult::statistics_info_)
      - PROTOBUF_FIELD_OFFSET(DomDistillerResult, distilled_content_)>(
          reinterpret_cast<char*>(&distilled_content_),
          reinterpret_cast<char*>(&other->distilled_content_));
}

std::string DomDistillerResult::GetTypeName() const {
  return "dom_distiller.proto.DomDistillerResult";
}


// ===================================================================

class DomDistillerOptions::_Internal {
 public:
  using HasBits = decltype(std::declval<DomDistillerOptions>()._has_bits_);
  static void set_has_extract_text_only(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_debug_level(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_original_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pagination_algo(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

DomDistillerOptions::DomDistillerOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:dom_distiller.proto.DomDistillerOptions)
}
DomDistillerOptions::DomDistillerOptions(const DomDistillerOptions& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  original_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    original_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_original_url()) {
    original_url_.Set(from._internal_original_url(), 
      GetArenaForAllocation());
  }
  pagination_algo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    pagination_algo_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pagination_algo()) {
    pagination_algo_.Set(from._internal_pagination_algo(), 
      GetArenaForAllocation());
  }
  ::memcpy(&extract_text_only_, &from.extract_text_only_,
    static_cast<size_t>(reinterpret_cast<char*>(&debug_level_) -
    reinterpret_cast<char*>(&extract_text_only_)) + sizeof(debug_level_));
  // @@protoc_insertion_point(copy_constructor:dom_distiller.proto.DomDistillerOptions)
}

inline void DomDistillerOptions::SharedCtor() {
original_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  original_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
pagination_algo_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  pagination_algo_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&extract_text_only_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&debug_level_) -
    reinterpret_cast<char*>(&extract_text_only_)) + sizeof(debug_level_));
}

DomDistillerOptions::~DomDistillerOptions() {
  // @@protoc_insertion_point(destructor:dom_distiller.proto.DomDistillerOptions)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DomDistillerOptions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  original_url_.Destroy();
  pagination_algo_.Destroy();
}

void DomDistillerOptions::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DomDistillerOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:dom_distiller.proto.DomDistillerOptions)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      original_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      pagination_algo_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&extract_text_only_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&debug_level_) -
        reinterpret_cast<char*>(&extract_text_only_)) + sizeof(debug_level_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DomDistillerOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool extract_text_only = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_extract_text_only(&has_bits);
          extract_text_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 debug_level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_debug_level(&has_bits);
          debug_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string original_url = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_original_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string pagination_algo = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_pagination_algo();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DomDistillerOptions::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:dom_distiller.proto.DomDistillerOptions)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool extract_text_only = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_extract_text_only(), target);
  }

  // optional int32 debug_level = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_debug_level(), target);
  }

  // optional string original_url = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_original_url(), target);
  }

  // optional string pagination_algo = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_pagination_algo(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dom_distiller.proto.DomDistillerOptions)
  return target;
}

size_t DomDistillerOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dom_distiller.proto.DomDistillerOptions)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string original_url = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_original_url());
    }

    // optional string pagination_algo = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_pagination_algo());
    }

    // optional bool extract_text_only = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional int32 debug_level = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_debug_level());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DomDistillerOptions::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DomDistillerOptions*>(
      &from));
}

void DomDistillerOptions::MergeFrom(const DomDistillerOptions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dom_distiller.proto.DomDistillerOptions)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_original_url(from._internal_original_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_pagination_algo(from._internal_pagination_algo());
    }
    if (cached_has_bits & 0x00000004u) {
      extract_text_only_ = from.extract_text_only_;
    }
    if (cached_has_bits & 0x00000008u) {
      debug_level_ = from.debug_level_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DomDistillerOptions::CopyFrom(const DomDistillerOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dom_distiller.proto.DomDistillerOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DomDistillerOptions::IsInitialized() const {
  return true;
}

void DomDistillerOptions::InternalSwap(DomDistillerOptions* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &original_url_, lhs_arena,
      &other->original_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &pagination_algo_, lhs_arena,
      &other->pagination_algo_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DomDistillerOptions, debug_level_)
      + sizeof(DomDistillerOptions::debug_level_)
      - PROTOBUF_FIELD_OFFSET(DomDistillerOptions, extract_text_only_)>(
          reinterpret_cast<char*>(&extract_text_only_),
          reinterpret_cast<char*>(&other->extract_text_only_));
}

std::string DomDistillerOptions::GetTypeName() const {
  return "dom_distiller.proto.DomDistillerOptions";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace dom_distiller
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::dom_distiller::proto::DistilledContent*
Arena::CreateMaybeMessage< ::dom_distiller::proto::DistilledContent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dom_distiller::proto::DistilledContent >(arena);
}
template<> PROTOBUF_NOINLINE ::dom_distiller::proto::PaginationInfo*
Arena::CreateMaybeMessage< ::dom_distiller::proto::PaginationInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dom_distiller::proto::PaginationInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::dom_distiller::proto::MarkupArticle*
Arena::CreateMaybeMessage< ::dom_distiller::proto::MarkupArticle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dom_distiller::proto::MarkupArticle >(arena);
}
template<> PROTOBUF_NOINLINE ::dom_distiller::proto::MarkupImage*
Arena::CreateMaybeMessage< ::dom_distiller::proto::MarkupImage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dom_distiller::proto::MarkupImage >(arena);
}
template<> PROTOBUF_NOINLINE ::dom_distiller::proto::MarkupInfo*
Arena::CreateMaybeMessage< ::dom_distiller::proto::MarkupInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dom_distiller::proto::MarkupInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::dom_distiller::proto::TimingEntry*
Arena::CreateMaybeMessage< ::dom_distiller::proto::TimingEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dom_distiller::proto::TimingEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::dom_distiller::proto::TimingInfo*
Arena::CreateMaybeMessage< ::dom_distiller::proto::TimingInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dom_distiller::proto::TimingInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::dom_distiller::proto::DebugInfo*
Arena::CreateMaybeMessage< ::dom_distiller::proto::DebugInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dom_distiller::proto::DebugInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::dom_distiller::proto::StatisticsInfo*
Arena::CreateMaybeMessage< ::dom_distiller::proto::StatisticsInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dom_distiller::proto::StatisticsInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::dom_distiller::proto::DomDistillerResult_ContentImage*
Arena::CreateMaybeMessage< ::dom_distiller::proto::DomDistillerResult_ContentImage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dom_distiller::proto::DomDistillerResult_ContentImage >(arena);
}
template<> PROTOBUF_NOINLINE ::dom_distiller::proto::DomDistillerResult*
Arena::CreateMaybeMessage< ::dom_distiller::proto::DomDistillerResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dom_distiller::proto::DomDistillerResult >(arena);
}
template<> PROTOBUF_NOINLINE ::dom_distiller::proto::DomDistillerOptions*
Arena::CreateMaybeMessage< ::dom_distiller::proto::DomDistillerOptions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::dom_distiller::proto::DomDistillerOptions >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
