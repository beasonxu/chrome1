// services/network/public/mojom/url_loader_network_service_observer.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_NETWORK_PUBLIC_MOJOM_URL_LOADER_NETWORK_SERVICE_OBSERVER_MOJOM_H_
#define SERVICES_NETWORK_PUBLIC_MOJOM_URL_LOADER_NETWORK_SERVICE_OBSERVER_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "third_party/abseil-cpp/absl/types/optional.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "services/network/public/mojom/url_loader_network_service_observer.mojom-shared.h"
#include "services/network/public/mojom/url_loader_network_service_observer.mojom-forward.h"
#include "mojo/public/mojom/base/string16.mojom.h"
#include "mojo/public/mojom/base/time.mojom.h"
#include "mojo/public/mojom/base/unguessable_token.mojom.h"
#include "services/network/public/mojom/cookie_partition_key.mojom.h"
#include "services/network/public/mojom/network_param.mojom.h"
#include "url/mojom/url.mojom.h"
#include <string>
#include <vector>

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"






namespace network {
namespace mojom {

class ClientCertificateResponderProxy;

template <typename ImplRefTraits>
class ClientCertificateResponderStub;

class ClientCertificateResponderRequestValidator;


class  ClientCertificateResponder
    : public ClientCertificateResponderInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = ClientCertificateResponderInterfaceBase;
  using Proxy_ = ClientCertificateResponderProxy;

  template <typename ImplRefTraits>
  using Stub_ = ClientCertificateResponderStub<ImplRefTraits>;

  using RequestValidator_ = ClientCertificateResponderRequestValidator;
  using ResponseValidator_ = mojo::PassThroughFilter;
  enum MethodMinVersions : uint32_t {
    kContinueWithCertificateMinVersion = 0,
    kContinueWithoutCertificateMinVersion = 0,
    kCancelRequestMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct ContinueWithCertificate_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct ContinueWithoutCertificate_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct CancelRequest_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~ClientCertificateResponder() = default;

  
  virtual void ContinueWithCertificate(const ::scoped_refptr<::net::X509Certificate>& x509_certificate, const std::string& provider_name, const std::vector<uint16_t>& algorithm_preferences, ::mojo::PendingRemote<SSLPrivateKey> ssl_private_key) = 0;

  
  virtual void ContinueWithoutCertificate() = 0;

  
  virtual void CancelRequest() = 0;
};

class SSLPrivateKeyProxy;

template <typename ImplRefTraits>
class SSLPrivateKeyStub;

class SSLPrivateKeyRequestValidator;
class SSLPrivateKeyResponseValidator;


class  SSLPrivateKey
    : public SSLPrivateKeyInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = SSLPrivateKeyInterfaceBase;
  using Proxy_ = SSLPrivateKeyProxy;

  template <typename ImplRefTraits>
  using Stub_ = SSLPrivateKeyStub<ImplRefTraits>;

  using RequestValidator_ = SSLPrivateKeyRequestValidator;
  using ResponseValidator_ = SSLPrivateKeyResponseValidator;
  enum MethodMinVersions : uint32_t {
    kSignMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct Sign_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~SSLPrivateKey() = default;


  using SignCallback = base::OnceCallback<void(int32_t, const std::vector<uint8_t>&)>;
  
  virtual void Sign(uint16_t algorithm, const std::vector<uint8_t>& input, SignCallback callback) = 0;
};

class AuthChallengeResponderProxy;

template <typename ImplRefTraits>
class AuthChallengeResponderStub;

class AuthChallengeResponderRequestValidator;


class  AuthChallengeResponder
    : public AuthChallengeResponderInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = AuthChallengeResponderInterfaceBase;
  using Proxy_ = AuthChallengeResponderProxy;

  template <typename ImplRefTraits>
  using Stub_ = AuthChallengeResponderStub<ImplRefTraits>;

  using RequestValidator_ = AuthChallengeResponderRequestValidator;
  using ResponseValidator_ = mojo::PassThroughFilter;
  enum MethodMinVersions : uint32_t {
    kOnAuthCredentialsMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct OnAuthCredentials_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~AuthChallengeResponder() = default;

  
  virtual void OnAuthCredentials(const absl::optional<::net::AuthCredentials>& credentials) = 0;
};

class URLLoaderNetworkServiceObserverProxy;

template <typename ImplRefTraits>
class URLLoaderNetworkServiceObserverStub;

class URLLoaderNetworkServiceObserverRequestValidator;
class URLLoaderNetworkServiceObserverResponseValidator;


class  URLLoaderNetworkServiceObserver
    : public URLLoaderNetworkServiceObserverInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = URLLoaderNetworkServiceObserverInterfaceBase;
  using Proxy_ = URLLoaderNetworkServiceObserverProxy;

  template <typename ImplRefTraits>
  using Stub_ = URLLoaderNetworkServiceObserverStub<ImplRefTraits>;

  using RequestValidator_ = URLLoaderNetworkServiceObserverRequestValidator;
  using ResponseValidator_ = URLLoaderNetworkServiceObserverResponseValidator;
  enum MethodMinVersions : uint32_t {
    kOnSSLCertificateErrorMinVersion = 0,
    kOnCertificateRequestedMinVersion = 0,
    kOnAuthRequiredMinVersion = 0,
    kOnClearSiteDataMinVersion = 0,
    kOnLoadingStateUpdateMinVersion = 0,
    kOnDataUseUpdateMinVersion = 0,
    kCloneMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct OnSSLCertificateError_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnCertificateRequested_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnAuthRequired_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnClearSiteData_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnLoadingStateUpdate_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnDataUseUpdate_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct Clone_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~URLLoaderNetworkServiceObserver() = default;


  using OnSSLCertificateErrorCallback = base::OnceCallback<void(int32_t)>;
  
  virtual void OnSSLCertificateError(const ::GURL& url, int32_t net_error, const ::net::SSLInfo& ssl_info, bool fatal, OnSSLCertificateErrorCallback callback) = 0;

  
  virtual void OnCertificateRequested(const absl::optional<::base::UnguessableToken>& window_id, const ::scoped_refptr<::net::SSLCertRequestInfo>& cert_info, ::mojo::PendingRemote<ClientCertificateResponder> cert_responder) = 0;

  
  virtual void OnAuthRequired(const absl::optional<::base::UnguessableToken>& window_id, uint32_t request_id, const ::GURL& url, bool first_auth_attempt, const ::net::AuthChallengeInfo& auth_info, const ::scoped_refptr<::net::HttpResponseHeaders>& head_headers, ::mojo::PendingRemote<AuthChallengeResponder> auth_challenge_responder) = 0;


  using OnClearSiteDataCallback = base::OnceCallback<void()>;
  
  virtual void OnClearSiteData(const ::GURL& url, const std::string& header_value, int32_t load_flags, const absl::optional<::net::CookiePartitionKey>& cookie_partition_key, OnClearSiteDataCallback callback) = 0;


  using OnLoadingStateUpdateCallback = base::OnceCallback<void()>;
  
  virtual void OnLoadingStateUpdate(LoadInfoPtr info, OnLoadingStateUpdateCallback callback) = 0;

  
  virtual void OnDataUseUpdate(int32_t network_traffic_annotation_id_hash, int64_t recv_bytes, int64_t sent_bytes) = 0;

  
  virtual void Clone(::mojo::PendingReceiver<URLLoaderNetworkServiceObserver> listener) = 0;
};



class  ClientCertificateResponderProxy
    : public ClientCertificateResponder {
 public:
  using InterfaceType = ClientCertificateResponder;

  explicit ClientCertificateResponderProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void ContinueWithCertificate(const ::scoped_refptr<::net::X509Certificate>& x509_certificate, const std::string& provider_name, const std::vector<uint16_t>& algorithm_preferences, ::mojo::PendingRemote<SSLPrivateKey> ssl_private_key) final;
  
  void ContinueWithoutCertificate() final;
  
  void CancelRequest() final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class  SSLPrivateKeyProxy
    : public SSLPrivateKey {
 public:
  using InterfaceType = SSLPrivateKey;

  explicit SSLPrivateKeyProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void Sign(uint16_t algorithm, const std::vector<uint8_t>& input, SignCallback callback) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class  AuthChallengeResponderProxy
    : public AuthChallengeResponder {
 public:
  using InterfaceType = AuthChallengeResponder;

  explicit AuthChallengeResponderProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void OnAuthCredentials(const absl::optional<::net::AuthCredentials>& credentials) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class  URLLoaderNetworkServiceObserverProxy
    : public URLLoaderNetworkServiceObserver {
 public:
  using InterfaceType = URLLoaderNetworkServiceObserver;

  explicit URLLoaderNetworkServiceObserverProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void OnSSLCertificateError(const ::GURL& url, int32_t net_error, const ::net::SSLInfo& ssl_info, bool fatal, OnSSLCertificateErrorCallback callback) final;
  
  void OnCertificateRequested(const absl::optional<::base::UnguessableToken>& window_id, const ::scoped_refptr<::net::SSLCertRequestInfo>& cert_info, ::mojo::PendingRemote<ClientCertificateResponder> cert_responder) final;
  
  void OnAuthRequired(const absl::optional<::base::UnguessableToken>& window_id, uint32_t request_id, const ::GURL& url, bool first_auth_attempt, const ::net::AuthChallengeInfo& auth_info, const ::scoped_refptr<::net::HttpResponseHeaders>& head_headers, ::mojo::PendingRemote<AuthChallengeResponder> auth_challenge_responder) final;
  
  void OnClearSiteData(const ::GURL& url, const std::string& header_value, int32_t load_flags, const absl::optional<::net::CookiePartitionKey>& cookie_partition_key, OnClearSiteDataCallback callback) final;
  
  void OnLoadingStateUpdate(LoadInfoPtr info, OnLoadingStateUpdateCallback callback) final;
  
  void OnDataUseUpdate(int32_t network_traffic_annotation_id_hash, int64_t recv_bytes, int64_t sent_bytes) final;
  
  void Clone(::mojo::PendingReceiver<URLLoaderNetworkServiceObserver> listener) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};
class  ClientCertificateResponderStubDispatch {
 public:
  static bool Accept(ClientCertificateResponder* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      ClientCertificateResponder* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<ClientCertificateResponder>>
class ClientCertificateResponderStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  ClientCertificateResponderStub() = default;
  ~ClientCertificateResponderStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return ClientCertificateResponderStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return ClientCertificateResponderStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  SSLPrivateKeyStubDispatch {
 public:
  static bool Accept(SSLPrivateKey* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      SSLPrivateKey* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<SSLPrivateKey>>
class SSLPrivateKeyStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  SSLPrivateKeyStub() = default;
  ~SSLPrivateKeyStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return SSLPrivateKeyStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return SSLPrivateKeyStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  AuthChallengeResponderStubDispatch {
 public:
  static bool Accept(AuthChallengeResponder* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      AuthChallengeResponder* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<AuthChallengeResponder>>
class AuthChallengeResponderStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  AuthChallengeResponderStub() = default;
  ~AuthChallengeResponderStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return AuthChallengeResponderStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return AuthChallengeResponderStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  URLLoaderNetworkServiceObserverStubDispatch {
 public:
  static bool Accept(URLLoaderNetworkServiceObserver* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      URLLoaderNetworkServiceObserver* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<URLLoaderNetworkServiceObserver>>
class URLLoaderNetworkServiceObserverStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  URLLoaderNetworkServiceObserverStub() = default;
  ~URLLoaderNetworkServiceObserverStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return URLLoaderNetworkServiceObserverStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return URLLoaderNetworkServiceObserverStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  ClientCertificateResponderRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  SSLPrivateKeyRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  AuthChallengeResponderRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  URLLoaderNetworkServiceObserverRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  SSLPrivateKeyResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  URLLoaderNetworkServiceObserverResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};








class  LoadInfo {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<LoadInfo, T>::value>;
  using DataView = LoadInfoDataView;
  using Data_ = internal::LoadInfo_Data;

  template <typename... Args>
  static LoadInfoPtr New(Args&&... args) {
    return LoadInfoPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static LoadInfoPtr From(const U& u) {
    return mojo::TypeConverter<LoadInfoPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, LoadInfo>::Convert(*this);
  }


  LoadInfo();

  LoadInfo(
      ::base::TimeTicks timestamp,
      const std::string& host,
      uint32_t load_state,
      const ::std::u16string& state_param,
      uint64_t upload_position,
      uint64_t upload_size);


  ~LoadInfo();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = LoadInfoPtr>
  LoadInfoPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, LoadInfo::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, LoadInfo::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        LoadInfo::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        LoadInfo::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::LoadInfo_UnserializedMessageContext<
            UserType, LoadInfo::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<LoadInfo::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return LoadInfo::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::LoadInfo_UnserializedMessageContext<
            UserType, LoadInfo::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<LoadInfo::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::base::TimeTicks timestamp;
  
  std::string host;
  
  uint32_t load_state;
  
  ::std::u16string state_param;
  
  uint64_t upload_position;
  
  uint64_t upload_size;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, LoadInfo::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, LoadInfo::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, LoadInfo::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, LoadInfo::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}

template <typename StructPtrType>
LoadInfoPtr LoadInfo::Clone() const {
  return New(
      mojo::Clone(timestamp),
      mojo::Clone(host),
      mojo::Clone(load_state),
      mojo::Clone(state_param),
      mojo::Clone(upload_position),
      mojo::Clone(upload_size)
  );
}

template <typename T, LoadInfo::EnableIfSame<T>*>
bool LoadInfo::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->timestamp, other_struct.timestamp))
    return false;
  if (!mojo::Equals(this->host, other_struct.host))
    return false;
  if (!mojo::Equals(this->load_state, other_struct.load_state))
    return false;
  if (!mojo::Equals(this->state_param, other_struct.state_param))
    return false;
  if (!mojo::Equals(this->upload_position, other_struct.upload_position))
    return false;
  if (!mojo::Equals(this->upload_size, other_struct.upload_size))
    return false;
  return true;
}

template <typename T, LoadInfo::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.timestamp < rhs.timestamp)
    return true;
  if (rhs.timestamp < lhs.timestamp)
    return false;
  if (lhs.host < rhs.host)
    return true;
  if (rhs.host < lhs.host)
    return false;
  if (lhs.load_state < rhs.load_state)
    return true;
  if (rhs.load_state < lhs.load_state)
    return false;
  if (lhs.state_param < rhs.state_param)
    return true;
  if (rhs.state_param < lhs.state_param)
    return false;
  if (lhs.upload_position < rhs.upload_position)
    return true;
  if (rhs.upload_position < lhs.upload_position)
    return false;
  if (lhs.upload_size < rhs.upload_size)
    return true;
  if (rhs.upload_size < lhs.upload_size)
    return false;
  return false;
}


}  // namespace mojom
}  // namespace network

namespace mojo {


template <>
struct  StructTraits<::network::mojom::LoadInfo::DataView,
                                         ::network::mojom::LoadInfoPtr> {
  static bool IsNull(const ::network::mojom::LoadInfoPtr& input) { return !input; }
  static void SetToNull(::network::mojom::LoadInfoPtr* output) { output->reset(); }

  static const decltype(::network::mojom::LoadInfo::timestamp)& timestamp(
      const ::network::mojom::LoadInfoPtr& input) {
    return input->timestamp;
  }

  static const decltype(::network::mojom::LoadInfo::host)& host(
      const ::network::mojom::LoadInfoPtr& input) {
    return input->host;
  }

  static decltype(::network::mojom::LoadInfo::load_state) load_state(
      const ::network::mojom::LoadInfoPtr& input) {
    return input->load_state;
  }

  static const decltype(::network::mojom::LoadInfo::state_param)& state_param(
      const ::network::mojom::LoadInfoPtr& input) {
    return input->state_param;
  }

  static decltype(::network::mojom::LoadInfo::upload_position) upload_position(
      const ::network::mojom::LoadInfoPtr& input) {
    return input->upload_position;
  }

  static decltype(::network::mojom::LoadInfo::upload_size) upload_size(
      const ::network::mojom::LoadInfoPtr& input) {
    return input->upload_size;
  }

  static bool Read(::network::mojom::LoadInfo::DataView input, ::network::mojom::LoadInfoPtr* output);
};

}  // namespace mojo

#endif  // SERVICES_NETWORK_PUBLIC_MOJOM_URL_LOADER_NETWORK_SERVICE_OBSERVER_MOJOM_H_