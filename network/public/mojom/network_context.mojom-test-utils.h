// services/network/public/mojom/network_context.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_NETWORK_PUBLIC_MOJOM_NETWORK_CONTEXT_MOJOM_TEST_UTILS_H_
#define SERVICES_NETWORK_PUBLIC_MOJOM_NETWORK_CONTEXT_MOJOM_TEST_UTILS_H_

#include "services/network/public/mojom/network_context.mojom.h"


namespace network {
namespace mojom {


class  CustomProxyConnectionObserverInterceptorForTesting : public CustomProxyConnectionObserver {
  virtual CustomProxyConnectionObserver* GetForwardingInterface() = 0;
  void OnFallback(const ::net::ProxyServer& bad_proxy, int32_t net_error) override;
  void OnTunnelHeadersReceived(const ::net::ProxyServer& proxy_server, const ::scoped_refptr<::net::HttpResponseHeaders>& response_headers) override;
};
class  CustomProxyConnectionObserverAsyncWaiter {
 public:
  explicit CustomProxyConnectionObserverAsyncWaiter(CustomProxyConnectionObserver* proxy);

  CustomProxyConnectionObserverAsyncWaiter(const CustomProxyConnectionObserverAsyncWaiter&) = delete;
  CustomProxyConnectionObserverAsyncWaiter& operator=(const CustomProxyConnectionObserverAsyncWaiter&) = delete;

  ~CustomProxyConnectionObserverAsyncWaiter();

 private:
  CustomProxyConnectionObserver* const proxy_;
};


class  CustomProxyConfigClientInterceptorForTesting : public CustomProxyConfigClient {
  virtual CustomProxyConfigClient* GetForwardingInterface() = 0;
  void OnCustomProxyConfigUpdated(CustomProxyConfigPtr proxy_config, OnCustomProxyConfigUpdatedCallback callback) override;
  void MarkProxiesAsBad(::base::TimeDelta bypass_duration, const ::net::ProxyList& bad_proxies, MarkProxiesAsBadCallback callback) override;
  void ClearBadProxiesCache() override;
};
class  CustomProxyConfigClientAsyncWaiter {
 public:
  explicit CustomProxyConfigClientAsyncWaiter(CustomProxyConfigClient* proxy);

  CustomProxyConfigClientAsyncWaiter(const CustomProxyConfigClientAsyncWaiter&) = delete;
  CustomProxyConfigClientAsyncWaiter& operator=(const CustomProxyConfigClientAsyncWaiter&) = delete;

  ~CustomProxyConfigClientAsyncWaiter();
  void OnCustomProxyConfigUpdated(
      CustomProxyConfigPtr proxy_config);
  void MarkProxiesAsBad(
      ::base::TimeDelta bypass_duration, const ::net::ProxyList& bad_proxies);

 private:
  CustomProxyConfigClient* const proxy_;
};


class  TrustedHeaderClientInterceptorForTesting : public TrustedHeaderClient {
  virtual TrustedHeaderClient* GetForwardingInterface() = 0;
  void OnBeforeSendHeaders(const ::net::HttpRequestHeaders& headers, OnBeforeSendHeadersCallback callback) override;
  void OnHeadersReceived(const std::string& headers, const ::net::IPEndPoint& remote_endpoint, OnHeadersReceivedCallback callback) override;
};
class  TrustedHeaderClientAsyncWaiter {
 public:
  explicit TrustedHeaderClientAsyncWaiter(TrustedHeaderClient* proxy);

  TrustedHeaderClientAsyncWaiter(const TrustedHeaderClientAsyncWaiter&) = delete;
  TrustedHeaderClientAsyncWaiter& operator=(const TrustedHeaderClientAsyncWaiter&) = delete;

  ~TrustedHeaderClientAsyncWaiter();
  void OnBeforeSendHeaders(
      const ::net::HttpRequestHeaders& headers, int32_t* out_result, absl::optional<::net::HttpRequestHeaders>* out_headers);
  void OnHeadersReceived(
      const std::string& headers, const ::net::IPEndPoint& remote_endpoint, int32_t* out_result, absl::optional<std::string>* out_headers, absl::optional<::GURL>* out_preserve_fragment_on_redirect_url);

 private:
  TrustedHeaderClient* const proxy_;
};


class  TrustedURLLoaderHeaderClientInterceptorForTesting : public TrustedURLLoaderHeaderClient {
  virtual TrustedURLLoaderHeaderClient* GetForwardingInterface() = 0;
  void OnLoaderCreated(int32_t request_id, ::mojo::PendingReceiver<TrustedHeaderClient> header_client) override;
  void OnLoaderForCorsPreflightCreated(const ::network::ResourceRequest& request, ::mojo::PendingReceiver<TrustedHeaderClient> header_client) override;
};
class  TrustedURLLoaderHeaderClientAsyncWaiter {
 public:
  explicit TrustedURLLoaderHeaderClientAsyncWaiter(TrustedURLLoaderHeaderClient* proxy);

  TrustedURLLoaderHeaderClientAsyncWaiter(const TrustedURLLoaderHeaderClientAsyncWaiter&) = delete;
  TrustedURLLoaderHeaderClientAsyncWaiter& operator=(const TrustedURLLoaderHeaderClientAsyncWaiter&) = delete;

  ~TrustedURLLoaderHeaderClientAsyncWaiter();

 private:
  TrustedURLLoaderHeaderClient* const proxy_;
};


class  NetworkContextClientInterceptorForTesting : public NetworkContextClient {
  virtual NetworkContextClient* GetForwardingInterface() = 0;
  void OnFileUploadRequested(int32_t process_id, bool async, const std::vector<::base::FilePath>& file_paths, const ::GURL& destination_url, OnFileUploadRequestedCallback callback) override;
  void OnCanSendReportingReports(const std::vector<::url::Origin>& origins, OnCanSendReportingReportsCallback callback) override;
  void OnCanSendDomainReliabilityUpload(const ::url::Origin& origin, OnCanSendDomainReliabilityUploadCallback callback) override;
  void OnGenerateHttpNegotiateAuthToken(const std::string& server_auth_token, bool can_delegate, const std::string& auth_negotiate_android_account_type, const std::string& spn, OnGenerateHttpNegotiateAuthTokenCallback callback) override;
  void OnTrustTokenIssuanceDivertedToSystem(::network::mojom::FulfillTrustTokenIssuanceRequestPtr request, OnTrustTokenIssuanceDivertedToSystemCallback callback) override;
  void OnCanSendSCTAuditingReport(OnCanSendSCTAuditingReportCallback callback) override;
  void OnNewSCTAuditingReportSent() override;
};
class  NetworkContextClientAsyncWaiter {
 public:
  explicit NetworkContextClientAsyncWaiter(NetworkContextClient* proxy);

  NetworkContextClientAsyncWaiter(const NetworkContextClientAsyncWaiter&) = delete;
  NetworkContextClientAsyncWaiter& operator=(const NetworkContextClientAsyncWaiter&) = delete;

  ~NetworkContextClientAsyncWaiter();
  void OnFileUploadRequested(
      int32_t process_id, bool async, const std::vector<::base::FilePath>& file_paths, const ::GURL& destination_url, int32_t* out_net_error, std::vector<::base::File>* out_files);
  void OnCanSendReportingReports(
      const std::vector<::url::Origin>& origins, std::vector<::url::Origin>* out_origins);
  void OnCanSendDomainReliabilityUpload(
      const ::url::Origin& origin, bool* out_allowed);
  void OnGenerateHttpNegotiateAuthToken(
      const std::string& server_auth_token, bool can_delegate, const std::string& auth_negotiate_android_account_type, const std::string& spn, int32_t* out_result, std::string* out_auth_token);
  void OnTrustTokenIssuanceDivertedToSystem(
      ::network::mojom::FulfillTrustTokenIssuanceRequestPtr request, ::network::mojom::FulfillTrustTokenIssuanceAnswerPtr* out_response);
  void OnCanSendSCTAuditingReport(
      bool* out_allowed);

 private:
  NetworkContextClient* const proxy_;
};


class  NetworkContextInterceptorForTesting : public NetworkContext {
  virtual NetworkContext* GetForwardingInterface() = 0;
  void SetClient(::mojo::PendingRemote<NetworkContextClient> client) override;
  void CreateURLLoaderFactory(::mojo::PendingReceiver<::network::mojom::URLLoaderFactory> url_loader_factory, URLLoaderFactoryParamsPtr params) override;
  void ResetURLLoaderFactories() override;
  void GetCookieManager(::mojo::PendingReceiver<::network::mojom::CookieManager> cookie_manager) override;
  void GetRestrictedCookieManager(::mojo::PendingReceiver<::network::mojom::RestrictedCookieManager> restricted_cookie_manager, ::network::mojom::RestrictedCookieManagerRole role, const ::url::Origin& origin, const ::net::IsolationInfo& isolation_info, ::mojo::PendingRemote<::network::mojom::CookieAccessObserver> cookie_observer) override;
  void GetTrustTokenQueryAnswerer(::mojo::PendingReceiver<::network::mojom::TrustTokenQueryAnswerer> trust_token_query_answerer, const ::url::Origin& top_frame_origin) override;
  void ClearTrustTokenData(ClearDataFilterPtr filter, ClearTrustTokenDataCallback callback) override;
  void GetStoredTrustTokenCounts(GetStoredTrustTokenCountsCallback callback) override;
  void DeleteStoredTrustTokens(const ::url::Origin& issuer, DeleteStoredTrustTokensCallback callback) override;
  void SetBlockTrustTokens(bool block) override;
  void ClearNetworkingHistoryBetween(::base::Time start_time, ::base::Time end_time, ClearNetworkingHistoryBetweenCallback callback) override;
  void ClearHttpCache(::base::Time start_time, ::base::Time end_time, ClearDataFilterPtr filter, ClearHttpCacheCallback callback) override;
  void ComputeHttpCacheSize(::base::Time start_time, ::base::Time end_time, ComputeHttpCacheSizeCallback callback) override;
  void NotifyExternalCacheHit(const ::GURL& url, const std::string& http_method, const ::net::NetworkIsolationKey& key, bool is_subframe_document_resource, bool include_credentials) override;
  void ClearHostCache(ClearDataFilterPtr filter, ClearHostCacheCallback callback) override;
  void ClearHttpAuthCache(::base::Time start_time, ::base::Time end_time, ClearHttpAuthCacheCallback callback) override;
  void ClearReportingCacheReports(ClearDataFilterPtr filter, ClearReportingCacheReportsCallback callback) override;
  void ClearReportingCacheClients(ClearDataFilterPtr filter, ClearReportingCacheClientsCallback callback) override;
  void ClearNetworkErrorLogging(ClearDataFilterPtr filter, ClearNetworkErrorLoggingCallback callback) override;
  void ClearDomainReliability(ClearDataFilterPtr filter, NetworkContext::DomainReliabilityClearMode mode, ClearDomainReliabilityCallback callback) override;
  void SetDocumentReportingEndpoints(const ::base::UnguessableToken& reporting_source, const ::url::Origin& origin, const ::net::IsolationInfo& isolation_info, const base::flat_map<std::string, std::string>& endpoints) override;
  void SendReportsAndRemoveSource(const ::base::UnguessableToken& reporting_source) override;
  void QueueReport(const std::string& type, const std::string& group, const ::GURL& url, const absl::optional<::base::UnguessableToken>& reporting_source, const ::net::NetworkIsolationKey& network_isolation_key, const absl::optional<std::string>& user_agent, ::base::Value::Dict body) override;
  void QueueSignedExchangeReport(SignedExchangeReportPtr report, const ::net::NetworkIsolationKey& network_isolation_key) override;
  void CloseAllConnections(CloseAllConnectionsCallback callback) override;
  void CloseIdleConnections(CloseIdleConnectionsCallback callback) override;
  void SetNetworkConditions(const ::base::UnguessableToken& throttling_profile_id, NetworkConditionsPtr conditions) override;
  void SetAcceptLanguage(const std::string& new_accept_language) override;
  void SetEnableReferrers(bool enable_referrers) override;
  void SetCTPolicy(CTPolicyPtr ct_policy) override;
  void AddExpectCT(const std::string& host, ::base::Time expiry, bool enforce, const ::GURL& report_uri, const ::net::NetworkIsolationKey& network_isolation_key, AddExpectCTCallback callback) override;
  void SetExpectCTTestReport(const ::GURL& report_uri, SetExpectCTTestReportCallback callback) override;
  void GetExpectCTState(const std::string& domain, const ::net::NetworkIsolationKey& network_isolation_key, GetExpectCTStateCallback callback) override;
  void CreateUDPSocket(::mojo::PendingReceiver<::network::mojom::UDPSocket> receiver, ::mojo::PendingRemote<::network::mojom::UDPSocketListener> listener) override;
  void CreateTCPServerSocket(const ::net::IPEndPoint& local_addr, uint32_t backlog, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, ::mojo::PendingReceiver<::network::mojom::TCPServerSocket> socket, CreateTCPServerSocketCallback callback) override;
  void CreateTCPConnectedSocket(const absl::optional<::net::IPEndPoint>& local_addr, const ::net::AddressList& remote_addr_list, ::network::mojom::TCPConnectedSocketOptionsPtr tcp_connected_socket_options, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, ::mojo::PendingReceiver<::network::mojom::TCPConnectedSocket> socket, ::mojo::PendingRemote<::network::mojom::SocketObserver> observer, CreateTCPConnectedSocketCallback callback) override;
  void CreateTCPBoundSocket(const ::net::IPEndPoint& local_addr, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, ::mojo::PendingReceiver<::network::mojom::TCPBoundSocket> socket, CreateTCPBoundSocketCallback callback) override;
  void CreateProxyResolvingSocketFactory(::mojo::PendingReceiver<::network::mojom::ProxyResolvingSocketFactory> factory) override;
  void LookUpProxyForURL(const ::GURL& url, const ::net::NetworkIsolationKey& network_isolation_key, ::mojo::PendingRemote<::network::mojom::ProxyLookupClient> proxy_lookup_client) override;
  void ForceReloadProxyConfig(ForceReloadProxyConfigCallback callback) override;
  void ClearBadProxiesCache(ClearBadProxiesCacheCallback callback) override;
  void CreateWebSocket(const ::GURL& url, const std::vector<std::string>& requested_protocols, const ::net::SiteForCookies& site_for_cookies, const ::net::IsolationInfo& isolation_info, std::vector<::network::mojom::HttpHeaderPtr> additional_headers, int32_t process_id, const ::url::Origin& origin, uint32_t options, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, ::mojo::PendingRemote<::network::mojom::WebSocketHandshakeClient> handshake_client, ::mojo::PendingRemote<::network::mojom::URLLoaderNetworkServiceObserver> url_loader_network_observer, ::mojo::PendingRemote<::network::mojom::WebSocketAuthenticationHandler> auth_handler, ::mojo::PendingRemote<TrustedHeaderClient> header_client, const absl::optional<::base::UnguessableToken>& throttling_profile_id) override;
  void CreateWebTransport(const ::GURL& url, const ::url::Origin& origin, const ::net::NetworkIsolationKey& network_isolation_key, std::vector<::network::mojom::WebTransportCertificateFingerprintPtr> fingerprints, ::mojo::PendingRemote<::network::mojom::WebTransportHandshakeClient> handshake_client) override;
  void CreateNetLogExporter(::mojo::PendingReceiver<::network::mojom::NetLogExporter> receiver) override;
  void PreconnectSockets(uint32_t num_streams, const ::GURL& url, bool allow_credentials, const ::net::NetworkIsolationKey& network_isolation_key) override;
  void CreateP2PSocketManager(const ::net::NetworkIsolationKey& network_isolation_key, ::mojo::PendingRemote<::network::mojom::P2PTrustedSocketManagerClient> client, ::mojo::PendingReceiver<::network::mojom::P2PTrustedSocketManager> trusted_socket_manager, ::mojo::PendingReceiver<::network::mojom::P2PSocketManager> socket_manager) override;
  void CreateMdnsResponder(::mojo::PendingReceiver<::network::mojom::MdnsResponder> responder_receiver) override;
  void ResolveHost(const ::net::HostPortPair& host, const ::net::NetworkIsolationKey& network_isolation_key, ::network::mojom::ResolveHostParametersPtr optional_parameters, ::mojo::PendingRemote<::network::mojom::ResolveHostClient> response_client) override;
  void CreateHostResolver(const absl::optional<::net::DnsConfigOverrides>& config_overrides, ::mojo::PendingReceiver<::network::mojom::HostResolver> host_resolver) override;
  void VerifyCertForSignedExchange(const ::scoped_refptr<::net::X509Certificate>& certificate, const ::GURL& url, const ::net::NetworkIsolationKey& network_isolation_key, const std::string& ocsp_response, const std::string& sct_list, VerifyCertForSignedExchangeCallback callback) override;
  void AddHSTS(const std::string& host, ::base::Time expiry, bool include_subdomains, AddHSTSCallback callback) override;
  void IsHSTSActiveForHost(const std::string& host, IsHSTSActiveForHostCallback callback) override;
  void GetHSTSState(const std::string& domain, GetHSTSStateCallback callback) override;
  void SetCorsOriginAccessListsForOrigin(const ::url::Origin& source_origin, std::vector<::network::mojom::CorsOriginPatternPtr> allow_patterns, std::vector<::network::mojom::CorsOriginPatternPtr> block_patterns, SetCorsOriginAccessListsForOriginCallback callback) override;
  void DeleteDynamicDataForHost(const std::string& host, DeleteDynamicDataForHostCallback callback) override;
  void SetSplitAuthCacheByNetworkIsolationKey(bool split_auth_cache_by_network_isolation_key) override;
  void SaveHttpAuthCacheProxyEntries(SaveHttpAuthCacheProxyEntriesCallback callback) override;
  void LoadHttpAuthCacheProxyEntries(const ::base::UnguessableToken& cache_key, LoadHttpAuthCacheProxyEntriesCallback callback) override;
  void AddAuthCacheEntry(const ::net::AuthChallengeInfo& challenge, const ::net::NetworkIsolationKey& network_isolation_key, const ::net::AuthCredentials& credentials, AddAuthCacheEntryCallback callback) override;
  void SetCorsNonWildcardRequestHeadersSupport(bool value) override;
  void LookupServerBasicAuthCredentials(const ::GURL& url, const ::net::NetworkIsolationKey& network_isolation_key, LookupServerBasicAuthCredentialsCallback callback) override;
  void EnableStaticKeyPinningForTesting(EnableStaticKeyPinningForTestingCallback callback) override;
  void VerifyCertificateForTesting(const ::scoped_refptr<::net::X509Certificate>& certificate, const std::string& hostname, const std::string& ocsp_response, const std::string& sct_list, VerifyCertificateForTestingCallback callback) override;
  void AddDomainReliabilityContextForTesting(const ::url::Origin& origin, const ::GURL& upload_url, AddDomainReliabilityContextForTestingCallback callback) override;
  void ForceDomainReliabilityUploadsForTesting(ForceDomainReliabilityUploadsForTestingCallback callback) override;
  void SetCTLogListAlwaysTimelyForTesting() override;
  void SetSCTAuditingMode(SCTAuditingMode mode) override;
  void AddReportingApiObserver(::mojo::PendingRemote<::network::mojom::ReportingApiObserver> observer) override;
};
class  NetworkContextAsyncWaiter {
 public:
  explicit NetworkContextAsyncWaiter(NetworkContext* proxy);

  NetworkContextAsyncWaiter(const NetworkContextAsyncWaiter&) = delete;
  NetworkContextAsyncWaiter& operator=(const NetworkContextAsyncWaiter&) = delete;

  ~NetworkContextAsyncWaiter();
  void ClearTrustTokenData(
      ClearDataFilterPtr filter);
  void GetStoredTrustTokenCounts(
      std::vector<::network::mojom::StoredTrustTokensForIssuerPtr>* out_tokens);
  void DeleteStoredTrustTokens(
      const ::url::Origin& issuer, ::network::mojom::DeleteStoredTrustTokensStatus* out_status);
  void ClearNetworkingHistoryBetween(
      ::base::Time start_time, ::base::Time end_time);
  void ClearHttpCache(
      ::base::Time start_time, ::base::Time end_time, ClearDataFilterPtr filter);
  void ComputeHttpCacheSize(
      ::base::Time start_time, ::base::Time end_time, bool* out_is_upper_bound, int64_t* out_size_or_error);
  void ClearHostCache(
      ClearDataFilterPtr filter);
  void ClearHttpAuthCache(
      ::base::Time start_time, ::base::Time end_time);
  void ClearReportingCacheReports(
      ClearDataFilterPtr filter);
  void ClearReportingCacheClients(
      ClearDataFilterPtr filter);
  void ClearNetworkErrorLogging(
      ClearDataFilterPtr filter);
  void ClearDomainReliability(
      ClearDataFilterPtr filter, NetworkContext::DomainReliabilityClearMode mode);
  void CloseAllConnections(
      );
  void CloseIdleConnections(
      );
  void AddExpectCT(
      const std::string& host, ::base::Time expiry, bool enforce, const ::GURL& report_uri, const ::net::NetworkIsolationKey& network_isolation_key, bool* out_success);
  void SetExpectCTTestReport(
      const ::GURL& report_uri, bool* out_success);
  void GetExpectCTState(
      const std::string& domain, const ::net::NetworkIsolationKey& network_isolation_key, ::base::Value::Dict* out_state);
  void CreateTCPServerSocket(
      const ::net::IPEndPoint& local_addr, uint32_t backlog, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, ::mojo::PendingReceiver<::network::mojom::TCPServerSocket> socket, int32_t* out_result, absl::optional<::net::IPEndPoint>* out_local_addr_out);
  void CreateTCPConnectedSocket(
      const absl::optional<::net::IPEndPoint>& local_addr, const ::net::AddressList& remote_addr_list, ::network::mojom::TCPConnectedSocketOptionsPtr tcp_connected_socket_options, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, ::mojo::PendingReceiver<::network::mojom::TCPConnectedSocket> socket, ::mojo::PendingRemote<::network::mojom::SocketObserver> observer, int32_t* out_result, absl::optional<::net::IPEndPoint>* out_local_addr, absl::optional<::net::IPEndPoint>* out_peer_addr, ::mojo::ScopedDataPipeConsumerHandle* out_receive_stream, ::mojo::ScopedDataPipeProducerHandle* out_send_stream);
  void CreateTCPBoundSocket(
      const ::net::IPEndPoint& local_addr, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, ::mojo::PendingReceiver<::network::mojom::TCPBoundSocket> socket, int32_t* out_result, absl::optional<::net::IPEndPoint>* out_local_addr);
  void ForceReloadProxyConfig(
      );
  void ClearBadProxiesCache(
      );
  void VerifyCertForSignedExchange(
      const ::scoped_refptr<::net::X509Certificate>& certificate, const ::GURL& url, const ::net::NetworkIsolationKey& network_isolation_key, const std::string& ocsp_response, const std::string& sct_list, int32_t* out_error_code, ::net::CertVerifyResult* out_cv_result, bool* out_pkp_bypassed, std::string* out_pinning_failure_log);
  void AddHSTS(
      const std::string& host, ::base::Time expiry, bool include_subdomains);
  void IsHSTSActiveForHost(
      const std::string& host, bool* out_result);
  void GetHSTSState(
      const std::string& domain, ::base::Value::Dict* out_state);
  void SetCorsOriginAccessListsForOrigin(
      const ::url::Origin& source_origin, std::vector<::network::mojom::CorsOriginPatternPtr> allow_patterns, std::vector<::network::mojom::CorsOriginPatternPtr> block_patterns);
  void DeleteDynamicDataForHost(
      const std::string& host, bool* out_result);
  void SaveHttpAuthCacheProxyEntries(
      ::base::UnguessableToken* out_cache_key);
  void LoadHttpAuthCacheProxyEntries(
      const ::base::UnguessableToken& cache_key);
  void AddAuthCacheEntry(
      const ::net::AuthChallengeInfo& challenge, const ::net::NetworkIsolationKey& network_isolation_key, const ::net::AuthCredentials& credentials);
  void LookupServerBasicAuthCredentials(
      const ::GURL& url, const ::net::NetworkIsolationKey& network_isolation_key, absl::optional<::net::AuthCredentials>* out_credentials);
  void EnableStaticKeyPinningForTesting(
      );
  void VerifyCertificateForTesting(
      const ::scoped_refptr<::net::X509Certificate>& certificate, const std::string& hostname, const std::string& ocsp_response, const std::string& sct_list, int32_t* out_error_code);
  void AddDomainReliabilityContextForTesting(
      const ::url::Origin& origin, const ::GURL& upload_url);
  void ForceDomainReliabilityUploadsForTesting(
      );

 private:
  NetworkContext* const proxy_;
};




}  // namespace mojom
}  // namespace network

#endif  // SERVICES_NETWORK_PUBLIC_MOJOM_NETWORK_CONTEXT_MOJOM_TEST_UTILS_H_