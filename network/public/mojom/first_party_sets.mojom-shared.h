// services/network/public/mojom/first_party_sets.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_NETWORK_PUBLIC_MOJOM_FIRST_PARTY_SETS_MOJOM_SHARED_H_
#define SERVICES_NETWORK_PUBLIC_MOJOM_FIRST_PARTY_SETS_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "services/network/public/mojom/first_party_sets.mojom-shared-internal.h"
#include "services/network/public/mojom/schemeful_site.mojom-shared.h"







namespace network {
namespace mojom {
class SiteIndexDataView;

class FirstPartySetEntryDataView;

class SamePartyContextDataView;

class FirstPartySetMetadataDataView;



}  // namespace mojom
}  // namespace network

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::network::mojom::SiteIndexDataView> {
  using Data = ::network::mojom::internal::SiteIndex_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::network::mojom::FirstPartySetEntryDataView> {
  using Data = ::network::mojom::internal::FirstPartySetEntry_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::network::mojom::SamePartyContextDataView> {
  using Data = ::network::mojom::internal::SamePartyContext_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::network::mojom::FirstPartySetMetadataDataView> {
  using Data = ::network::mojom::internal::FirstPartySetMetadata_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

}  // namespace internal
}  // namespace mojo


namespace network {
namespace mojom {


enum class SiteType : int32_t {
  
  kPrimary = 0,
  
  kAssociated = 1,
  kMinValue = 0,
  kMaxValue = 1,
};

 std::ostream& operator<<(std::ostream& os, SiteType value);
inline bool IsKnownEnumValue(SiteType value) {
  return internal::SiteType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class SamePartyCookieContextType : int32_t {
  
  kCrossParty = 0,
  
  kSameParty = 1,
  kMinValue = 0,
  kMaxValue = 1,
};

 std::ostream& operator<<(std::ostream& os, SamePartyCookieContextType value);
inline bool IsKnownEnumValue(SamePartyCookieContextType value) {
  return internal::SamePartyCookieContextType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


class SiteIndexDataView {
 public:
  SiteIndexDataView() = default;

  SiteIndexDataView(
      internal::SiteIndex_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  uint32_t value() const {
    return data_->value;
  }
 private:
  internal::SiteIndex_Data* data_ = nullptr;
};



class FirstPartySetEntryDataView {
 public:
  FirstPartySetEntryDataView() = default;

  FirstPartySetEntryDataView(
      internal::FirstPartySetEntry_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetPrimaryDataView(
      ::network::mojom::SchemefulSiteDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPrimary(UserType* output) {
    
    auto* pointer = data_->primary.Get();
    return mojo::internal::Deserialize<::network::mojom::SchemefulSiteDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadSiteType(UserType* output) const {
    auto data_value = data_->site_type;
    return mojo::internal::Deserialize<::network::mojom::SiteType>(
        data_value, output);
  }
  SiteType site_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::network::mojom::SiteType>(data_->site_type));
  }
  inline void GetSiteIndexDataView(
      SiteIndexDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSiteIndex(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::network::mojom::SiteIndexDataView, UserType>(),
    "Attempting to read the optional `site_index` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadSiteIndex` instead "
    "of `ReadSiteIndex if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->site_index.Get();
    return mojo::internal::Deserialize<::network::mojom::SiteIndexDataView>(
        pointer, output, message_);
  }
 private:
  internal::FirstPartySetEntry_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class SamePartyContextDataView {
 public:
  SamePartyContextDataView() = default;

  SamePartyContextDataView(
      internal::SamePartyContext_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadContextType(UserType* output) const {
    auto data_value = data_->context_type;
    return mojo::internal::Deserialize<::network::mojom::SamePartyCookieContextType>(
        data_value, output);
  }
  SamePartyCookieContextType context_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::network::mojom::SamePartyCookieContextType>(data_->context_type));
  }
 private:
  internal::SamePartyContext_Data* data_ = nullptr;
};



class FirstPartySetMetadataDataView {
 public:
  FirstPartySetMetadataDataView() = default;

  FirstPartySetMetadataDataView(
      internal::FirstPartySetMetadata_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetContextDataView(
      SamePartyContextDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadContext(UserType* output) {
    
    auto* pointer = data_->context.Get();
    return mojo::internal::Deserialize<::network::mojom::SamePartyContextDataView>(
        pointer, output, message_);
  }
  inline void GetFrameEntryDataView(
      FirstPartySetEntryDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFrameEntry(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::network::mojom::FirstPartySetEntryDataView, UserType>(),
    "Attempting to read the optional `frame_entry` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadFrameEntry` instead "
    "of `ReadFrameEntry if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->frame_entry.Get();
    return mojo::internal::Deserialize<::network::mojom::FirstPartySetEntryDataView>(
        pointer, output, message_);
  }
  inline void GetTopFrameEntryDataView(
      FirstPartySetEntryDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTopFrameEntry(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::network::mojom::FirstPartySetEntryDataView, UserType>(),
    "Attempting to read the optional `top_frame_entry` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadTopFrameEntry` instead "
    "of `ReadTopFrameEntry if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->top_frame_entry.Get();
    return mojo::internal::Deserialize<::network::mojom::FirstPartySetEntryDataView>(
        pointer, output, message_);
  }
 private:
  internal::FirstPartySetMetadata_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



}  // namespace mojom
}  // namespace network

namespace std {

template <>
struct hash<::network::mojom::SiteType>
    : public mojo::internal::EnumHashImpl<::network::mojom::SiteType> {};

template <>
struct hash<::network::mojom::SamePartyCookieContextType>
    : public mojo::internal::EnumHashImpl<::network::mojom::SamePartyCookieContextType> {};

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::network::mojom::SiteType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::network::mojom::SiteType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::network::mojom::SiteType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::network::mojom::SamePartyCookieContextType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::network::mojom::SamePartyCookieContextType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::network::mojom::SamePartyCookieContextType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::network::mojom::SiteIndexDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::network::mojom::SiteIndexDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::network::mojom::internal::SiteIndex_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->value = Traits::value(input);
  }

  static bool Deserialize(::network::mojom::internal::SiteIndex_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::network::mojom::SiteIndexDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::network::mojom::FirstPartySetEntryDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::network::mojom::FirstPartySetEntryDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::network::mojom::internal::FirstPartySetEntry_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::primary(input)) in_primary = Traits::primary(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->primary)::BaseType> primary_fragment(
            fragment.message());
    mojo::internal::Serialize<::network::mojom::SchemefulSiteDataView>(
        in_primary, primary_fragment);
    fragment->primary.Set(
        primary_fragment.is_null() ? nullptr : primary_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->primary.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null primary in FirstPartySetEntry struct");
    mojo::internal::Serialize<::network::mojom::SiteType>(
        Traits::site_type(input), &fragment->site_type);
    decltype(Traits::site_index(input)) in_site_index = Traits::site_index(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->site_index)::BaseType> site_index_fragment(
            fragment.message());
    mojo::internal::Serialize<::network::mojom::SiteIndexDataView>(
        in_site_index, site_index_fragment);
    fragment->site_index.Set(
        site_index_fragment.is_null() ? nullptr : site_index_fragment.data());
  }

  static bool Deserialize(::network::mojom::internal::FirstPartySetEntry_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::network::mojom::FirstPartySetEntryDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::network::mojom::SamePartyContextDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::network::mojom::SamePartyContextDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::network::mojom::internal::SamePartyContext_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::network::mojom::SamePartyCookieContextType>(
        Traits::context_type(input), &fragment->context_type);
  }

  static bool Deserialize(::network::mojom::internal::SamePartyContext_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::network::mojom::SamePartyContextDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::network::mojom::FirstPartySetMetadataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::network::mojom::FirstPartySetMetadataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::network::mojom::internal::FirstPartySetMetadata_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::context(input)) in_context = Traits::context(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->context)::BaseType> context_fragment(
            fragment.message());
    mojo::internal::Serialize<::network::mojom::SamePartyContextDataView>(
        in_context, context_fragment);
    fragment->context.Set(
        context_fragment.is_null() ? nullptr : context_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->context.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null context in FirstPartySetMetadata struct");
    decltype(Traits::frame_entry(input)) in_frame_entry = Traits::frame_entry(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->frame_entry)::BaseType> frame_entry_fragment(
            fragment.message());
    mojo::internal::Serialize<::network::mojom::FirstPartySetEntryDataView>(
        in_frame_entry, frame_entry_fragment);
    fragment->frame_entry.Set(
        frame_entry_fragment.is_null() ? nullptr : frame_entry_fragment.data());
    decltype(Traits::top_frame_entry(input)) in_top_frame_entry = Traits::top_frame_entry(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->top_frame_entry)::BaseType> top_frame_entry_fragment(
            fragment.message());
    mojo::internal::Serialize<::network::mojom::FirstPartySetEntryDataView>(
        in_top_frame_entry, top_frame_entry_fragment);
    fragment->top_frame_entry.Set(
        top_frame_entry_fragment.is_null() ? nullptr : top_frame_entry_fragment.data());
  }

  static bool Deserialize(::network::mojom::internal::FirstPartySetMetadata_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::network::mojom::FirstPartySetMetadataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace network {
namespace mojom {



inline void FirstPartySetEntryDataView::GetPrimaryDataView(
    ::network::mojom::SchemefulSiteDataView* output) {
  auto pointer = data_->primary.Get();
  *output = ::network::mojom::SchemefulSiteDataView(pointer, message_);
}
inline void FirstPartySetEntryDataView::GetSiteIndexDataView(
    SiteIndexDataView* output) {
  auto pointer = data_->site_index.Get();
  *output = SiteIndexDataView(pointer, message_);
}




inline void FirstPartySetMetadataDataView::GetContextDataView(
    SamePartyContextDataView* output) {
  auto pointer = data_->context.Get();
  *output = SamePartyContextDataView(pointer, message_);
}
inline void FirstPartySetMetadataDataView::GetFrameEntryDataView(
    FirstPartySetEntryDataView* output) {
  auto pointer = data_->frame_entry.Get();
  *output = FirstPartySetEntryDataView(pointer, message_);
}
inline void FirstPartySetMetadataDataView::GetTopFrameEntryDataView(
    FirstPartySetEntryDataView* output) {
  auto pointer = data_->top_frame_entry.Get();
  *output = FirstPartySetEntryDataView(pointer, message_);
}



}  // namespace mojom
}  // namespace network

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <>
struct  TraceFormatTraits<::network::mojom::SiteType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::network::mojom::SiteType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::network::mojom::SamePartyCookieContextType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::network::mojom::SamePartyCookieContextType value);
};

} // namespace perfetto

#endif  // SERVICES_NETWORK_PUBLIC_MOJOM_FIRST_PARTY_SETS_MOJOM_SHARED_H_