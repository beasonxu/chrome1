// media/capture/mojom/video_capture_types.mojom-shared.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "media/capture/mojom/video_capture_types.mojom-shared.h"

// Used to support stream output operator for enums.
// TODO(dcheng): Consider omitting this somehow if not needed.
#include <ostream>
#include <utility>

#include "base/strings/stringprintf.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "media/capture/mojom/video_capture_types.mojom-params-data.h"
namespace media {
namespace mojom {

static NOINLINE const char* VideoCapturePixelFormatToStringHelper(VideoCapturePixelFormat value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case VideoCapturePixelFormat::UNKNOWN:
      return "UNKNOWN";
    case VideoCapturePixelFormat::I420:
      return "I420";
    case VideoCapturePixelFormat::YV12:
      return "YV12";
    case VideoCapturePixelFormat::I422:
      return "I422";
    case VideoCapturePixelFormat::I420A:
      return "I420A";
    case VideoCapturePixelFormat::I444:
      return "I444";
    case VideoCapturePixelFormat::NV12:
      return "NV12";
    case VideoCapturePixelFormat::NV21:
      return "NV21";
    case VideoCapturePixelFormat::UYVY:
      return "UYVY";
    case VideoCapturePixelFormat::YUY2:
      return "YUY2";
    case VideoCapturePixelFormat::ARGB:
      return "ARGB";
    case VideoCapturePixelFormat::XRGB:
      return "XRGB";
    case VideoCapturePixelFormat::RGB24:
      return "RGB24";
    case VideoCapturePixelFormat::MJPEG:
      return "MJPEG";
    case VideoCapturePixelFormat::YUV420P9:
      return "YUV420P9";
    case VideoCapturePixelFormat::YUV420P10:
      return "YUV420P10";
    case VideoCapturePixelFormat::YUV422P9:
      return "YUV422P9";
    case VideoCapturePixelFormat::YUV422P10:
      return "YUV422P10";
    case VideoCapturePixelFormat::YUV444P9:
      return "YUV444P9";
    case VideoCapturePixelFormat::YUV444P10:
      return "YUV444P10";
    case VideoCapturePixelFormat::YUV420P12:
      return "YUV420P12";
    case VideoCapturePixelFormat::YUV422P12:
      return "YUV422P12";
    case VideoCapturePixelFormat::YUV444P12:
      return "YUV444P12";
    case VideoCapturePixelFormat::Y16:
      return "Y16";
    case VideoCapturePixelFormat::ABGR:
      return "ABGR";
    case VideoCapturePixelFormat::XBGR:
      return "XBGR";
    case VideoCapturePixelFormat::P016LE:
      return "P016LE";
    case VideoCapturePixelFormat::XR30:
      return "XR30";
    case VideoCapturePixelFormat::XB30:
      return "XB30";
    case VideoCapturePixelFormat::BGRA:
      return "BGRA";
    case VideoCapturePixelFormat::RGBAF16:
      return "RGBAF16";
    case VideoCapturePixelFormat::I422A:
      return "I422A";
    case VideoCapturePixelFormat::I444A:
      return "I444A";
    case VideoCapturePixelFormat::YUV420AP10:
      return "YUV420AP10";
    case VideoCapturePixelFormat::YUV422AP10:
      return "YUV422AP10";
    case VideoCapturePixelFormat::YUV444AP10:
      return "YUV444AP10";
    default:
      return nullptr;
  }
}

std::string VideoCapturePixelFormatToString(VideoCapturePixelFormat value) {
  const char *str = VideoCapturePixelFormatToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown VideoCapturePixelFormat value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, VideoCapturePixelFormat value) {
  return os << VideoCapturePixelFormatToString(value);
}

static NOINLINE const char* ResolutionChangePolicyToStringHelper(ResolutionChangePolicy value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case ResolutionChangePolicy::FIXED_RESOLUTION:
      return "FIXED_RESOLUTION";
    case ResolutionChangePolicy::FIXED_ASPECT_RATIO:
      return "FIXED_ASPECT_RATIO";
    case ResolutionChangePolicy::ANY_WITHIN_LIMIT:
      return "ANY_WITHIN_LIMIT";
    default:
      return nullptr;
  }
}

std::string ResolutionChangePolicyToString(ResolutionChangePolicy value) {
  const char *str = ResolutionChangePolicyToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown ResolutionChangePolicy value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, ResolutionChangePolicy value) {
  return os << ResolutionChangePolicyToString(value);
}

static NOINLINE const char* PowerLineFrequencyToStringHelper(PowerLineFrequency value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case PowerLineFrequency::DEFAULT:
      return "DEFAULT";
    case PowerLineFrequency::HZ_50:
      return "HZ_50";
    case PowerLineFrequency::HZ_60:
      return "HZ_60";
    default:
      return nullptr;
  }
}

std::string PowerLineFrequencyToString(PowerLineFrequency value) {
  const char *str = PowerLineFrequencyToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown PowerLineFrequency value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, PowerLineFrequency value) {
  return os << PowerLineFrequencyToString(value);
}

static NOINLINE const char* VideoFacingModeToStringHelper(VideoFacingMode value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case VideoFacingMode::NONE:
      return "NONE";
    case VideoFacingMode::USER:
      return "USER";
    case VideoFacingMode::ENVIRONMENT:
      return "ENVIRONMENT";
    default:
      return nullptr;
  }
}

std::string VideoFacingModeToString(VideoFacingMode value) {
  const char *str = VideoFacingModeToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown VideoFacingMode value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, VideoFacingMode value) {
  return os << VideoFacingModeToString(value);
}

static NOINLINE const char* VideoCaptureApiToStringHelper(VideoCaptureApi value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case VideoCaptureApi::LINUX_V4L2_SINGLE_PLANE:
      return "LINUX_V4L2_SINGLE_PLANE";
    case VideoCaptureApi::WIN_MEDIA_FOUNDATION:
      return "WIN_MEDIA_FOUNDATION";
    case VideoCaptureApi::WIN_MEDIA_FOUNDATION_SENSOR:
      return "WIN_MEDIA_FOUNDATION_SENSOR";
    case VideoCaptureApi::WIN_DIRECT_SHOW:
      return "WIN_DIRECT_SHOW";
    case VideoCaptureApi::MACOSX_AVFOUNDATION:
      return "MACOSX_AVFOUNDATION";
    case VideoCaptureApi::MACOSX_DECKLINK:
      return "MACOSX_DECKLINK";
    case VideoCaptureApi::ANDROID_API1:
      return "ANDROID_API1";
    case VideoCaptureApi::ANDROID_API2_LEGACY:
      return "ANDROID_API2_LEGACY";
    case VideoCaptureApi::ANDROID_API2_FULL:
      return "ANDROID_API2_FULL";
    case VideoCaptureApi::ANDROID_API2_LIMITED:
      return "ANDROID_API2_LIMITED";
    case VideoCaptureApi::FUCHSIA_CAMERA3:
      return "FUCHSIA_CAMERA3";
    case VideoCaptureApi::VIRTUAL_DEVICE:
      return "VIRTUAL_DEVICE";
    case VideoCaptureApi::UNKNOWN:
      return "UNKNOWN";
    default:
      return nullptr;
  }
}

std::string VideoCaptureApiToString(VideoCaptureApi value) {
  const char *str = VideoCaptureApiToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown VideoCaptureApi value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, VideoCaptureApi value) {
  return os << VideoCaptureApiToString(value);
}

static NOINLINE const char* VideoCaptureTransportTypeToStringHelper(VideoCaptureTransportType value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case VideoCaptureTransportType::MACOSX_USB_OR_BUILT_IN:
      return "MACOSX_USB_OR_BUILT_IN";
    case VideoCaptureTransportType::OTHER_TRANSPORT:
      return "OTHER_TRANSPORT";
    default:
      return nullptr;
  }
}

std::string VideoCaptureTransportTypeToString(VideoCaptureTransportType value) {
  const char *str = VideoCaptureTransportTypeToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown VideoCaptureTransportType value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, VideoCaptureTransportType value) {
  return os << VideoCaptureTransportTypeToString(value);
}

static NOINLINE const char* VideoCaptureBufferTypeToStringHelper(VideoCaptureBufferType value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case VideoCaptureBufferType::kSharedMemory:
      return "kSharedMemory";
    case VideoCaptureBufferType::kSharedMemoryViaRawFileDescriptor:
      return "kSharedMemoryViaRawFileDescriptor";
    case VideoCaptureBufferType::kMailboxHolder:
      return "kMailboxHolder";
    case VideoCaptureBufferType::kGpuMemoryBuffer:
      return "kGpuMemoryBuffer";
    default:
      return nullptr;
  }
}

std::string VideoCaptureBufferTypeToString(VideoCaptureBufferType value) {
  const char *str = VideoCaptureBufferTypeToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown VideoCaptureBufferType value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, VideoCaptureBufferType value) {
  return os << VideoCaptureBufferTypeToString(value);
}

static NOINLINE const char* VideoCaptureErrorToStringHelper(VideoCaptureError value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case VideoCaptureError::kNone:
      return "kNone";
    case VideoCaptureError::kVideoCaptureControllerInvalidOrUnsupportedVideoCaptureParametersRequested:
      return "kVideoCaptureControllerInvalidOrUnsupportedVideoCaptureParametersRequested";
    case VideoCaptureError::kVideoCaptureControllerIsAlreadyInErrorState:
      return "kVideoCaptureControllerIsAlreadyInErrorState";
    case VideoCaptureError::kVideoCaptureManagerDeviceConnectionLost:
      return "kVideoCaptureManagerDeviceConnectionLost";
    case VideoCaptureError::kFrameSinkVideoCaptureDeviceAlreadyEndedOnFatalError:
      return "kFrameSinkVideoCaptureDeviceAlreadyEndedOnFatalError";
    case VideoCaptureError::kFrameSinkVideoCaptureDeviceEncounteredFatalError:
      return "kFrameSinkVideoCaptureDeviceEncounteredFatalError";
    case VideoCaptureError::kV4L2FailedToOpenV4L2DeviceDriverFile:
      return "kV4L2FailedToOpenV4L2DeviceDriverFile";
    case VideoCaptureError::kV4L2ThisIsNotAV4L2VideoCaptureDevice:
      return "kV4L2ThisIsNotAV4L2VideoCaptureDevice";
    case VideoCaptureError::kV4L2FailedToFindASupportedCameraFormat:
      return "kV4L2FailedToFindASupportedCameraFormat";
    case VideoCaptureError::kV4L2FailedToSetVideoCaptureFormat:
      return "kV4L2FailedToSetVideoCaptureFormat";
    case VideoCaptureError::kV4L2UnsupportedPixelFormat:
      return "kV4L2UnsupportedPixelFormat";
    case VideoCaptureError::kV4L2FailedToSetCameraFramerate:
      return "kV4L2FailedToSetCameraFramerate";
    case VideoCaptureError::kV4L2ErrorRequestingMmapBuffers:
      return "kV4L2ErrorRequestingMmapBuffers";
    case VideoCaptureError::kV4L2AllocateBufferFailed:
      return "kV4L2AllocateBufferFailed";
    case VideoCaptureError::kV4L2VidiocStreamonFailed:
      return "kV4L2VidiocStreamonFailed";
    case VideoCaptureError::kV4L2VidiocStreamoffFailed:
      return "kV4L2VidiocStreamoffFailed";
    case VideoCaptureError::kV4L2FailedToVidiocReqbufsWithCount0:
      return "kV4L2FailedToVidiocReqbufsWithCount0";
    case VideoCaptureError::kV4L2PollFailed:
      return "kV4L2PollFailed";
    case VideoCaptureError::kV4L2MultipleContinuousTimeoutsWhileReadPolling:
      return "kV4L2MultipleContinuousTimeoutsWhileReadPolling";
    case VideoCaptureError::kV4L2FailedToDequeueCaptureBuffer:
      return "kV4L2FailedToDequeueCaptureBuffer";
    case VideoCaptureError::kV4L2FailedToEnqueueCaptureBuffer:
      return "kV4L2FailedToEnqueueCaptureBuffer";
    case VideoCaptureError::kSingleClientVideoCaptureHostLostConnectionToDevice:
      return "kSingleClientVideoCaptureHostLostConnectionToDevice";
    case VideoCaptureError::kSingleClientVideoCaptureDeviceLaunchAborted:
      return "kSingleClientVideoCaptureDeviceLaunchAborted";
    case VideoCaptureError::kDesktopCaptureDeviceWebrtcDesktopCapturerHasFailed:
      return "kDesktopCaptureDeviceWebrtcDesktopCapturerHasFailed";
    case VideoCaptureError::kFileVideoCaptureDeviceCouldNotOpenVideoFile:
      return "kFileVideoCaptureDeviceCouldNotOpenVideoFile";
    case VideoCaptureError::kDeviceCaptureLinuxFailedToCreateVideoCaptureDelegate:
      return "kDeviceCaptureLinuxFailedToCreateVideoCaptureDelegate";
    case VideoCaptureError::kErrorFakeDeviceIntentionallyEmittingErrorEvent:
      return "kErrorFakeDeviceIntentionallyEmittingErrorEvent";
    case VideoCaptureError::kDeviceClientTooManyFramesDroppedY16:
      return "kDeviceClientTooManyFramesDroppedY16";
    case VideoCaptureError::kDeviceMediaToMojoAdapterEncounteredUnsupportedBufferType:
      return "kDeviceMediaToMojoAdapterEncounteredUnsupportedBufferType";
    case VideoCaptureError::kVideoCaptureManagerProcessDeviceStartQueueDeviceInfoNotFound:
      return "kVideoCaptureManagerProcessDeviceStartQueueDeviceInfoNotFound";
    case VideoCaptureError::kInProcessDeviceLauncherFailedToCreateDeviceInstance:
      return "kInProcessDeviceLauncherFailedToCreateDeviceInstance";
    case VideoCaptureError::kServiceDeviceLauncherLostConnectionToDeviceFactoryDuringDeviceStart:
      return "kServiceDeviceLauncherLostConnectionToDeviceFactoryDuringDeviceStart";
    case VideoCaptureError::kServiceDeviceLauncherServiceRespondedWithDeviceNotFound:
      return "kServiceDeviceLauncherServiceRespondedWithDeviceNotFound";
    case VideoCaptureError::kServiceDeviceLauncherConnectionLostWhileWaitingForCallback:
      return "kServiceDeviceLauncherConnectionLostWhileWaitingForCallback";
    case VideoCaptureError::kIntentionalErrorRaisedByUnitTest:
      return "kIntentionalErrorRaisedByUnitTest";
    case VideoCaptureError::kCrosHalV3FailedToStartDeviceThread:
      return "kCrosHalV3FailedToStartDeviceThread";
    case VideoCaptureError::kCrosHalV3DeviceDelegateMojoConnectionError:
      return "kCrosHalV3DeviceDelegateMojoConnectionError";
    case VideoCaptureError::kCrosHalV3DeviceDelegateFailedToGetCameraInfo:
      return "kCrosHalV3DeviceDelegateFailedToGetCameraInfo";
    case VideoCaptureError::kCrosHalV3DeviceDelegateMissingSensorOrientationInfo:
      return "kCrosHalV3DeviceDelegateMissingSensorOrientationInfo";
    case VideoCaptureError::kCrosHalV3DeviceDelegateFailedToOpenCameraDevice:
      return "kCrosHalV3DeviceDelegateFailedToOpenCameraDevice";
    case VideoCaptureError::kCrosHalV3DeviceDelegateFailedToInitializeCameraDevice:
      return "kCrosHalV3DeviceDelegateFailedToInitializeCameraDevice";
    case VideoCaptureError::kCrosHalV3DeviceDelegateFailedToConfigureStreams:
      return "kCrosHalV3DeviceDelegateFailedToConfigureStreams";
    case VideoCaptureError::kCrosHalV3DeviceDelegateWrongNumberOfStreamsConfigured:
      return "kCrosHalV3DeviceDelegateWrongNumberOfStreamsConfigured";
    case VideoCaptureError::kCrosHalV3DeviceDelegateFailedToGetDefaultRequestSettings:
      return "kCrosHalV3DeviceDelegateFailedToGetDefaultRequestSettings";
    case VideoCaptureError::kCrosHalV3BufferManagerHalRequestedTooManyBuffers:
      return "kCrosHalV3BufferManagerHalRequestedTooManyBuffers";
    case VideoCaptureError::kCrosHalV3BufferManagerFailedToCreateGpuMemoryBuffer:
      return "kCrosHalV3BufferManagerFailedToCreateGpuMemoryBuffer";
    case VideoCaptureError::kCrosHalV3BufferManagerFailedToMapGpuMemoryBuffer:
      return "kCrosHalV3BufferManagerFailedToMapGpuMemoryBuffer";
    case VideoCaptureError::kCrosHalV3BufferManagerUnsupportedVideoPixelFormat:
      return "kCrosHalV3BufferManagerUnsupportedVideoPixelFormat";
    case VideoCaptureError::kCrosHalV3BufferManagerFailedToDupFd:
      return "kCrosHalV3BufferManagerFailedToDupFd";
    case VideoCaptureError::kCrosHalV3BufferManagerFailedToWrapGpuMemoryHandle:
      return "kCrosHalV3BufferManagerFailedToWrapGpuMemoryHandle";
    case VideoCaptureError::kCrosHalV3BufferManagerFailedToRegisterBuffer:
      return "kCrosHalV3BufferManagerFailedToRegisterBuffer";
    case VideoCaptureError::kCrosHalV3BufferManagerProcessCaptureRequestFailed:
      return "kCrosHalV3BufferManagerProcessCaptureRequestFailed";
    case VideoCaptureError::kCrosHalV3BufferManagerInvalidPendingResultId:
      return "kCrosHalV3BufferManagerInvalidPendingResultId";
    case VideoCaptureError::kCrosHalV3BufferManagerReceivedDuplicatedPartialMetadata:
      return "kCrosHalV3BufferManagerReceivedDuplicatedPartialMetadata";
    case VideoCaptureError::kCrosHalV3BufferManagerIncorrectNumberOfOutputBuffersReceived:
      return "kCrosHalV3BufferManagerIncorrectNumberOfOutputBuffersReceived";
    case VideoCaptureError::kCrosHalV3BufferManagerInvalidTypeOfOutputBuffersReceived:
      return "kCrosHalV3BufferManagerInvalidTypeOfOutputBuffersReceived";
    case VideoCaptureError::kCrosHalV3BufferManagerReceivedMultipleResultBuffersForFrame:
      return "kCrosHalV3BufferManagerReceivedMultipleResultBuffersForFrame";
    case VideoCaptureError::kCrosHalV3BufferManagerUnknownStreamInCamera3NotifyMsg:
      return "kCrosHalV3BufferManagerUnknownStreamInCamera3NotifyMsg";
    case VideoCaptureError::kCrosHalV3BufferManagerReceivedInvalidShutterTime:
      return "kCrosHalV3BufferManagerReceivedInvalidShutterTime";
    case VideoCaptureError::kCrosHalV3BufferManagerFatalDeviceError:
      return "kCrosHalV3BufferManagerFatalDeviceError";
    case VideoCaptureError::kCrosHalV3BufferManagerReceivedFrameIsOutOfOrder:
      return "kCrosHalV3BufferManagerReceivedFrameIsOutOfOrder";
    case VideoCaptureError::kCrosHalV3BufferManagerFailedToUnwrapReleaseFenceFd:
      return "kCrosHalV3BufferManagerFailedToUnwrapReleaseFenceFd";
    case VideoCaptureError::kCrosHalV3BufferManagerSyncWaitOnReleaseFenceTimedOut:
      return "kCrosHalV3BufferManagerSyncWaitOnReleaseFenceTimedOut";
    case VideoCaptureError::kCrosHalV3BufferManagerInvalidJpegBlob:
      return "kCrosHalV3BufferManagerInvalidJpegBlob";
    case VideoCaptureError::kAndroidFailedToAllocate:
      return "kAndroidFailedToAllocate";
    case VideoCaptureError::kAndroidFailedToStartCapture:
      return "kAndroidFailedToStartCapture";
    case VideoCaptureError::kAndroidFailedToStopCapture:
      return "kAndroidFailedToStopCapture";
    case VideoCaptureError::kAndroidApi1CameraErrorCallbackReceived:
      return "kAndroidApi1CameraErrorCallbackReceived";
    case VideoCaptureError::kAndroidApi2CameraDeviceErrorReceived:
      return "kAndroidApi2CameraDeviceErrorReceived";
    case VideoCaptureError::kAndroidApi2CaptureSessionConfigureFailed:
      return "kAndroidApi2CaptureSessionConfigureFailed";
    case VideoCaptureError::kAndroidApi2ImageReaderUnexpectedImageFormat:
      return "kAndroidApi2ImageReaderUnexpectedImageFormat";
    case VideoCaptureError::kAndroidApi2ImageReaderSizeDidNotMatchImageSize:
      return "kAndroidApi2ImageReaderSizeDidNotMatchImageSize";
    case VideoCaptureError::kAndroidApi2ErrorRestartingPreview:
      return "kAndroidApi2ErrorRestartingPreview";
    case VideoCaptureError::kAndroidScreenCaptureUnsupportedFormat:
      return "kAndroidScreenCaptureUnsupportedFormat";
    case VideoCaptureError::kAndroidScreenCaptureFailedToStartCaptureMachine:
      return "kAndroidScreenCaptureFailedToStartCaptureMachine";
    case VideoCaptureError::kAndroidScreenCaptureTheUserDeniedScreenCapture:
      return "kAndroidScreenCaptureTheUserDeniedScreenCapture";
    case VideoCaptureError::kAndroidScreenCaptureFailedToStartScreenCapture:
      return "kAndroidScreenCaptureFailedToStartScreenCapture";
    case VideoCaptureError::kWinDirectShowCantGetCaptureFormatSettings:
      return "kWinDirectShowCantGetCaptureFormatSettings";
    case VideoCaptureError::kWinDirectShowFailedToGetNumberOfCapabilities:
      return "kWinDirectShowFailedToGetNumberOfCapabilities";
    case VideoCaptureError::kWinDirectShowFailedToGetCaptureDeviceCapabilities:
      return "kWinDirectShowFailedToGetCaptureDeviceCapabilities";
    case VideoCaptureError::kWinDirectShowFailedToSetCaptureDeviceOutputFormat:
      return "kWinDirectShowFailedToSetCaptureDeviceOutputFormat";
    case VideoCaptureError::kWinDirectShowFailedToConnectTheCaptureGraph:
      return "kWinDirectShowFailedToConnectTheCaptureGraph";
    case VideoCaptureError::kWinDirectShowFailedToPauseTheCaptureDevice:
      return "kWinDirectShowFailedToPauseTheCaptureDevice";
    case VideoCaptureError::kWinDirectShowFailedToStartTheCaptureDevice:
      return "kWinDirectShowFailedToStartTheCaptureDevice";
    case VideoCaptureError::kWinDirectShowFailedToStopTheCaptureGraph:
      return "kWinDirectShowFailedToStopTheCaptureGraph";
    case VideoCaptureError::kWinMediaFoundationEngineIsNull:
      return "kWinMediaFoundationEngineIsNull";
    case VideoCaptureError::kWinMediaFoundationEngineGetSourceFailed:
      return "kWinMediaFoundationEngineGetSourceFailed";
    case VideoCaptureError::kWinMediaFoundationFillPhotoCapabilitiesFailed:
      return "kWinMediaFoundationFillPhotoCapabilitiesFailed";
    case VideoCaptureError::kWinMediaFoundationFillVideoCapabilitiesFailed:
      return "kWinMediaFoundationFillVideoCapabilitiesFailed";
    case VideoCaptureError::kWinMediaFoundationNoVideoCapabilityFound:
      return "kWinMediaFoundationNoVideoCapabilityFound";
    case VideoCaptureError::kWinMediaFoundationGetAvailableDeviceMediaTypeFailed:
      return "kWinMediaFoundationGetAvailableDeviceMediaTypeFailed";
    case VideoCaptureError::kWinMediaFoundationSetCurrentDeviceMediaTypeFailed:
      return "kWinMediaFoundationSetCurrentDeviceMediaTypeFailed";
    case VideoCaptureError::kWinMediaFoundationEngineGetSinkFailed:
      return "kWinMediaFoundationEngineGetSinkFailed";
    case VideoCaptureError::kWinMediaFoundationSinkQueryCapturePreviewInterfaceFailed:
      return "kWinMediaFoundationSinkQueryCapturePreviewInterfaceFailed";
    case VideoCaptureError::kWinMediaFoundationSinkRemoveAllStreamsFailed:
      return "kWinMediaFoundationSinkRemoveAllStreamsFailed";
    case VideoCaptureError::kWinMediaFoundationCreateSinkVideoMediaTypeFailed:
      return "kWinMediaFoundationCreateSinkVideoMediaTypeFailed";
    case VideoCaptureError::kWinMediaFoundationConvertToVideoSinkMediaTypeFailed:
      return "kWinMediaFoundationConvertToVideoSinkMediaTypeFailed";
    case VideoCaptureError::kWinMediaFoundationSinkAddStreamFailed:
      return "kWinMediaFoundationSinkAddStreamFailed";
    case VideoCaptureError::kWinMediaFoundationSinkSetSampleCallbackFailed:
      return "kWinMediaFoundationSinkSetSampleCallbackFailed";
    case VideoCaptureError::kWinMediaFoundationEngineStartPreviewFailed:
      return "kWinMediaFoundationEngineStartPreviewFailed";
    case VideoCaptureError::kWinMediaFoundationGetMediaEventStatusFailed:
      return "kWinMediaFoundationGetMediaEventStatusFailed";
    case VideoCaptureError::kMacSetCaptureDeviceFailed:
      return "kMacSetCaptureDeviceFailed";
    case VideoCaptureError::kMacCouldNotStartCaptureDevice:
      return "kMacCouldNotStartCaptureDevice";
    case VideoCaptureError::kMacReceivedFrameWithUnexpectedResolution:
      return "kMacReceivedFrameWithUnexpectedResolution";
    case VideoCaptureError::kMacUpdateCaptureResolutionFailed:
      return "kMacUpdateCaptureResolutionFailed";
    case VideoCaptureError::kMacDeckLinkDeviceIdNotFoundInTheSystem:
      return "kMacDeckLinkDeviceIdNotFoundInTheSystem";
    case VideoCaptureError::kMacDeckLinkErrorQueryingInputInterface:
      return "kMacDeckLinkErrorQueryingInputInterface";
    case VideoCaptureError::kMacDeckLinkErrorCreatingDisplayModeIterator:
      return "kMacDeckLinkErrorCreatingDisplayModeIterator";
    case VideoCaptureError::kMacDeckLinkCouldNotFindADisplayMode:
      return "kMacDeckLinkCouldNotFindADisplayMode";
    case VideoCaptureError::kMacDeckLinkCouldNotSelectTheVideoFormatWeLike:
      return "kMacDeckLinkCouldNotSelectTheVideoFormatWeLike";
    case VideoCaptureError::kMacDeckLinkCouldNotStartCapturing:
      return "kMacDeckLinkCouldNotStartCapturing";
    case VideoCaptureError::kMacDeckLinkUnsupportedPixelFormat:
      return "kMacDeckLinkUnsupportedPixelFormat";
    case VideoCaptureError::kMacAvFoundationReceivedAVCaptureSessionRuntimeErrorNotification:
      return "kMacAvFoundationReceivedAVCaptureSessionRuntimeErrorNotification";
    case VideoCaptureError::kAndroidApi2ErrorConfiguringCamera:
      return "kAndroidApi2ErrorConfiguringCamera";
    case VideoCaptureError::kCrosHalV3DeviceDelegateFailedToFlush:
      return "kCrosHalV3DeviceDelegateFailedToFlush";
    case VideoCaptureError::kFuchsiaCameraDeviceDisconnected:
      return "kFuchsiaCameraDeviceDisconnected";
    case VideoCaptureError::kFuchsiaCameraStreamDisconnected:
      return "kFuchsiaCameraStreamDisconnected";
    case VideoCaptureError::kFuchsiaSysmemDidNotSetImageFormat:
      return "kFuchsiaSysmemDidNotSetImageFormat";
    case VideoCaptureError::kFuchsiaSysmemInvalidBufferIndex:
      return "kFuchsiaSysmemInvalidBufferIndex";
    case VideoCaptureError::kFuchsiaSysmemInvalidBufferSize:
      return "kFuchsiaSysmemInvalidBufferSize";
    case VideoCaptureError::kFuchsiaUnsupportedPixelFormat:
      return "kFuchsiaUnsupportedPixelFormat";
    case VideoCaptureError::kFuchsiaFailedToMapSysmemBuffer:
      return "kFuchsiaFailedToMapSysmemBuffer";
    case VideoCaptureError::kCrosHalV3DeviceContextDuplicatedClient:
      return "kCrosHalV3DeviceContextDuplicatedClient";
    case VideoCaptureError::kDesktopCaptureDeviceMacFailedStreamCreate:
      return "kDesktopCaptureDeviceMacFailedStreamCreate";
    case VideoCaptureError::kDesktopCaptureDeviceMacFailedStreamStart:
      return "kDesktopCaptureDeviceMacFailedStreamStart";
    case VideoCaptureError::kCrosHalV3BufferManagerFailedToReserveBuffers:
      return "kCrosHalV3BufferManagerFailedToReserveBuffers";
    case VideoCaptureError::kWinMediaFoundationSystemPermissionDenied:
      return "kWinMediaFoundationSystemPermissionDenied";
    case VideoCaptureError::kVideoCaptureImplTimedOutOnStart:
      return "kVideoCaptureImplTimedOutOnStart";
    case VideoCaptureError::kLacrosVideoCaptureDeviceProxyAlreadyEndedOnFatalError:
      return "kLacrosVideoCaptureDeviceProxyAlreadyEndedOnFatalError";
    case VideoCaptureError::kLacrosVideoCaptureDeviceProxyEncounteredFatalError:
      return "kLacrosVideoCaptureDeviceProxyEncounteredFatalError";
    case VideoCaptureError::kScreenCaptureKitFailedGetShareableContent:
      return "kScreenCaptureKitFailedGetShareableContent";
    case VideoCaptureError::kScreenCaptureKitFailedAddStreamOutput:
      return "kScreenCaptureKitFailedAddStreamOutput";
    case VideoCaptureError::kScreenCaptureKitFailedStartCapture:
      return "kScreenCaptureKitFailedStartCapture";
    case VideoCaptureError::kScreenCaptureKitFailedStopCapture:
      return "kScreenCaptureKitFailedStopCapture";
    case VideoCaptureError::kScreenCaptureKitStreamError:
      return "kScreenCaptureKitStreamError";
    case VideoCaptureError::kScreenCaptureKitFailedToFindSCDisplay:
      return "kScreenCaptureKitFailedToFindSCDisplay";
    default:
      return nullptr;
  }
}

std::string VideoCaptureErrorToString(VideoCaptureError value) {
  const char *str = VideoCaptureErrorToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown VideoCaptureError value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, VideoCaptureError value) {
  return os << VideoCaptureErrorToString(value);
}

static NOINLINE const char* VideoCaptureFrameDropReasonToStringHelper(VideoCaptureFrameDropReason value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case VideoCaptureFrameDropReason::kNone:
      return "kNone";
    case VideoCaptureFrameDropReason::kDeviceClientFrameHasInvalidFormat:
      return "kDeviceClientFrameHasInvalidFormat";
    case VideoCaptureFrameDropReason::kDeviceClientLibyuvConvertToI420Failed:
      return "kDeviceClientLibyuvConvertToI420Failed";
    case VideoCaptureFrameDropReason::kV4L2BufferErrorFlagWasSet:
      return "kV4L2BufferErrorFlagWasSet";
    case VideoCaptureFrameDropReason::kV4L2InvalidNumberOfBytesInBuffer:
      return "kV4L2InvalidNumberOfBytesInBuffer";
    case VideoCaptureFrameDropReason::kAndroidThrottling:
      return "kAndroidThrottling";
    case VideoCaptureFrameDropReason::kAndroidGetByteArrayElementsFailed:
      return "kAndroidGetByteArrayElementsFailed";
    case VideoCaptureFrameDropReason::kAndroidApi1UnexpectedDataLength:
      return "kAndroidApi1UnexpectedDataLength";
    case VideoCaptureFrameDropReason::kAndroidApi2AcquiredImageIsNull:
      return "kAndroidApi2AcquiredImageIsNull";
    case VideoCaptureFrameDropReason::kWinDirectShowUnexpectedSampleLength:
      return "kWinDirectShowUnexpectedSampleLength";
    case VideoCaptureFrameDropReason::kWinDirectShowFailedToGetMemoryPointerFromMediaSample:
      return "kWinDirectShowFailedToGetMemoryPointerFromMediaSample";
    case VideoCaptureFrameDropReason::kWinMediaFoundationReceivedSampleIsNull:
      return "kWinMediaFoundationReceivedSampleIsNull";
    case VideoCaptureFrameDropReason::kWinMediaFoundationLockingBufferDelieveredNullptr:
      return "kWinMediaFoundationLockingBufferDelieveredNullptr";
    case VideoCaptureFrameDropReason::kWinMediaFoundationGetBufferByIndexReturnedNull:
      return "kWinMediaFoundationGetBufferByIndexReturnedNull";
    case VideoCaptureFrameDropReason::kBufferPoolMaxBufferCountExceeded:
      return "kBufferPoolMaxBufferCountExceeded";
    case VideoCaptureFrameDropReason::kBufferPoolBufferAllocationFailed:
      return "kBufferPoolBufferAllocationFailed";
    case VideoCaptureFrameDropReason::kVideoCaptureImplNotInStartedState:
      return "kVideoCaptureImplNotInStartedState";
    case VideoCaptureFrameDropReason::kVideoCaptureImplFailedToWrapDataAsMediaVideoFrame:
      return "kVideoCaptureImplFailedToWrapDataAsMediaVideoFrame";
    case VideoCaptureFrameDropReason::kVideoTrackAdapterHasNoResolutionAdapters:
      return "kVideoTrackAdapterHasNoResolutionAdapters";
    case VideoCaptureFrameDropReason::kResolutionAdapterFrameIsNotValid:
      return "kResolutionAdapterFrameIsNotValid";
    case VideoCaptureFrameDropReason::kResolutionAdapterWrappingFrameForCroppingFailed:
      return "kResolutionAdapterWrappingFrameForCroppingFailed";
    case VideoCaptureFrameDropReason::kResolutionAdapterTimestampTooCloseToPrevious:
      return "kResolutionAdapterTimestampTooCloseToPrevious";
    case VideoCaptureFrameDropReason::kResolutionAdapterFrameRateIsHigherThanRequested:
      return "kResolutionAdapterFrameRateIsHigherThanRequested";
    case VideoCaptureFrameDropReason::kResolutionAdapterHasNoCallbacks:
      return "kResolutionAdapterHasNoCallbacks";
    case VideoCaptureFrameDropReason::kVideoTrackFrameDelivererNotEnabledReplacingWithBlackFrame:
      return "kVideoTrackFrameDelivererNotEnabledReplacingWithBlackFrame";
    case VideoCaptureFrameDropReason::kRendererSinkFrameDelivererIsNotStarted:
      return "kRendererSinkFrameDelivererIsNotStarted";
    default:
      return nullptr;
  }
}

std::string VideoCaptureFrameDropReasonToString(VideoCaptureFrameDropReason value) {
  const char *str = VideoCaptureFrameDropReasonToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown VideoCaptureFrameDropReason value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, VideoCaptureFrameDropReason value) {
  return os << VideoCaptureFrameDropReasonToString(value);
}

static NOINLINE const char* CropRequestResultToStringHelper(CropRequestResult value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case CropRequestResult::kSuccess:
      return "kSuccess";
    case CropRequestResult::kErrorGeneric:
      return "kErrorGeneric";
    case CropRequestResult::kUnsupportedCaptureDevice:
      return "kUnsupportedCaptureDevice";
    case CropRequestResult::kNotImplemented:
      return "kNotImplemented";
    case CropRequestResult::kNonIncreasingCropVersion:
      return "kNonIncreasingCropVersion";
    case CropRequestResult::kInvalidCropTarget:
      return "kInvalidCropTarget";
    default:
      return nullptr;
  }
}

std::string CropRequestResultToString(CropRequestResult value) {
  const char *str = CropRequestResultToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown CropRequestResult value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, CropRequestResult value) {
  return os << CropRequestResultToString(value);
}

namespace internal {


// static
bool VideoCaptureControlSupport_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 16, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const VideoCaptureControlSupport_Data* object =
      static_cast<const VideoCaptureControlSupport_Data*>(data);

  return true;
}

VideoCaptureControlSupport_Data::VideoCaptureControlSupport_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool VideoCaptureFormat_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 24, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const VideoCaptureFormat_Data* object =
      static_cast<const VideoCaptureFormat_Data*>(data);

  if (!mojo::internal::ValidatePointerNonNullable(
          object->frame_size, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->frame_size, validation_context))
    return false;


  if (!::media::mojom::internal::VideoCapturePixelFormat_Data
        ::Validate(object->pixel_format, validation_context))
    return false;

  return true;
}

VideoCaptureFormat_Data::VideoCaptureFormat_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool VideoCaptureParams_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 32, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const VideoCaptureParams_Data* object =
      static_cast<const VideoCaptureParams_Data*>(data);

  if (!mojo::internal::ValidatePointerNonNullable(
          object->requested_format, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->requested_format, validation_context))
    return false;


  if (!::media::mojom::internal::VideoCaptureBufferType_Data
        ::Validate(object->buffer_type, validation_context))
    return false;


  if (!::media::mojom::internal::ResolutionChangePolicy_Data
        ::Validate(object->resolution_change_policy, validation_context))
    return false;


  if (!::media::mojom::internal::PowerLineFrequency_Data
        ::Validate(object->power_line_frequency, validation_context))
    return false;

  return true;
}

VideoCaptureParams_Data::VideoCaptureParams_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool VideoCaptureFeedback_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  static constexpr mojo::internal::StructVersionSize kVersionSizes[] = {
    { 0, 32 },
    { 1, 40 },
    { 2, 40 },
  };
  if (!ValidateStructHeaderAndVersionSizeAndClaimMemory(
          data, kVersionSizes, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const VideoCaptureFeedback_Data* object =
      static_cast<const VideoCaptureFeedback_Data*>(data);
  if (object->header_.version < 1)
    return true;

  const mojo::internal::ContainerValidateParams mapped_sizes_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->mapped_sizes, validation_context,
                                         &mapped_sizes_validate_params)) {
    return false;
  }

  return true;
}

VideoCaptureFeedback_Data::VideoCaptureFeedback_Data()
    : header_({sizeof(*this), 2}) {}


// static
bool PlaneStrides_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 16, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const PlaneStrides_Data* object =
      static_cast<const PlaneStrides_Data*>(data);

  if (!mojo::internal::ValidatePointerNonNullable(
          object->stride_by_plane, 1, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams stride_by_plane_validate_params(
      4, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->stride_by_plane, validation_context,
                                         &stride_by_plane_validate_params)) {
    return false;
  }

  return true;
}

PlaneStrides_Data::PlaneStrides_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool VideoCaptureDeviceDescriptor_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 56, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const VideoCaptureDeviceDescriptor_Data* object =
      static_cast<const VideoCaptureDeviceDescriptor_Data*>(data);

  if (!mojo::internal::ValidatePointerNonNullable(
          object->display_name, 1, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams display_name_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->display_name, validation_context,
                                         &display_name_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->device_id, 2, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams device_id_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->device_id, validation_context,
                                         &device_id_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->model_id, 3, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams model_id_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->model_id, validation_context,
                                         &model_id_validate_params)) {
    return false;
  }


  if (!::media::mojom::internal::VideoFacingMode_Data
        ::Validate(object->facing_mode, validation_context))
    return false;


  if (!::media::mojom::internal::VideoCaptureApi_Data
        ::Validate(object->capture_api, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->control_support, 6, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->control_support, validation_context))
    return false;


  if (!::media::mojom::internal::VideoCaptureTransportType_Data
        ::Validate(object->transport_type, validation_context))
    return false;

  return true;
}

VideoCaptureDeviceDescriptor_Data::VideoCaptureDeviceDescriptor_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool VideoCaptureDeviceInfo_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 24, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const VideoCaptureDeviceInfo_Data* object =
      static_cast<const VideoCaptureDeviceInfo_Data*>(data);

  if (!mojo::internal::ValidatePointerNonNullable(
          object->descriptor, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->descriptor, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->supported_formats, 2, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams supported_formats_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->supported_formats, validation_context,
                                         &supported_formats_validate_params)) {
    return false;
  }

  return true;
}

VideoCaptureDeviceInfo_Data::VideoCaptureDeviceInfo_Data()
    : header_({sizeof(*this), 0}) {}

}  // namespace internal
}  // namespace mojom
}  // namespace media

namespace perfetto {

// static
void TraceFormatTraits<::media::mojom::VideoCapturePixelFormat>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::mojom::VideoCapturePixelFormat value) {
  return std::move(context).WriteString(::media::mojom::VideoCapturePixelFormatToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::mojom::ResolutionChangePolicy>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::mojom::ResolutionChangePolicy value) {
  return std::move(context).WriteString(::media::mojom::ResolutionChangePolicyToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::mojom::PowerLineFrequency>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::mojom::PowerLineFrequency value) {
  return std::move(context).WriteString(::media::mojom::PowerLineFrequencyToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::mojom::VideoFacingMode>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::mojom::VideoFacingMode value) {
  return std::move(context).WriteString(::media::mojom::VideoFacingModeToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::mojom::VideoCaptureApi>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::mojom::VideoCaptureApi value) {
  return std::move(context).WriteString(::media::mojom::VideoCaptureApiToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::mojom::VideoCaptureTransportType>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::mojom::VideoCaptureTransportType value) {
  return std::move(context).WriteString(::media::mojom::VideoCaptureTransportTypeToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::mojom::VideoCaptureBufferType>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::mojom::VideoCaptureBufferType value) {
  return std::move(context).WriteString(::media::mojom::VideoCaptureBufferTypeToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::mojom::VideoCaptureError>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::mojom::VideoCaptureError value) {
  return std::move(context).WriteString(::media::mojom::VideoCaptureErrorToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::mojom::VideoCaptureFrameDropReason>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::mojom::VideoCaptureFrameDropReason value) {
  return std::move(context).WriteString(::media::mojom::VideoCaptureFrameDropReasonToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::media::mojom::CropRequestResult>::WriteIntoTrace(
   perfetto::TracedValue context, ::media::mojom::CropRequestResult value) {
  return std::move(context).WriteString(::media::mojom::CropRequestResultToString(value));
}

} // namespace perfetto