// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/device_info_specifics.proto

package org.chromium.components.sync.protocol;

public interface PhoneAsASecurityKeySpecificFieldsOrBuilder extends
    // @@protoc_insertion_point(interface_extends:sync_pb.PhoneAsASecurityKeySpecificFields)
    com.google.protobuf.MessageLiteOrBuilder {

  /**
   * <pre>
   * The encoded tunnel server in the same format as in the BLE advert. See
   * device::cablev2::tunnelserver::DecodeDomain. (Actually a uint16 but
   * proto doesn't have that as a type.)
   * </pre>
   *
   * <code>optional uint32 tunnel_server_domain = 1;</code>
   * @return Whether the tunnelServerDomain field is set.
   */
  boolean hasTunnelServerDomain();
  /**
   * <pre>
   * The encoded tunnel server in the same format as in the BLE advert. See
   * device::cablev2::tunnelserver::DecodeDomain. (Actually a uint16 but
   * proto doesn't have that as a type.)
   * </pre>
   *
   * <code>optional uint32 tunnel_server_domain = 1;</code>
   * @return The tunnelServerDomain.
   */
  int getTunnelServerDomain();

  /**
   * <pre>
   * An FCM token that can be presented to the tunnel server to contact this
   * device.
   * </pre>
   *
   * <code>optional bytes contact_id = 2;</code>
   * @return Whether the contactId field is set.
   */
  boolean hasContactId();
  /**
   * <pre>
   * An FCM token that can be presented to the tunnel server to contact this
   * device.
   * </pre>
   *
   * <code>optional bytes contact_id = 2;</code>
   * @return The contactId.
   */
  com.google.protobuf.ByteString getContactId();

  /**
   * <pre>
   * A shared secret key, used to enable communication across devices via
   * unauthenticated channels. Knowledge of this secret acts as proof that the
   * remote end is authorized to talk to the device publishing this secret.
   * </pre>
   *
   * <code>optional bytes secret = 3;</code>
   * @return Whether the secret field is set.
   */
  boolean hasSecret();
  /**
   * <pre>
   * A shared secret key, used to enable communication across devices via
   * unauthenticated channels. Knowledge of this secret acts as proof that the
   * remote end is authorized to talk to the device publishing this secret.
   * </pre>
   *
   * <code>optional bytes secret = 3;</code>
   * @return The secret.
   */
  com.google.protobuf.ByteString getSecret();

  /**
   * <pre>
   * An id that identifies |secret|. This, and |secret|, will be rotated and
   * the ID allows this device to know which |secret| the counterparty is
   * using.
   * </pre>
   *
   * <code>optional fixed32 id = 4;</code>
   * @return Whether the id field is set.
   */
  boolean hasId();
  /**
   * <pre>
   * An id that identifies |secret|. This, and |secret|, will be rotated and
   * the ID allows this device to know which |secret| the counterparty is
   * using.
   * </pre>
   *
   * <code>optional fixed32 id = 4;</code>
   * @return The id.
   */
  int getId();

  /**
   * <pre>
   * A P-256, X9.62-encoded public key for this device. Specific to the Chrome
   * instance.
   * </pre>
   *
   * <code>optional bytes peer_public_key_x962 = 5;</code>
   * @return Whether the peerPublicKeyX962 field is set.
   */
  boolean hasPeerPublicKeyX962();
  /**
   * <pre>
   * A P-256, X9.62-encoded public key for this device. Specific to the Chrome
   * instance.
   * </pre>
   *
   * <code>optional bytes peer_public_key_x962 = 5;</code>
   * @return The peerPublicKeyX962.
   */
  com.google.protobuf.ByteString getPeerPublicKeyX962();
}
