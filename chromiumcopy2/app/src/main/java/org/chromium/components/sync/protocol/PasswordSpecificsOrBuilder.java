// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/password_specifics.proto

package org.chromium.components.sync.protocol;

public interface PasswordSpecificsOrBuilder extends
    // @@protoc_insertion_point(interface_extends:sync_pb.PasswordSpecifics)
    com.google.protobuf.MessageLiteOrBuilder {

  /**
   * <pre>
   * The actual password data. Contains an encrypted PasswordSpecificsData
   * message.
   * </pre>
   *
   * <code>optional .sync_pb.EncryptedData encrypted = 1;</code>
   * @return Whether the encrypted field is set.
   */
  boolean hasEncrypted();
  /**
   * <pre>
   * The actual password data. Contains an encrypted PasswordSpecificsData
   * message.
   * </pre>
   *
   * <code>optional .sync_pb.EncryptedData encrypted = 1;</code>
   * @return The encrypted.
   */
  org.chromium.components.sync.protocol.EncryptedData getEncrypted();

  /**
   * <pre>
   * An unsynced field for use internally on the client. This field should
   * never be set in any network-based communications because it contains
   * unencrypted material.
   * </pre>
   *
   * <code>optional .sync_pb.PasswordSpecificsData client_only_encrypted_data = 2;</code>
   * @return Whether the clientOnlyEncryptedData field is set.
   */
  boolean hasClientOnlyEncryptedData();
  /**
   * <pre>
   * An unsynced field for use internally on the client. This field should
   * never be set in any network-based communications because it contains
   * unencrypted material.
   * </pre>
   *
   * <code>optional .sync_pb.PasswordSpecificsData client_only_encrypted_data = 2;</code>
   * @return The clientOnlyEncryptedData.
   */
  org.chromium.components.sync.protocol.PasswordSpecificsData getClientOnlyEncryptedData();

  /**
   * <pre>
   * Password related metadata, which is sent to the server side. The field
   * should never be set for full encryption users. If encryption is enabled,
   * this field must be cleared.
   * </pre>
   *
   * <code>optional .sync_pb.PasswordSpecificsMetadata unencrypted_metadata = 3;</code>
   * @return Whether the unencryptedMetadata field is set.
   */
  boolean hasUnencryptedMetadata();
  /**
   * <pre>
   * Password related metadata, which is sent to the server side. The field
   * should never be set for full encryption users. If encryption is enabled,
   * this field must be cleared.
   * </pre>
   *
   * <code>optional .sync_pb.PasswordSpecificsMetadata unencrypted_metadata = 3;</code>
   * @return The unencryptedMetadata.
   */
  org.chromium.components.sync.protocol.PasswordSpecificsMetadata getUnencryptedMetadata();

  /**
   * <pre>
   * An encrypted backup of the notes field inside the PasswordSpecificsData.
   * The Sync server preserves the contents of this field across commits from
   * legacy clients that don't set this field. It is the responsibility of Sync
   * clients to populate the contents of PasswordSpecificsData notes fields
   * using the contents of this field. This should be deprecated together with
   * the logic for preserving it on the server when clients without support for
   * the |notes| field are no longer allowed by the server (below support
   * version horizon).
   * Encryption key considerations:
   * a) For commits, the client must use the same key for both encrypted blobs.
   * b) For handling getupdates, the two keys may NOT necessarily match the
   *    encryption key used, as in theory the new blob could be "behind" if key
   *    rotation took place. As of today, it is safe to assume that if
   *    |encrypted| is decryptable by a client, then |encrypted_notes_backup|
   *    must be decryptable too (i.e. the Nigori keybag should include older
   *    versions of the key). But not the other way round.
   * If both `encrypted_notes_backup` and the `notes` in `encrypted` are
   * populated, the one in notes is considered the authoritative value.
   * </pre>
   *
   * <code>optional .sync_pb.EncryptedData encrypted_notes_backup = 4;</code>
   * @return Whether the encryptedNotesBackup field is set.
   */
  boolean hasEncryptedNotesBackup();
  /**
   * <pre>
   * An encrypted backup of the notes field inside the PasswordSpecificsData.
   * The Sync server preserves the contents of this field across commits from
   * legacy clients that don't set this field. It is the responsibility of Sync
   * clients to populate the contents of PasswordSpecificsData notes fields
   * using the contents of this field. This should be deprecated together with
   * the logic for preserving it on the server when clients without support for
   * the |notes| field are no longer allowed by the server (below support
   * version horizon).
   * Encryption key considerations:
   * a) For commits, the client must use the same key for both encrypted blobs.
   * b) For handling getupdates, the two keys may NOT necessarily match the
   *    encryption key used, as in theory the new blob could be "behind" if key
   *    rotation took place. As of today, it is safe to assume that if
   *    |encrypted| is decryptable by a client, then |encrypted_notes_backup|
   *    must be decryptable too (i.e. the Nigori keybag should include older
   *    versions of the key). But not the other way round.
   * If both `encrypted_notes_backup` and the `notes` in `encrypted` are
   * populated, the one in notes is considered the authoritative value.
   * </pre>
   *
   * <code>optional .sync_pb.EncryptedData encrypted_notes_backup = 4;</code>
   * @return The encryptedNotesBackup.
   */
  org.chromium.components.sync.protocol.EncryptedData getEncryptedNotesBackup();
}
